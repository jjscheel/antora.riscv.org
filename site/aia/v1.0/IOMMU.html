<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Untitled :: RISC-V Ratified Specifications Library</title>
    <link rel="prev" href="IPIs.html">
    <meta name="generator" content="Antora 3.1.12">
    <script>
!function (theme, navWidth) {
  if (theme === 'dark') document.documentElement.classList.add('dark-theme')
  if (navWidth) document.documentElement.style.setProperty('--nav-width', `${navWidth}px`)
}(localStorage && localStorage.getItem('theme') || (matchMedia('(prefers-color-scheme: dark)')?.matches && 'dark'),
  localStorage && localStorage.getItem('nav-width'))
    </script>
    <link rel="stylesheet" href="../../_/css/site.css">
    <link rel="stylesheet" href="../../_/css/vendor/search.css">
    <link rel="stylesheet" href="../../_/css/vendor/page-search.css">
    <link rel="stylesheet" href="../../_/css/vendor/spring-tabs.css">

    <meta name="antora-ui-version" content="24b0ea9bb868390e1ef3290e476fd66788c083d5"> 
    <meta name="version" content="v1.0">
    <meta name="component" content="aia">
    <meta name="latest-version" content="false">
    <link rel="icon" href="../../_/img/favicon.ico" type="image/vnd.microsoft.icon">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../..">RISC-V Ratified Specifications Library</a>
      <button class="navbar-burger" aria-controls="topbar-nav" aria-expanded="false" aria-label="Toggle main menu">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="aia" data-version="v1.0">
  <aside class="nav">
    <div class="panels">
      <div class="nav-panel-menu is-active" data-panel="menu">
        <nav class="nav-menu">
<div class="context">
  <span class="title">Advanced Interrupt Architecture</span>
  <span class="version">v1.0</span>
  <button class="browse-version" id="browse-version">
    <svg
      height="24px"
      id="Layer_1"
      style="enable-background:new 0 0 512 512;"
      version="1.1"
      viewBox="0 0 512 512"
      width="24px"
      xml:space="preserve"
    ><g><path
          d="M256,224c-17.7,0-32,14.3-32,32s14.3,32,32,32c17.7,0,32-14.3,32-32S273.7,224,256,224L256,224z"
        ></path><path
          d="M128.4,224c-17.7,0-32,14.3-32,32s14.3,32,32,32c17.7,0,32-14.3,32-32S146,224,128.4,224L128.4,224z"
        ></path><path
          d="M384,224c-17.7,0-32,14.3-32,32s14.3,32,32,32s32-14.3,32-32S401.7,224,384,224L384,224z"
        ></path></g></svg>
  </button>
  </div><ul class="nav-list">
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">RISC-V Advanced Interrupt Architecture</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="intro.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="CSRs.html">Control and Status Registers (CSRs) Added to Harts</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="IMSIC.html">Incoming MSI Controller (IMSIC)</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="AdvPLIC.html">Advanced Platform-Level Interrupt Controller (APLIC)</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="MSLevel.html">Interrupts for Machine and Supervisor Levels</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="VSLevel.html">Interrupts for Virtual Machines (VS Level)</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="IPIs.html">Interprocessor Interrupts (IPIs)</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link"  href="IOMMU.html">IOMMU Support for MSIs to Virtual Machines</a>
  </li>
</ul>
  </li>
</ul>
          <div class="toggle-sm">
            <button id="nav-toggle-2" class="nav-toggle"></button>
          </div>
        </nav>
      </div>
      <div class="nav-collapse">
        <button id="nav-collapse-toggle"><span></span></button>        
      </div>
    </div>
    <div class="nav-resize"></div>
  </aside>
</div>
<script>
!function (sidebar) {
  if (sidebar) {
    document.body.classList.add('nav-sm')
  }
}(localStorage && localStorage.getItem('sidebar') === 'close')
</script><main class="article">
<div class="toolbar" role="navigation">
  <button id="nav-toggle-1" class="nav-toggle"></button>
</div>
  <div class="content">
<aside class="sidebar">
  <div class="content">
    <div
      class="toc"
      data-title=""
      data-levels="2"
    >
      <div class="toc-menu"></div>
    </div>
    <div class="sidebar-links">
        <a href="https://github.com/riscv/riscv-aia/edit/antora-refactor/modules/ROOT/pages/IOMMU.adoc">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            height="24"
            viewBox="0 0 24 24"
            width="24"
          ><path
              d="m16 2.012 3 3L16.713 7.3l-3-3zM4 14v3h3l8.299-8.287-3-3zm0 6h16v2H4z"
            ></path></svg>
          Edit this Page
        </a>
              <a href="https://github.com/riscv/riscv-aia" title="GitHub">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            height="512px"
            id="Layer_1"
            version="1.1"
            viewBox="0 0 512 512"
            width="512px"
          ><style type="text/css"><![CDATA[
              .st0{fill-rule:evenodd;clip-rule:evenodd;} ]]></style><g><path
                class="st0"
                d="M256,32C132.3,32,32,134.8,32,261.7c0,101.5,64.2,187.5,153.2,217.9c11.2,2.1,15.3-5,15.3-11.1   c0-5.5-0.2-19.9-0.3-39.1c-62.3,13.9-75.5-30.8-75.5-30.8c-10.2-26.5-24.9-33.6-24.9-33.6c-20.3-14.3,1.5-14,1.5-14   c22.5,1.6,34.3,23.7,34.3,23.7c20,35.1,52.4,25,65.2,19.1c2-14.8,7.8-25,14.2-30.7c-49.7-5.8-102-25.5-102-113.5   c0-25.1,8.7-45.6,23-61.6c-2.3-5.8-10-29.2,2.2-60.8c0,0,18.8-6.2,61.6,23.5c17.9-5.1,37-7.6,56.1-7.7c19,0.1,38.2,2.6,56.1,7.7   c42.8-29.7,61.5-23.5,61.5-23.5c12.2,31.6,4.5,55,2.2,60.8c14.3,16.1,23,36.6,23,61.6c0,88.2-52.4,107.6-102.3,113.3   c8,7.1,15.2,21.1,15.2,42.5c0,30.7-0.3,55.5-0.3,63c0,6.1,4,13.3,15.4,11C415.9,449.1,480,363.1,480,261.7   C480,134.8,379.7,32,256,32z"
              ></path></g></svg>
          GitHub Project
        </a>
    </div>
  </div>
</aside>
<article class="doc">
<div class="breadcrumbs-container">
  <nav class="breadcrumbs" aria-label="breadcrumbs">
    <ul>
      <li><a href="index.html">Advanced Interrupt Architecture</a></li>
      <li>RISC-V Advanced Interrupt Architecture</li>
      <li><a href="IOMMU.html">IOMMU Support for MSIs to Virtual Machines</a></li>
    </ul>
  </nav>
</div><div class="sect1">
<h2 id="IOMMU"><a class="anchor" href="#IOMMU"></a>IOMMU Support for MSIs to Virtual Machines</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The existence of an IOMMU in a system makes it possible for a guest
operating system, running in a virtual machine, to be given direct
control of an I/O device with only minimal hypervisor intervention. A
guest OS with direct control of a device will program the device with
guest physical addresses, because that is all the OS knows. When the
device then performs memory accesses using those addresses, an IOMMU is
responsible for translating those guest physical addresses into machine
physical addresses, referencing address-translation data structures
supplied by the hypervisor.</p>
</div>
<div class="paragraph">
<p>To handle MSIs from a device controlled by a guest OS, an IOMMU must be
able to redirect those MSIs to a guest interrupt file in an IMSIC.
Systems that do not have IMSICs with guest interrupt files do not need
to implement the facilities described in this chapter.</p>
</div>
<div class="paragraph">
<p>Because MSIs from devices are simply memory writes, they would naturally
be subject to the same address translation that an IOMMU applies to
other memory writes. However, the Advanced Interrupt Architecture
requires that IOMMUs treat MSIs directed to virtual machines specially,
in part to simplify software, and in part to allow optional support for
<em>memory-resident interrupt files</em>.</p>
</div>
<div class="paragraph">
<p>This chapter uses the term <em>IOMMU</em> in a generic sense that encompasses
all translation and transaction processing services required to
virtualize device accesses and is concerned only with how an IOMMU
recognizes and processes MSIs directed to virtual machines. Most other
functions and details of an IOMMU are beyond the scope of this standard,
and must be specified elsewhere.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The RISC-V IOMMU Architecture Specification provides a detailed description of
the IOMMU architecture, dividing translation and transaction processing
functionality into blocks such as IOMMU, IO Bridge, etc. and describing
how those blocks are integrated into a system.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If a single physical I/O device can be subdivided for control by
multiple separate device drivers, each sub-device is referred to here as
one device.</p>
</div>
<div class="sect2">
<h3 id="IOMMU-deviceContexts"><a class="anchor" href="#IOMMU-deviceContexts"></a>Device contexts at an IOMMU</h3>
<div class="paragraph">
<p>The following assumptions are made about the IOMMUs in a system:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For each I/O device connected to the system through an IOMMU, software
can configure at the IOMMU a <em>device context</em>, which associates with the
device a specific virtual address space and any other per-device
parameters the IOMMU may support. By giving devices each their own
separate device context at an IOMMU, each device can be individually
configured for a separate operating system, which may be a guest OS or
the main (host) OS. On every memory access initiated by a device,
hardware indicates to the IOMMU the originating device by some form of
unique device identifier, which the IOMMU uses to locate the appropriate
device context within data structures supplied by software. For PCI, for
example, the originating device may be identified by the unique triple
of PCI bus number, device number, and function number.</p>
</li>
<li>
<p>An IOMMU optionally translates the addresses of a device&#8217;s memory
accesses using address-translation data structures—typically page
tables—specified by software via the corresponding device context. The
smallest granularity of address translation implemented by all IOMMUs is
not larger than a 4-KiB page, matching that of standard RISC-V
address-translation page tables. (An IOMMU may in fact employ page
tables in the same format as the page-based address translation defined
by the RISC-V Privileged Architecture, but this is not required.)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Advanced Interrupt Architecture adds to device contexts these
fields, as needed:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>an <em>MSI address mask</em> and <em>address pattern</em>, used together to identify
pages in the guest physical address space that are the destinations of
MSIs; and</p>
</li>
<li>
<p>the real physical address of an <em>MSI page table</em> for controlling the
translation and/or conversion of MSIs from the device.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The MSI address mask and address pattern are each unsigned integers with
the same width as guest physical page numbers, i.e., 12 bits narrower
than the maximum supported width of a guest physical address. Their use
is explained in <a href="#IOMMU-identIncomingMSIs">Identification of page addresses of a VM&#8217;s interrupt files</a>.</p>
</div>
<div class="paragraph">
<p>A device context&#8217;s MSI page table is separate from the usual
address-translation data structures used to translate other memory
accesses from the same device. The form and function of MSI page tables
are the subject of most of the rest of this chapter.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A device context is given an independent page table for MSIs for two
reasons:</p>
</div>
<div class="paragraph">
<p>First, hypervisors running under Linux or a similar OS can benefit from
separate control of MSI translations to help simplify the case when
virtual harts are migrated from one physical hart to another. As noted
in <a href="#virtHartMigration">[virtHartMigration]</a>, when a
virtual hart&#8217;s interrupt files are mapped to guest interrupt files in
the real machine, migration of the virtual hart causes the physical
guest interrupt files underlying those virtual interrupt files to
change. However, because on other systems (not RISC-V) the migration of a
virtual hart does not affect the mapping from guest physical addresses
to real physical addresses, the internal functions of Linux that perform
this migration are not set up to modify an IOMMU&#8217;s address-translation
tables to adjust for the changing physical locations of RISC-V virtual
interrupt files. Giving a hypervisor control of a separate MSI
translation table at an IOMMU bypasses this limitation. The MSI page
table can be modified at will by the hypervisor and/or by the subsystem
that manages interrupts without coordinating with the many other OS
components concerned with regular address translation.</p>
</div>
<div class="paragraph">
<p>Second, specifying a separate MSI page table facilitates the use of
<em>memory-resident interrupt files</em> (MRIFs), which are introduced in
<a href="#IOMMU-MRIFs">Memory-resident interrupt files</a>. A dedicated MSI page table can easily
support a special table entry format for MRIFs
(<a href="#IOMMU-MSIPTE-MRIF">MSI PTE, MRIF mode</a>) that would be entirely foreign
and difficult to retrofit to any other address-translation data
structures.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="translation-of-addresses-for-msis-from-devices"><a class="anchor" href="#translation-of-addresses-for-msis-from-devices"></a>Translation of addresses for MSIs from devices</h3>
<div class="paragraph">
<p>To support the delivery of MSIs from I/O devices directly to RISC-V virtual
machines without hypervisor intervention, an IOMMU must be able to
translate the guest physical address of an MSI to the real physical
address of an IMSIC’s guest interrupt file in the machine, as
illustrated in <a href="#IOMMU-guestIntrFiles">Translation of a device-sourced MSI that a guest OS intended to go to a (virtual) IMSIC interrupt file in the OS&#8217;s virtual machine. Referencing an MSI page table supplied by the controlling hypervisor, the IOMMU redirects the MSI to a guest interrupt file of the real machine.</a>. This address
translation is controlled by the MSI page table configured in the
appropriate device context at the IOMMU. Because every interrupt file,
real or virtual, occupies a naturally aligned 4-KiB page of address
space, the required address translation is from a virtual (guest) page
address to a physical page address, the same as supported by regular RISC-V
page-based address translation.</p>
</div>
<div id="IOMMU-guestIntrFiles" class="imageblock unresolved">
<div class="content">
<img src="IOMMU-guestIntrFiles.png" alt="IOMMU guestIntrFiles">
</div>
<div class="title">Figure 1. Translation of a device-sourced MSI that a guest OS intended to go to a (virtual) IMSIC interrupt file in the OS&#8217;s virtual machine. Referencing an MSI page table supplied by the controlling hypervisor, the IOMMU redirects the MSI to a guest interrupt file of the real machine.</div>
</div>
<div class="paragraph">
<p>Memory writes from a device are recognized as MSIs by the destination
address of the write. If an IOMMU determines that a 32-bit write is to
the location of a (virtual) interrupt file in the relevant virtual
machine, the write is considered an MSI within the VM, else not. The
exact formula for recognizing MSIs is documented in
<a href="#IOMMU-identIncomingMSIs">Identification of page addresses of a VM&#8217;s interrupt files</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Although the translation of MSIs is controlled by its own separate page
table, the fact that MSI translations are at the same page granularity
as regular RISC-V address translations implies that an address translation
cache within an IOMMU requires little modification to also cache MSI
translations. Only on a translation cache miss does the IOMMU need to
treat MSIs significantly differently than other memory accesses from the
same device, to choose the correct translation table and to access and
interpret the table properly.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="IOMMU-MRIFs"><a class="anchor" href="#IOMMU-MRIFs"></a>Memory-resident interrupt files</h3>
<div class="paragraph">
<p>An IOMMU may optionally support memory-resident interrupt files (MRIFs).
If implemented, the use of memory-resident interrupt files can greatly
increase the number of virtual harts that can be given direct control of
one or more physical devices in a system, assuming the rest of the
system can still handle the added load.</p>
</div>
<div class="paragraph">
<p>Without memory-resident interrupt files, the number of virtual RISC-V harts
that can directly receive MSIs from devices is limited by the total
number of guest interrupt files implemented by all IMSICs in the system,
because all MSIs to RISC-V harts must go through IMSICs. For a single RISC-V hart, the
number of guest interrupt files is the <em>GEILEN</em> parameter defined by the
H extension, which can be at most 31 for RV32 and 63 for
RV64.</p>
</div>
<div class="paragraph">
<p>With the use of memory-resident interrupt files, on the other hand, the
total number of virtual RISC-V harts able to receive device MSIs is almost
unbounded, constrained only by the amount of real physical memory and
the additional processing time needed to handle them. As its name
implies, a memory-resident interrupt file is located in memory instead
of within an IMSIC. <a href="#IOMMU-MRIF">Recording an incoming MSI into a memory-resident interrupt file (MRIF) instead of sending it to a guest interrupt file as in Translation of a device-sourced MSI that a guest OS intended to go to a (virtual) IMSIC interrupt file in the OS&#8217;s virtual machine. Referencing an MSI page table supplied by the controlling hypervisor, the IOMMU redirects the MSI to a guest interrupt file of the real machine..</a> depicts how an IOMMU can
record an incoming MSI in an MRIF. When properly configured by a
hypervisor, an IOMMU recognizes certain incoming MSIs as intended for a
specific virtual interrupt file, and records each such MSI by setting an
interrupt-pending bit stored within the MRIF data structure in ordinary
memory. After each MSI is recorded in an MRIF, the IOMMU also sends a
<em>notice MSI</em> to the hypervisor to inform it that the MRIF contents may
have changed.</p>
</div>
<div id="IOMMU-MRIF" class="imageblock unresolved">
<div class="content">
<img src="IOMMU-MRIF.png" alt="IOMMU MRIF">
</div>
<div class="title">Figure 2. Recording an incoming MSI into a memory-resident interrupt file (MRIF) instead of sending it to a guest interrupt file as in <a href="#IOMMU-guestIntrFiles">Translation of a device-sourced MSI that a guest OS intended to go to a (virtual) IMSIC interrupt file in the OS&#8217;s virtual machine. Referencing an MSI page table supplied by the controlling hypervisor, the IOMMU redirects the MSI to a guest interrupt file of the real machine.</a>.</div>
</div>
<div class="paragraph">
<p>While a memory-resident interrupt file provides a place to record MSIs,
it cannot interrupt a hart directly the way an IMSIC&#8217;s guest interrupt
files can. The notice MSIs that hypervisors receive only indicate that a
virtual hart <em>might</em> need interrupting; a hypervisor is responsible for
examining the MRIF contents each time to determine whether actually to
interrupt the virtual hart. Furthermore, whereas an IMSIC&#8217;s guest
interrupt file can directly act as a supervisor-level interrupt file for
a virtual hart, keeping a virtual hart&#8217;s interrupt file in an MRIF while
the virtual hart executes requires that the hypervisor emulate a
supervisor-level interrupt file for the virtual hart, hiding the
underlying MRIF. Depending on how often the virtual hart touches its
interrupt file and the implementation&#8217;s level of support for MRIFs, the
cost of this emulation may be significant.</p>
</div>
<div class="paragraph">
<p>Consequently, MRIFs are expected most often to be used for virtual harts
that are more-or-less "swapped out" of a physical hart due to being
idle, or nearly so. When a hypervisor determines that an MSI that landed
in an MRIF should wake up a particular virtual hart that was idle, the
virtual hart can be assigned a guest interrupt file in an IMSIC and its
interrupt file moved from the MRIF into this guest interrupt file before
the virtual hart is resumed. The process of allocating a guest interrupt
file for the newly wakened virtual hart may of course force the
interrupt file of another virtual hart to be evicted to its own MRIF.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Not all systems need to accommodate large numbers of idle virtual harts.
Many batch-processing servers, for example, strive to keep all virtual
worker threads as busy as possible from start to finish, throttled only
by I/O delays and limits on processing resources. In such environments,
support for MRIFs may not be useful, so long as parameter GEILEN is not
too small.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>An IOMMU can have one of these three levels of support for
memory-resident interrupt files:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>no memory-resident interrupt files;</p>
</li>
<li>
<p>memory-resident interrupt files without atomic update; or</p>
</li>
<li>
<p>memory-resident interrupt files with atomic update.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Memory-resident interrupt files are most efficient when the memory
system supports logical atomic memory operations (AMOs) corresponding to RISC-V
instructions AMOAND and AMOOR, for memory accesses made both from harts
and from the IOMMU. The AMOAND and AMOOR operations are required for
<em>atomic update</em> of a memory-resident interrupt file. A reduced level of
support is possible without AMOs, relying solely on basic memory reads
and writes.</p>
</div>
<div class="sect3">
<h4 id="IOMMU-MRIFFormat"><a class="anchor" href="#IOMMU-MRIFFormat"></a>Format of a memory-resident interrupt file</h4>
<div class="paragraph">
<p>A memory-resident interrupt file occupies 512 bytes of memory, naturally
aligned to a 512-byte address boundary. The 512 bytes are organized as
an array of 32 pairs of 64-bit doublewords, 64 doublewords in all. Each
doubleword is in little-endian byte order (even for systems where all
harts are big-endian-only).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Big-endian-configured harts that make use of MRIFs are expected to
implement the REV8 byte-reversal instruction defined by standard RISC-V
extension Zbb, or pay the cost of endianness conversion using a sequence
of instructions.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The pairs of doublewords contain the interrupt-pending and
interrupt-enable bits for external interrupt identities 1-2047, in this
arrangement:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>offset</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>size</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>contents</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x000</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>8 bytes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>interrupt-pending bits for (minor) identities 1-63</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x008</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>8 bytes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>interrupt-enable bits for identities 1-63</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x010</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>8 bytes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>interrupt-pending bits for identities 64-127</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x018</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>8 bytes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>interrupt-enable bits for identities 64-127</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>…</code></p></td>
<td class="tableblock halign-center valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>…</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1F0</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>8 bytes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>interrupt-pending bits for identities 1984-2047</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1F8</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>8 bytes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>interrupt-enable bits for identities 1984-2047</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>In general, the pair of doublewords at address offsets
\(k\times{16}\) and
\(k\times16+8\) for integer \(k\)
contain the interrupt-pending and interrupt-enable bits for external
interrupt minor identities in the range \(k\times64\)
to \(k\times64+63\). For
identity \(i\) in this range, bit
\((i\bmod 64)\) of the first (even) doubleword is the
interrupt-pending bit, and the same bit of the second (odd) doubleword
is the interrupt-enable bit.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The interrupt-pending and interrupt-enable bits are stored interleaved
by doublewords within an MRIF to facilitate the possibility of an IOMMU
examining the relevant enable bit to determine whether to send a notice
MSI after updating a pending bit, rather than the default behavior of
always sending a notice MSI after an update without regard for the
interrupt-enable bits. The memory arrangement matters only when MRIFs
are supported without atomic update.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Bit 0 of the first doubleword of an MRIF stores a faux interrupt-pending
bit for nonexistent interrupt 0. If a write from an I/O device appears
to be an MSI that should be stored in an MRIF, yet the data to write
(the interrupt identity) is zero, the IOMMU acts as though zero were a
valid interrupt identity, setting bit 0 of the target MRIF&#8217;s first
doubleword and sending a notice MSI as usual.</p>
</div>
<div class="paragraph">
<p>All MRIFs are the size to accommodate 2047 valid interrupt identities,
the maximum allowed for an IMSIC interrupt file. If a system’s actual
IMSICs have interrupt files that implement only \(N\)
interrupt identities, \(N &lt; 2047\), then the contents
of MRIFs for identities greater than \(N\) may be ignored by
software. IOMMUs, however, treat every MRIF as though all interrupt
identities in the range 0-2047 are valid, even as software ignores
invalid identity 0 and all identities greater than \(N\).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>There is no need to specify to an IOMMU a desired size \(N\)
for an MRIF smaller than 2047 valid interrupt identities. The only use
an IOMMU would make of this information would be to discard any MSIs
indicating an interrupt identity greater than \(N\). If
devices are properly configured by software, such errant MSIs should not
occur; but even if they do, it is just as effective for software to
ignore spurious interrupt identities <em>after</em> they have been recorded in
an MRIF as for an IOMMU to discard them before recording them in the
MRIF.</p>
</div>
<div class="paragraph">
<p>It is likewise unnecessary for IOMMUs to check for and discard MSIs
indicating an invalid interrupt identity of zero.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="recording-of-incoming-msis-to-memory-resident-interrupt-files"><a class="anchor" href="#recording-of-incoming-msis-to-memory-resident-interrupt-files"></a>Recording of incoming MSIs to memory-resident interrupt files</h4>
<div class="paragraph">
<p>The data component of an MSI write specifies the interrupt identity to
raise in the destination interrupt file. (Recall
<a href="#MSIEncoding">[MSIEncoding]</a>.) This data may be in
little-endian or big-endian byte order. If an IOMMU supports
memory-resident interrupt files, it can store to an MRIF MSIs of the
same endianness that the machine&#8217;s IMSICs accept. All IMSIC interrupt
files are required to accept MSIs in little-endian byte order written to
memory-mapped register <code>seteipnum_le</code> (<a href="#IMSIC-memRegion">[IMSIC-memRegion]</a>). IMSIC interrupt
files may also accept MSIs in big-endian byte order if register <code>seteipnum_be</code> is
implemented alongside <code>seteipnum_le</code>.</p>
</div>
<div class="paragraph">
<p>If the interrupt identity indicated by an MSI&#8217;s data (when interpreted
in the correct byte order) is in the range 0-2047, an IOMMU stores the
MSI to an MRIF by setting to one the interrupt-pending bit in the MRIF
for that identity. If atomic update is supported for MRIFs, the pending
bit is set using an AMOOR operation, else it is set using a non-atomic
read-modify-write sequence. After the interrupt-pending bit is set in
the MRIF, the IOMMU sends the notice MSI that software has configured
for the MRIF.</p>
</div>
<div class="paragraph">
<p>The exact process of storing an MSI to an MRIF is specified more
precisely in <a href="#IOMMU-MSIPTE-MRIF">MSI PTE, MRIF mode</a>, which covers MSI
page table entries configured in <em>MRIF mode</em>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>It is an open question whether an IOMMU might optionally examine the
matching interrupt-enable bit within a destination MRIF to decide
whether to send a notice MSI after setting an interrupt-pending bit.
Currently, an IOMMU is required always to send a notice MSI after
storing an MSI to an MRIF, even when the corresponding enable bit for
the interrupt identity is zero.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="use-of-memory-resident-interrupt-files-with-atomic-update"><a class="anchor" href="#use-of-memory-resident-interrupt-files-with-atomic-update"></a>Use of memory-resident interrupt files with atomic update</h4>
<div class="paragraph">
<p>To make use of a memory-resident interrupt file with support for atomic
update, software must have memory locations to save an IMSIC interrupt
file&#8217;s <code>eidelivery</code> and <code>eithreshold</code> registers, in addition to the MRIF structure itself from <a href="#IOMMU-MRIFFormat">Format of a memory-resident interrupt file</a>.</p>
</div>
<div class="paragraph">
<p>Moving a virtual hart&#8217;s interrupt file from an IMSIC into an MRIF
involves these steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Prepare the MRIF by zeroing all of its interrupt-pending bits (the
even doublewords) and by copying the IMSIC interrupt file&#8217;s <code>eie</code> array to the
MRIF&#8217;s interrupt-enable bits (the odd doublewords).</p>
</li>
<li>
<p>Save to memory the existing values of the IMSIC interrupt file&#8217;s
registers <code>eidelivery</code> and <code>eithreshold</code>, and set <code>eidelivery</code> = 0.</p>
</li>
<li>
<p>Modify all relevant translation tables at IOMMUs so that MSIs for this
virtual interrupt file are now stored in the MRIF. If necessary,
synchronize with all IOMMUs to ensure that no straggler MSIs will arrive
at the IMSIC interrupt file after this step.</p>
</li>
<li>
<p>Logically OR the contents of the IMSIC interrupt file&#8217;s <code>eip</code> array into the
interrupt-pending bits of the MRIF, using AMOOR operations.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Once this sequence is complete, the IMSIC interrupt file is no longer in
use.</p>
</div>
<div class="paragraph">
<p>Each time a notice MSI arrives indicating that an MSI has been stored in
the MRIF, the controlling hypervisor should scan the MRIF&#8217;s
interrupt-pending and interrupt-enable bits to determine if any enabled
interrupt is now both pending and enabled and thus should interrupt the
virtual hart.</p>
</div>
<div class="paragraph">
<p>With atomic update of MRIFs, a virtual hart may continue executing with
its interrupt file contained in an MRIF, so long as the hypervisor
emulates for the virtual hart a proper IMSIC interrupt file to hide the
underlying MRIF. Hypervisor software can safely set and clear the
interrupt-pending and interrupt-enable bits of the MRIF using AMOOR and
AMOAND operations, even as an IOMMU may be storing incoming MSIs into
the same MRIF.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If an IOMMU is ever configured to examine an MRIF&#8217;s interrupt-enable
bits to decide whether to send notice MSIs, then modifying those enable
bits will generally require coordination with the IOMMU. But so long as
IOMMUs ignore the interrupt-enable bits as is currently assumed, the
bits can be changed by software without risk.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To move the same interrupt file from the MRIF back to an IMSIC:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>At the new IMSIC interrupt file, set <code>eidelivery</code> = 0, and zero the <code>eip</code> array.</p>
</li>
<li>
<p>Modify all relevant translation tables at IOMMUs so that MSIs for this
virtual interrupt file are now sent to the IMSIC interrupt file. If
necessary, synchronize with all IOMMUs to ensure that no straggler MSIs
will be stored in the MRIF after this step.</p>
</li>
<li>
<p>Logically OR the interrupt-pending bits from the MRIF into the IMSIC
interrupt file, using instruction CSRS to write to the <code>eip</code> array. Also, copy
the interrupt-enable bits from the MRIF to the IMSIC interrupt file&#8217;s <code>eie</code> array.</p>
</li>
<li>
<p>Load the IMSIC interrupt file&#8217;s registers <code>eithreshold</code> and <code>eidelivery</code> with the values that were earlier saved.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="use-of-memory-resident-interrupt-files-without-atomic-update"><a class="anchor" href="#use-of-memory-resident-interrupt-files-without-atomic-update"></a>Use of memory-resident interrupt files without atomic update</h4>
<div class="paragraph">
<p>Without support for atomic update, the use of memory-resident interrupt
files is similar to the atomic-update case of the previous subsection,
but with some added complexities.</p>
</div>
<div class="paragraph">
<p>First, if the I/O devices that a virtual hart controls are behind
multiple IOMMUs, then multiple MRIF structures are needed, one per
IOMMU, not just a single MRIF structure. Furthermore, in addition to
locations for storing <code>eidelivery</code> and <code>eithreshold</code>, software needs a place for a complete copy
of the interrupt file&#8217;s implemented <code>eip</code> array, apart from the MRIFs. While a
virtual interrupt file is in memory, its interrupt-pending bits will be
split across all the MRIFs and the saved <code>eip</code> array. The interrupt-enable
bits may exist only in the MRIFs.</p>
</div>
<div class="paragraph">
<p>To move a virtual hart&#8217;s interrupt file from an IMSIC into memory, with
one MRIF per IOMMU:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Prepare all MRIFs by zeroing their interrupt-pending bits (the even
doublewords) and by copying the IMSIC interrupt file&#8217;s <code>eie</code> array to the
MRIFs' interrupt-enable bits (the odd doublewords).</p>
</li>
<li>
<p>Save to memory the existing values of the IMSIC interrupt file&#8217;s
registers <code>eidelivery</code> and <code>eithreshold</code>, and set <code>eidelivery</code> = 0.</p>
</li>
<li>
<p>At each IOMMU, modify all relevant translation tables so that MSIs for
this virtual interrupt file are now stored in the individual MRIF
matched to the IOMMU. If necessary, synchronize with all IOMMUs to
ensure that no straggler MSIs will arrive at the IMSIC interrupt file
after this step.</p>
</li>
<li>
<p>Dump the IMSIC interrupt file&#8217;s <code>eip</code> array to its separate location outside
the MRIFs.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Once this sequence is complete, the IMSIC interrupt file is no longer in
use.</p>
</div>
<div class="paragraph">
<p>While a virtual hart&#8217;s interrupt file remains in memory, an interrupt
identity&#8217;s true pending bit is the logical OR of its bit in all MRIFs
and its bit in the saved <code>eip</code> array. All pending bits in the MRIFs start as
zeros, but interrupts may become pending there as MSIs for this virtual
hart arrive at IOMMUs and are stored in the corresponding MRIFs.</p>
</div>
<div class="paragraph">
<p>Without atomic update of MRIFs, an interrupt-pending bit is not easily
cleared in an MRIF. (Clearing a single pending bit in one MRIF requires
that a new MRIF be allocated and initialized and the corresponding IOMMU
reconfigured to store MSIs into the new MRIF.) For this reason, it may
or may not be practical to have a virtual hart execute while keeping one
of its interrupt files in memory. When an MRIF records an interrupt that
should wake a virtual hart, the simplest strategy is to always move the
interrupt file back into an IMSIC&#8217;s guest interrupt file before resuming
execution of the virtual hart.</p>
</div>
<div class="paragraph">
<p>To transfer an interrupt file from memory back to an IMSIC:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>At the new IMSIC interrupt file, set <code>eidelivery</code> = 0, and zero the <code>eip</code> array.</p>
</li>
<li>
<p>Modify all relevant translation tables at IOMMUs so that MSIs for this
virtual interrupt file are now sent to the IMSIC interrupt file. If
necessary, synchronize with all IOMMUs to ensure that no straggler MSIs
will be stored in MRIFs after this step.</p>
</li>
<li>
<p>Merge by bitwise logical OR the interrupt-pending bits of all MRIFs
and the saved <code>eip</code> array, and logically OR these merged bits into the IMSIC
interrupt file, using instruction CSRS to write to the <code>eip</code> array. Also, copy
the interrupt-enable bits from one of the MRIFs to the IMSIC interrupt
file&#8217;s <code>eie</code> array.</p>
</li>
<li>
<p>Load the IMSIC interrupt file&#8217;s registers <code>eithreshold</code> and <code>eidelivery</code> with the values that were earlier saved.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="allocation-of-guest-interrupt-files-for-receiving-notice-msis"><a class="anchor" href="#allocation-of-guest-interrupt-files-for-receiving-notice-msis"></a>Allocation of guest interrupt files for receiving notice MSIs</h4>
<div class="paragraph">
<p>The processing a hypervisor does in response to notice MSIs can be
minimized by assigning a separate interrupt identity for each MRIF, so
the identity encoded in a notice MSI always indicates which one MRIF may
have changed. However, if there are very many MRIFs (potentially in the
thousands), a hypervisor may run short of interrupt identities within
the supervisor-level interrupt files available in IMSICs. In that case,
the hypervisor can increase its supply of interrupt identities by
allocating one or more of the IMSICs’ guest interrupt files to itself
for the purpose of receiving notice MSIs.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Although guest interrupt files exist primarily to act as
supervisor-level interrupt files for virtual harts, the IMSIC hardware
does not police exactly how they are used by software.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="IOMMU-identIncomingMSIs"><a class="anchor" href="#IOMMU-identIncomingMSIs"></a>Identification of page addresses of a VM&#8217;s interrupt files</h3>
<div class="paragraph">
<p>When an I/O device is configured directly by a guest operating system,
MSIs from the device are expected to be targeted to virtual IMSICs
within the guest OS&#8217;s virtual machine, using guest physical addresses
that are inappropriate and unsafe for the real machine. An IOMMU must
recognize certain incoming writes from such devices as MSIs and convert
them as needed for the real machine. (Recall
<a href="#IOMMU-guestIntrFiles">Translation of a device-sourced MSI that a guest OS intended to go to a (virtual) IMSIC interrupt file in the OS&#8217;s virtual machine. Referencing an MSI page table supplied by the controlling hypervisor, the IOMMU redirects the MSI to a guest interrupt file of the real machine.</a>.)</p>
</div>
<div class="paragraph">
<p>MSIs originating from a single device that require conversion are
expected to have been configured at the device by a single guest OS
running within one RISC-V virtual machine. Assuming the VM itself conforms to
the Advanced Interrupt Architecture, MSIs are sent to virtual harts
within the VM by writing to the memory-mapped registers of the interrupt
files of virtual IMSICs. Each of these virtual interrupt files occupies
a separate 4-KiB page in the VM&#8217;s guest physical address space, the same
as real interrupt files do in a real machine&#8217;s physical address space. A
write to a guest physical address can thus be recognized as an MSI to a
virtual hart if the write is to a page occupied by an interrupt file of
a virtual IMSIC within the VM.</p>
</div>
<div class="paragraph">
<p>The MSI address mask and address pattern specified in a device context
(<a href="#IOMMU-deviceContexts">Device contexts at an IOMMU</a>) are used to identify the 4-KiB
pages of virtual interrupt files in the guest physical address space of
the relevant VM. An incoming 32-bit write made by a device is recognized
as an MSI write to a virtual interrupt file if the destination guest
physical page matches the supplied address pattern in all bit positions
that are zeros in the supplied address mask. In detail, a memory access
to guest physical address \(A\) is an access to a virtual
interrupt file’s memory-mapped page if</p>
</div>
<div class="paragraph text-center">
<p>((A &gt;&gt; 12) &amp; ~address mask) = (address pattern &amp; ~address mask)</p>
</div>
<div class="paragraph">
<p>where &gt;&gt; 12 represents shifting right by 12 bits, an ampersand (&amp;)
represents bitwise logical AND, and "~address mask"
is the bitwise logical complement of the address mask.</p>
</div>
<div class="paragraph">
<p>When a memory access is found to be to a virtual interrupt file, an
<em>interrupt file number</em> is extracted from the original guest physical
address as</p>
</div>
<div class="paragraph text-center">
<p>interrupt file number = extract(A &gt;&gt; 12, address mask)</p>
</div>
<div class="paragraph">
<p>Here, extract(\(x\), \(y\)) is a "bit extract"
that discards all bits from \(x\) whose matching bits in the
same positions in the mask \(y\) are zeros, and packs the
remaining bits from \(x\) contiguously at the
least-significant end of the result, keeping the same bit order as
\(x\) and filling any other bits at the most-significant end
of the result with zeros. For example, if the bits of \(x\)
and \(y\) are</p>
</div>
<div class="paragraph text-center">
<p>\(x\) = a b c d e f g h</p>
</div>
<div class="paragraph text-center">
<p>\(y\) = 1 0 1 0 0 1 1 0</p>
</div>
<div class="paragraph">
<p>then the value of extract(\(x\), \(y\)) has bits
0 0 0 0 a c f g.</p>
</div>
</div>
<div class="sect2">
<h3 id="msi-page-tables"><a class="anchor" href="#msi-page-tables"></a>MSI page tables</h3>
<div class="paragraph">
<p>When an IOMMU determines that a memory access is to a virtual interrupt
file as specified in the previous section, the access is translated or
converted by consulting the MSI page table configured for the device,
instead of using the regular translation data structures that apply to
all other memory accesses from the same device.</p>
</div>
<div class="paragraph">
<p>An MSI page table is a flat array of MSI page table entries (MSI PTEs),
each 16 bytes. MSI page tables have no multi-level hierarchy like
regular RISC-V page tables do. Rather, every MSI PTE is a leaf entry specifying
the translation or conversion of accesses made to a particular 4-KiB
guest physical page that a virtual interrupt file occupies (or may
occupy) in the relevant virtual machine. To select an individual MSI PTE
from an MSI page table, the PTE array is indexed by the interrupt file
number extracted from the destination guest physical address of the
incoming memory access by the formula of the previous section. Each MSI
PTE may specify either the address of a real guest interrupt file that
substitutes for the targeted virtual interrupt file (as in
<a href="#IOMMU-guestIntrFiles">Translation of a device-sourced MSI that a guest OS intended to go to a (virtual) IMSIC interrupt file in the OS&#8217;s virtual machine. Referencing an MSI page table supplied by the controlling hypervisor, the IOMMU redirects the MSI to a guest interrupt file of the real machine.</a>), or a memory-resident interrupt
file in which to store incoming MSIs for the virtual interrupt file (as
in <a href="#IOMMU-MRIF">Recording an incoming MSI into a memory-resident interrupt file (MRIF) instead of sending it to a guest interrupt file as in Translation of a device-sourced MSI that a guest OS intended to go to a (virtual) IMSIC interrupt file in the OS&#8217;s virtual machine. Referencing an MSI page table supplied by the controlling hypervisor, the IOMMU redirects the MSI to a guest interrupt file of the real machine..</a>).</p>
</div>
<div class="paragraph">
<p>The number of entries in an MSI page table is \({2}^{k}\)
where \(k\) is the number of bits that are ones in the MSI
address mask used to extract the interrupt file number from the
destination guest physical address. If an MSI page table has 256 or
fewer entries, the start of the table is aligned to a 4-KiB page address
in real physical memory. If an MSI page table has
\({{2}^{k} &gt; {256}}\) entries, the table must be
naturally aligned to a \({2}^{k}\times {16-byte}\)
address boundary. If an MSI page table is not aligned as required, all
entries in the table appear to an IOMMU as UNSPECIFED, and any address an IOMMU
may compute and use for reading an individual MSI PTE from the table is
also UNSPECIFIED.</p>
</div>
<div class="paragraph">
<p>Every 16-byte MSI PTE is interpreted as two 64-bit doublewords. If an
IOMMU also references standard RISC-V page tables, defined by the RISC-V Privileged
Architecture, for regular address translation, then the byte order for
each of the two doublewords in memory, little-endian or big-endian,
should be the same as the endianness of the regular RISC-V page tables
configured for the same device context. Otherwise, the endianness of the
doublewords of an MSI PTE is implementation-defined.</p>
</div>
<div class="paragraph">
<p>Bit 0 of the first doubleword of an MSI PTE is field V (Valid). When
V = 0, the PTE is invalid, and all other bits of both doublewords are
ignored by an IOMMU, making them free for software to use.</p>
</div>
<div class="paragraph">
<p>If V = 1, bit 63 of the first doubleword is field C (Custom), designated
for custom use. If an MSI PTE has V = 1 and C = 1, interpretation of the
rest of the PTE is implementation-defined.</p>
</div>
<div class="paragraph">
<p>If V = 1 and the custom-use bit C = 0, then bits 2:1 of the first
doubleword contain field M (Mode). If M = 3, the MSI PTE specifies
<em>basic translate mode</em> for accesses to the page, and if M = 1, it
specifies <em>MRIF mode</em>. Values of 0 and 2 for M are reserved. The
interpretation of an MSI PTE for each of the two defined modes is
detailed further in the next two subsections.</p>
</div>
<div class="sect3">
<h4 id="msi-pte-basic-translate-mode"><a class="anchor" href="#msi-pte-basic-translate-mode"></a>MSI PTE, basic translate mode</h4>
<div class="paragraph">
<p>When an MSI PTE has fields V = 1, C = 0, and M = 3 (basic translate
mode), the PTE&#8217;s complete format is:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top" rowspan="4"><p class="tableblock"><code>First doubleword:</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bit 63</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>C, = 0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bits 53:10</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PPN</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bits 2:1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>M, = 3</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bit 0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>V, = 1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Second doubleword:</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ignored</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>All other bits of the first doubleword are reserved and must be set to
zeros by software. The second doubleword is ignored by an IOMMU so is
free for software to use.</p>
</div>
<div class="paragraph">
<p>A memory access within the page covered by the MSI PTE is translated by
replacing the access&#8217;s original address bits 12 and above (the guest
physical page number) with field PPN (Physical Page Number) from the
PTE, while retaining the original address bits 11:0 (the page offset).
This translated address is either zero-extended or clipped at the upper
end as needed to make it the width of a real physical address for the
machine. The original memory access from the device is then passed
onward to the memory system with the new address.</p>
</div>
<div class="paragraph">
<p>An MSI PTE in basic translate mode allows a hypervisor to route an MSI
write intended for a virtual interrupt file to go instead to a guest
interrupt file of a real IMSIC in the machine.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>An IOMMU that also employs standard RISC-V page tables for regular address
translation can maximize the overlap between the handling of MSI PTEs
and regular RISC-V leaf PTEs as follows:</p>
</div>
<div class="paragraph">
<p>For RV64, the first doubleword of an MSI PTE in basic translate mode has
the same encoding as a regular RISC-V leaf PTE for Sv39, Sv48, Sv57, Sv39x4,
Sv48x4, or Sv57x4 page-based address translation, with PTE fields D, A,
G, U, and X all zeros and W = R = 1. Hence, the MSI PTE&#8217;s first
doubleword appears the same as a regular PTE that grants read and write
permission (R = W = 1) but not execute permissions (X = 0). This
same-encoded regular PTE would translate an MSI write the same as the
actual MSI PTE, except that what would be the PTE&#8217;s accessed (A), dirty
(D), and user (U) bits are all zeros. An IOMMU needs to treat only these
three bits differently for an MSI PTE versus a regular RV64 leaf PTE.</p>
</div>
<div class="paragraph">
<p>The address computation used to select a PTE from a regular RISC-V page table
must be modified to select an MSI PTE&#8217;s first doubleword from an MSI
page table. However, the extraction of an interrupt file number from a
guest physical address to obtain the index for accessing the MSI page
table already creates an unavoidable difference in PTE addressing.</p>
</div>
<div class="paragraph">
<p>For RV32, the lower 32-bit word of an MSI PTE&#8217;s first doubleword has the
same format as a leaf PTE for Sv32 or Sv32x4 page-based address
translation, except again for what would be PTE bits A, D, and U, which
must be treated differently.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="IOMMU-MSIPTE-MRIF"><a class="anchor" href="#IOMMU-MSIPTE-MRIF"></a>MSI PTE, MRIF mode</h4>
<div class="paragraph">
<p>If memory-resident interrupt files are supported and an MSI PTE has
fields V = 1, C = 0, and M = 1 (MRIF mode), the PTE&#8217;s complete format
is:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top" rowspan="4"><p class="tableblock"><code>First doubleword:</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bit 63</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>C, = 0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bits 53:7</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MRIF Address[55:9]</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bits 2:1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>M, = 1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bit 0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>V, = 1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Second doubleword:</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bit 60</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NID[10]</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bits 53:10</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NPPN</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bits 9:0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NID[9:0]</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>All other PTE bits are reserved and must be set to zeros by software.</p>
</div>
<div class="paragraph">
<p>The PTE&#8217;s MRIF Address field provides bits 55:9 of the physical address
of a memory-resident interrupt file in which to store incoming MSIs,
referred to as the <em>destination MRIF</em>. As every memory-resident
interrupt file is naturally aligned to a 512-byte address boundary, bits
8:0 of the destination MRIF&#8217;s address must be zero and are not specified
in the PTE.</p>
</div>
<div class="paragraph">
<p>Field NPPN (Notice Physical Page Number) and the two NID (Notice
Identifier) fields together specify a destination and value for a
<em>notice MSI</em> that is sent after each time the destination MRIF is
updated as a result of consulting this PTE to store an incoming MSI.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Typically, NPPN will be the page address of an IMSIC&#8217;s interrupt file in
the real machine, and NID will be the interrupt identity to make pending
in that interrupt file to indicate that the destination MRIF may have
changed. However, NPPN is not required to be a valid interrupt file
address, and an IOMMU must not attempt to restrict it to only such
addresses. Any page address must be accepted for NPPN.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Memory accesses by I/O devices to addresses within a page covered by an
MRIF-mode PTE are handled by the IOMMU instead of being passed through
to the memory system. If a memory access, read or write, is not for
32 bits of data, or if the access address is not aligned to a 4-byte
boundary (including accesses that straddle the page boundary), the
access should be aborted as unsupported. For a naturally aligned 32-bit
read, the IOMMU should preferably return zero as the read value but may
alternatively abort the access. A naturally aligned 32-bit write is
either interpreted as an MSI, resulting in an update of the destination
MRIF, or is discarded.</p>
</div>
<div class="paragraph">
<p>When the IMSIC interrupt files in the system implement memory-mapped
register <code>seteipnum_be</code> for receiving MSIs in big-endian byte order
(<a href="#IMSIC-memRegion">[IMSIC-memRegion]</a>), then an IOMMU
must be able to store MSIs in both little-endian and big-endian byte
orders to the destination MRIF. If the IMSIC interrupt files in the
system do not implement register <code>seteipnum_be</code>, an IOMMU should ordinarily store only
little-endian MSIs to the destination MRIF. The data of an incoming MSI
is assumed to be in little-endian byte order if bit 2 of the destination
address is zero, and in big-endian byte order if bit 2 of the
destination address is one.</p>
</div>
<div class="paragraph">
<p>If a naturally aligned 32-bit write is to guest physical
address \(A\) within a page covered by an MRIF-mode PTE, and
if the write data is \(D\) when interpreted in the byte order
indicated by bit 2 of \(A\), then the write is processed as
follows: If either \(A\)[11:3] or \(D\)[31:11] is not
zero, or if bit 2 of \(A\) is one and big-endian MSIs are not
supported, then the incoming write is accepted but discarded. Else, the
original incoming write is recognized as an MSI and is replaced by one
of the following memory accesses, setting the interrupt-pending bit that
corresponds to the interrupt identity \(D\) in the destination
MRIF to one:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>an atomic AMOOR operation, if atomic updates are supported; or</p>
</li>
<li>
<p>a non-atomic read-modify-write sequence, if atomic updates are not supported.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Once the MRIF update operation is visible to all agents in the system,
the 11-bit NID value is zero-extended to 32 bits, and this value is
written to the address NPPN&lt;&lt;12 (i.e., physical page number NPPN, page
offset zero) in little-endian byte order.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>While IOMMUs are expected typically to cache MSI PTEs that are
configured in basic translate mode (M = 3), they might not cache PTEs
configured in MRIF mode (M = 1). Two reasons together justify not
caching MSI PTEs in MRIF mode: First, the information and actions
required to store an MSI to an MRIF are far different than normal
address translation; and second, by their nature, MSIs to MRIFs should
occur less frequently. Hence, an IOMMU might perform MRIF-mode
processing solely as an extension of cache-miss page table walks,
leaving its address translation cache oblivious to MRIF-mode MSI PTEs.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="IPIs.html">Interprocessor Interrupts (IPIs)</a></span>
</nav>
</article>  </div>
</main>
<div class="modal micromodal-slide" id="modal-versions" aria-hidden="true">
    <div class="modal__overlay" tabindex="-1" data-micromodal-close>
        <div class="modal__container" role="dialog" aria-modal="true">
            <main class="modal__content" id="modal-versions-content">
              <button data-micromodal-close class="modal-versions-close">
                <svg width="28px" height="28px" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><defs><style>.cls-1h{fill:none;stroke:#000;stroke-linecap:round;stroke-linejoin:round;stroke-width:2px;}</style></defs><title/><g id="cross"><line class="cls-1h" x1="7" x2="25" y1="7" y2="25"/><line class="cls-1h" x1="7" x2="25" y1="25" y2="7"/></g></svg>
              </button>
              <div class="colset">
                <div class="col-left">

                  <ul class="nav-versions">
                      <li class="component">
                        <div>
                          <a class="title" href="../../ffh/v1.0/index.html">ACPI Functional Fixed Hardware</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../ffh/v1.0/index.html">
      v1.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="index.html">Advanced Interrupt Architecture</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="index.html">
      v1.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="../../etrace/v1.0/index.html">E-Trace Encapsulation Specification</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../etrace/v1.0/index.html">
      v1.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="../../psabi/v1.0/index.html">ELF psABI Specification</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../psabi/v1.0/index.html">
      v1.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="../../iommuArch/v1.0/index.html">IOMMU Architecture</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../iommuArch/v1.0/index.html">
      v1.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="../../isa/index.html">ISA Specifications</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../isa/index.html">
      default
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="../../reri/v1.0/index.html">RERI Architecture</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../reri/v1.0/index.html">
      v1.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="../../qos/v1.0/index.html">RISC-V Capacity and Bandwidth QoS Register Interface</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../qos/v1.0/index.html">
      v1.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="../../plic/v1.0.0/index.html">RISC-V Platform-Level Interrupt Controller</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../plic/v1.0.0/index.html">
      v1.0.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="../../semihost/v1.0/index.html">semihosting</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../semihost/v1.0/index.html">
      v1.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                  </ul>
                </div>
                <div class="col-right">
                  <ul class="projects">
  <li>
    Related Spring Documentation
    <ul class="projects-list">
        <li>
<a href="https://docs.spring.io/spring-boot/">
  Spring Boot
</a>
</li>
        <li>
<a href="https://docs.spring.io/spring-framework/reference/">
  Spring Framework
</a>
</li>
        <li>
<a class="anchor"><i class="fa fa-angle-right" aria-hidden="true"></i></a>
  Spring Cloud
<ul>
    <li>
<a href="https://docs.spring.io/spring-cloud-build/reference/">
  Spring Cloud Build
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-bus/reference/">
  Spring Cloud Bus
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-circuitbreaker/reference/">
  Spring Cloud Circuit Breaker
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-commons/reference/">
  Spring Cloud Commons
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-config/reference/">
  Spring Cloud Config
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-consul/reference/">
  Spring Cloud Consul
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-contract/reference/">
  Spring Cloud Contract
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-function/reference/">
  Spring Cloud Function
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-gateway/reference/">
  Spring Cloud Gateway
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-kubernetes/reference/">
  Spring Cloud Kubernetes
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-netflix/reference/">
  Spring Cloud Netflix
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-openfeign/reference/">
  Spring Cloud OpenFeign
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-stream/reference/">
  Spring Cloud Stream
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-task/reference/">
  Spring Cloud Task
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-vault/reference/">
  Spring Cloud Vault
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-zookeeper/reference/">
  Spring Cloud Zookeeper
</a>
</li>
</ul>
</li>
        <li>
<a class="anchor"><i class="fa fa-angle-right" aria-hidden="true"></i></a>
  Spring Data
<ul>
    <li>
<a href="https://docs.spring.io/spring-data/cassandra/reference/">
  Spring Data Cassandra
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-data/commons/reference/">
  Spring Data Commons
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-data/couchbase/reference/">
  Spring Data Couchbase
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-data/elasticsearch/reference/">
  Spring Data Elasticsearch
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-data/jpa/reference/">
  Spring Data JPA
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-data/keyvalue/reference/">
  Spring Data KeyValue
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-data/ldap/reference/">
  Spring Data LDAP
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-data/mongodb/reference/">
  Spring Data MongoDB
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-data/neo4j/reference/">
  Spring Data Neo4j
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-data/redis/reference/">
  Spring Data Redis
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-data/relational/reference/">
  Spring Data JDBC &amp; R2DBC
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-data/rest/reference/">
  Spring Data REST
</a>
</li>
</ul>
</li>
        <li>
<a href="https://docs.spring.io/spring-integration/reference/">
  Spring Integration
</a>
</li>
        <li>
<a href="https://docs.spring.io/spring-batch/reference/">
  Spring Batch
</a>
</li>
        <li>
<a class="anchor"><i class="fa fa-angle-right" aria-hidden="true"></i></a>
<a href="https://docs.spring.io/spring-security/reference/">
  Spring Security
</a>
<ul>
    <li>
<a href="https://docs.spring.io/spring-authorization-server/reference/">
  Spring Authorization Server
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-ldap/reference/">
  Spring LDAP
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-security-kerberos/reference/">
  Spring Security Kerberos
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-session/reference/">
  Spring Session
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-vault/reference/">
  Spring Vault
</a>
</li>
</ul>
</li>
        <li>
<a href="https://docs.spring.io/spring-ai/reference/">
  Spring AI
</a>
</li>
        <li>
<a href="https://docs.spring.io/spring-amqp/reference/">
  Spring AMQP
</a>
</li>
        <li>
<a href="https://docs.spring.io/spring-cli/reference/">
  Spring CLI
</a>
</li>
        <li>
<a href="https://docs.spring.io/spring-graphql/reference/">
  Spring GraphQL
</a>
</li>
        <li>
<a href="https://docs.spring.io/spring-kafka/reference/">
  Spring for Apache Kafka
</a>
</li>
        <li>
<a href="https://docs.spring.io/spring-modulith/reference/">
  Spring Modulith
</a>
</li>
        <li>
<a href="https://docs.spring.io/spring-pulsar/reference/">
  Spring for Apache Pulsar
</a>
</li>
        <li>
<a href="https://docs.spring.io/spring-shell/reference/">
  Spring Shell
</a>
</li>
    </ul>
  </li
  <li><a href="../../spring-projects.html">All Docs...</a></li>
</ul>
                </div>
              </div>
            </main>
        </div>
    </div>
</div>

</div>
<footer class="hidden">
</footer><script src="../../_/js/vendor/import.js"></script>
<script src="../../_/js/site.js"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
<script async src="../../_/js/vendor/spring-tabs.js" data-sync-storage-key="docs:preferred-tab"></script>
  </body>
</html>
