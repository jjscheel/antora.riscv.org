<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>RISC-V IOMMU Architecture Specification :: RISC-V Ratified Specifications Library</title>
    <meta name="description" content="RISC-V IOMMU Architecture Specification">
    <meta name="generator" content="Antora 3.1.12">
    <script>
!function (theme, navWidth) {
  if (theme === 'dark') document.documentElement.classList.add('dark-theme')
  if (navWidth) document.documentElement.style.setProperty('--nav-width', `${navWidth}px`)
}(localStorage && localStorage.getItem('theme') || (matchMedia('(prefers-color-scheme: dark)')?.matches && 'dark'),
  localStorage && localStorage.getItem('nav-width'))
    </script>
    <link rel="stylesheet" href="../../_/css/site.css">
    <link rel="stylesheet" href="../../_/css/vendor/search.css">
    <link rel="stylesheet" href="../../_/css/vendor/page-search.css">
    <link rel="stylesheet" href="../../_/css/vendor/spring-tabs.css">

    <meta name="antora-ui-version" content="24b0ea9bb868390e1ef3290e476fd66788c083d5"> 
    <meta name="version" content="v1.0">
    <meta name="component" content="iommuArch">
    <meta name="latest-version" content="false">
    <link rel="icon" href="../../_/img/favicon.ico" type="image/vnd.microsoft.icon">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../..">RISC-V Ratified Specifications Library</a>
      <button class="navbar-burger" aria-controls="topbar-nav" aria-expanded="false" aria-label="Toggle main menu">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="iommuArch" data-version="v1.0">
  <aside class="nav">
    <div class="panels">
      <div class="nav-panel-menu is-active" data-panel="menu">
        <nav class="nav-menu">
<div class="context">
  <span class="title">IOMMU Architecture</span>
  <span class="version">v1.0</span>
  <button class="browse-version" id="browse-version">
    <svg
      height="24px"
      id="Layer_1"
      style="enable-background:new 0 0 512 512;"
      version="1.1"
      viewBox="0 0 512 512"
      width="24px"
      xml:space="preserve"
    ><g><path
          d="M256,224c-17.7,0-32,14.3-32,32s14.3,32,32,32c17.7,0,32-14.3,32-32S273.7,224,256,224L256,224z"
        ></path><path
          d="M128.4,224c-17.7,0-32,14.3-32,32s14.3,32,32,32c17.7,0,32-14.3,32-32S146,224,128.4,224L128.4,224z"
        ></path><path
          d="M384,224c-17.7,0-32,14.3-32,32s14.3,32,32,32s32-14.3,32-32S401.7,224,384,224L384,224z"
        ></path></g></svg>
  </button>
  </div><ul class="nav-list">
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">IOMMU Architecture</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="contributors.html">Contributors</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="iommu_preface.html">Preface</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="iommu_intro.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="iommu_data_structures.html">Data Structures</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="iommu_in_memory_queues.html">In-memory queue interface</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="iommu_debug.html">Debug support</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="iommu_registers.html">Memory-mapped register interface</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="iommu_sw_guidelines.html">Software guidelines</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="iommu_hw_guidelines.html">Hardware guidelines</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="iommu_extensions.html">IOMMU Extensions</a>
  </li>
</ul>
  </li>
</ul>
          <div class="toggle-sm">
            <button id="nav-toggle-2" class="nav-toggle"></button>
          </div>
        </nav>
      </div>
      <div class="nav-collapse">
        <button id="nav-collapse-toggle"><span></span></button>        
      </div>
    </div>
    <div class="nav-resize"></div>
  </aside>
</div>
<script>
!function (sidebar) {
  if (sidebar) {
    document.body.classList.add('nav-sm')
  }
}(localStorage && localStorage.getItem('sidebar') === 'close')
</script><main class="article">
<div class="toolbar" role="navigation">
  <button id="nav-toggle-1" class="nav-toggle"></button>
</div>
  <div class="content">
<aside class="sidebar">
  <div class="content">
    <div
      class="toc"
      data-title="RISC-V IOMMU Architecture Specification"
      data-levels="2"
    >
      <div class="toc-menu"></div>
    </div>
    <div class="sidebar-links">
        <a href="https://github.com/riscv-non-isa/riscv-iommu/edit/antora-refactor/modules/ROOT/pages/riscv-iommu.adoc">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            height="24"
            viewBox="0 0 24 24"
            width="24"
          ><path
              d="m16 2.012 3 3L16.713 7.3l-3-3zM4 14v3h3l8.299-8.287-3-3zm0 6h16v2H4z"
            ></path></svg>
          Edit this Page
        </a>
              <a href="https://github.com/riscv-non-isa/riscv-iommu" title="GitHub">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            height="512px"
            id="Layer_1"
            version="1.1"
            viewBox="0 0 512 512"
            width="512px"
          ><style type="text/css"><![CDATA[
              .st0{fill-rule:evenodd;clip-rule:evenodd;} ]]></style><g><path
                class="st0"
                d="M256,32C132.3,32,32,134.8,32,261.7c0,101.5,64.2,187.5,153.2,217.9c11.2,2.1,15.3-5,15.3-11.1   c0-5.5-0.2-19.9-0.3-39.1c-62.3,13.9-75.5-30.8-75.5-30.8c-10.2-26.5-24.9-33.6-24.9-33.6c-20.3-14.3,1.5-14,1.5-14   c22.5,1.6,34.3,23.7,34.3,23.7c20,35.1,52.4,25,65.2,19.1c2-14.8,7.8-25,14.2-30.7c-49.7-5.8-102-25.5-102-113.5   c0-25.1,8.7-45.6,23-61.6c-2.3-5.8-10-29.2,2.2-60.8c0,0,18.8-6.2,61.6,23.5c17.9-5.1,37-7.6,56.1-7.7c19,0.1,38.2,2.6,56.1,7.7   c42.8-29.7,61.5-23.5,61.5-23.5c12.2,31.6,4.5,55,2.2,60.8c14.3,16.1,23,36.6,23,61.6c0,88.2-52.4,107.6-102.3,113.3   c8,7.1,15.2,21.1,15.2,42.5c0,30.7-0.3,55.5-0.3,63c0,6.1,4,13.3,15.4,11C415.9,449.1,480,363.1,480,261.7   C480,134.8,379.7,32,256,32z"
              ></path></g></svg>
          GitHub Project
        </a>
    </div>
  </div>
</aside>
<article class="doc">
<div class="breadcrumbs-container">
  <nav class="breadcrumbs" aria-label="breadcrumbs">
    <ul>
      <li><a href="index.html">IOMMU Architecture</a></li>
      <li><a href="riscv-iommu.html">RISC-V IOMMU Architecture Specification</a></li>
    </ul>
  </nav>
</div><h1 id="page-title" class="page">RISC-V IOMMU Architecture Specification</h1>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#copyright-and-license-information">Copyright and license information</a></li>
<li><a href="#contributors">Contributors</a></li>
<li><a href="#preface">1. Preface</a></li>
<li><a href="#introduction">2. Introduction</a>
<ul class="sectlevel2">
<li><a href="#glossary">2.1. Glossary</a></li>
<li><a href="#usage-models">2.2. Usage models</a>
<ul class="sectlevel3">
<li><a href="#non-virtualized-os">2.2.1. Non-virtualized OS</a></li>
<li><a href="#hypervisor">2.2.2. Hypervisor</a></li>
<li><a href="#guest-os">2.2.3. Guest OS</a></li>
</ul>
</li>
<li><a href="#placement-and-data-flow">2.3. Placement and data flow</a></li>
<li><a href="#iommu-features">2.4. IOMMU features</a></li>
</ul>
</li>
<li><a href="#DATA_STRUCTURES">3. Data Structures</a>
<ul class="sectlevel2">
<li><a href="#device-directory-table-ddt">3.1. Device-Directory-Table (DDT)</a>
<ul class="sectlevel3">
<li><a href="#non-leaf-ddt-entry">3.1.1. Non-leaf DDT entry</a></li>
<li><a href="#leaf-ddt-entry">3.1.2. Leaf DDT entry</a></li>
<li><a href="#device-context-fields">3.1.3. Device-context fields</a>
<ul class="sectlevel4">
<li><a href="#translation-control-tc">3.1.3.1. Translation control (<code>tc</code>)</a></li>
<li><a href="#io-hypervisor-guest-address-translation-and-protection-iohgatp">3.1.3.2. IO hypervisor guest address translation and protection (<code>iohgatp</code>)</a></li>
<li><a href="#DC_TA">3.1.3.3. Translation attributes (<code>ta</code>)</a></li>
<li><a href="#first-stage-context-fsc">3.1.3.4. First-Stage context (<code>fsc</code>)</a></li>
<li><a href="#msi-page-table-pointer-msiptp">3.1.3.5. MSI page table pointer (<code>msiptp</code>)</a></li>
<li><a href="#MSI_ID">3.1.3.6. MSI address mask (<code>msi_addr_mask</code>) and pattern (<code>msi_addr_pattern</code>)</a></li>
</ul>
</li>
<li><a href="#DC_MISCONFIG">3.1.4. Device-context configuration checks</a></li>
</ul>
</li>
<li><a href="#process-directory-table-pdt">3.2. Process-Directory-Table (PDT)</a>
<ul class="sectlevel3">
<li><a href="#non-leaf-pdt-entry">3.2.1. Non-leaf PDT entry</a></li>
<li><a href="#leaf-pdt-entry">3.2.2. Leaf PDT entry</a></li>
<li><a href="#process-context-fields">3.2.3. Process-context fields</a>
<ul class="sectlevel4">
<li><a href="#translation-attributes-ta">3.2.3.1. Translation attributes (<code>ta</code>)</a></li>
<li><a href="#first-stage-context-fsc-2">3.2.3.2. First-Stage context (<code>fsc</code>)</a></li>
</ul>
</li>
<li><a href="#PC_MISCONFIG">3.2.4. Process-context configuration checks</a></li>
</ul>
</li>
<li><a href="#P2IOVA">3.3. Process to translate an IOVA</a>
<ul class="sectlevel3">
<li><a href="#GET_DC">3.3.1. Process to locate the Device-context</a></li>
<li><a href="#GET_PC">3.3.2. Process to locate the Process-context</a></li>
<li><a href="#MSI_TRANS">3.3.3. Process to translate addresses of MSIs</a></li>
</ul>
</li>
<li><a href="#iommu-updating-of-pte-accessed-a-and-dirty-d-updates">3.4. IOMMU updating of PTE accessed (A) and dirty (D) updates</a></li>
<li><a href="#faults-from-virtual-address-translation-process">3.5. Faults from virtual address translation process</a></li>
<li><a href="#ATS_FAULTS">3.6. PCIe ATS translation request handling</a></li>
<li><a href="#ATS_PRI">3.7. PCIe ATS Page Request handling</a></li>
<li><a href="#CACHING">3.8. Caching in-memory data structures</a></li>
<li><a href="#updating-in-memory-data-structure-entries">3.9. Updating in-memory data structure entries</a></li>
<li><a href="#endianness-of-in-memory-data-structures">3.10. Endianness of in-memory data structures</a></li>
</ul>
</li>
<li><a href="#in-memory-queue-interface">4. In-memory queue interface</a>
<ul class="sectlevel2">
<li><a href="#command-queue-cq">4.1. Command-Queue (CQ)</a>
<ul class="sectlevel3">
<li><a href="#iommu-page-table-cache-invalidation-commands">4.1.1. IOMMU Page-Table cache invalidation commands</a></li>
<li><a href="#iommu-command-queue-fence-commands">4.1.2. IOMMU Command-queue Fence commands</a></li>
<li><a href="#iommu-directory-cache-invalidation-commands">4.1.3. IOMMU directory cache invalidation commands</a></li>
<li><a href="#iommu-pcie-ats-commands">4.1.4. IOMMU PCIe ATS commands</a></li>
</ul>
</li>
<li><a href="#FAULT_QUEUE">4.2. Fault/Event-Queue (<code>FQ</code>)</a></li>
<li><a href="#PRQ">4.3. Page-Request-Queue (<code>PQ</code>)</a></li>
</ul>
</li>
<li><a href="#debug">5. Debug support</a></li>
<li><a href="#memory-mapped-register-interface">6. Memory-mapped register interface</a>
<ul class="sectlevel2">
<li><a href="#register-layout">6.1. Register layout</a></li>
<li><a href="#reset-behavior">6.2. Reset behavior</a></li>
<li><a href="#CAP">6.3. IOMMU capabilities (<code>capabilities</code>)</a></li>
<li><a href="#FCTRL">6.4. Features-control register (<code>fctl</code>)</a></li>
<li><a href="#DDTP">6.5. Device-directory-table pointer (<code>ddtp</code>)</a></li>
<li><a href="#CQB">6.6. Command-queue base (<code>cqb</code>)</a></li>
<li><a href="#CQH">6.7. Command-queue head (<code>cqh</code>)</a></li>
<li><a href="#CQT">6.8. Command-queue tail (<code>cqt</code>)</a></li>
<li><a href="#FQB">6.9. Fault queue base (<code>fqb</code>)</a></li>
<li><a href="#FQH">6.10. Fault queue head (<code>fqh</code>)</a></li>
<li><a href="#FQT">6.11. Fault queue tail (<code>fqt</code>)</a></li>
<li><a href="#PQB">6.12. Page-request-queue base (<code>pqb</code>)</a></li>
<li><a href="#PQH">6.13. Page-request-queue head (<code>pqh</code>)</a></li>
<li><a href="#PQT">6.14. Page-request-queue tail (<code>pqt</code>)</a></li>
<li><a href="#CSR">6.15. Command-queue CSR (<code>cqcsr</code>)</a></li>
<li><a href="#FQCSR">6.16. Fault queue CSR (<code>fqcsr</code>)</a></li>
<li><a href="#PQCSR">6.17. Page-request-queue CSR (<code>pqcsr</code>)</a></li>
<li><a href="#IPSR">6.18. Interrupt pending status register (<code>ipsr</code>)</a></li>
<li><a href="#OVF">6.19. Performance-monitoring counter overflow status (<code>iocountovf</code>)</a></li>
<li><a href="#INH">6.20. Performance-monitoring counter inhibits (<code>iocountinh</code>)</a></li>
<li><a href="#CYC">6.21. Performance-monitoring cycles counter (<code>iohpmcycles</code>)</a></li>
<li><a href="#CTR">6.22. Performance-monitoring event counters (<code>iohpmctr1-31</code>)</a></li>
<li><a href="#EVT">6.23. Performance-monitoring event selectors (<code>iohpmevt1-31</code>)</a></li>
<li><a href="#TRR_IOVA">6.24. Translation-request IOVA (<code>tr_req_iova</code>)</a></li>
<li><a href="#TRR_CTRL">6.25. Translation-request control (<code>tr_req_ctl</code>)</a></li>
<li><a href="#TRR_RSP">6.26. Translation-response (<code>tr_response</code>)</a></li>
<li><a href="#IOQOSID">6.27. IOMMU QoS ID (<code>iommu_qosid</code>)</a></li>
<li><a href="#ICVEC">6.28. Interrupt-cause-to-vector register (<code>icvec</code>)</a></li>
<li><a href="#MSI">6.29. MSI configuration table (<code>msi_cfg_tbl</code>)</a></li>
</ul>
</li>
<li><a href="#sw_guidelines">7. Software guidelines</a>
<ul class="sectlevel2">
<li><a href="#reading-and-writing-iommu-registers">7.1. Reading and writing IOMMU registers</a></li>
<li><a href="#guidelines-for-initialization">7.2. Guidelines for initialization</a></li>
<li><a href="#guidelines-for-invalidations">7.3. Guidelines for invalidations</a>
<ul class="sectlevel3">
<li><a href="#DC_CHANGE">7.3.1. Changing device directory table entry</a></li>
<li><a href="#PC_CHANGE">7.3.2. Changing process directory table entry</a></li>
<li><a href="#MSI_PT_CHANGE">7.3.3. Changing MSI page table entry</a></li>
<li><a href="#changing-second-stage-page-table-entry">7.3.4. Changing second-stage page table entry</a></li>
<li><a href="#changing-first-stage-page-table-entry">7.3.5. Changing first-stage page table entry</a></li>
<li><a href="#accessed-adirty-d-bit-updates-and-page-promotions">7.3.6. Accessed (A)/Dirty (D) bit updates and page promotions</a></li>
<li><a href="#device-address-translation-cache-invalidations">7.3.7. Device Address Translation Cache invalidations</a></li>
<li><a href="#caching-invalid-entries">7.3.8. Caching invalid entries</a></li>
<li><a href="#guidelines-for-emulating-an-iommu">7.3.9. Guidelines for emulating an IOMMU</a></li>
</ul>
</li>
<li><a href="#reconfiguring-pmas">7.4. Reconfiguring PMAs</a></li>
<li><a href="#guidelines-for-handling-interrupts-from-iommu">7.5. Guidelines for handling interrupts from IOMMU</a></li>
<li><a href="#guidelines-for-enabling-and-disabling-ats-andor-pri">7.6. Guidelines for enabling and disabling ATS and/or PRI</a></li>
</ul>
</li>
<li><a href="#hardware-guidelines">8. Hardware guidelines</a>
<ul class="sectlevel2">
<li><a href="#integrating-an-iommu-as-a-pcie-device">8.1. Integrating an IOMMU as a PCIe device</a></li>
<li><a href="#faults-from-pma-and-pmp">8.2. Faults from PMA and PMP</a></li>
<li><a href="#IOBR_FAULT_RESP">8.3. Aborting transactions</a></li>
<li><a href="#RAS">8.4. Reliability, Availability, and Serviceability (RAS)</a></li>
</ul>
</li>
<li><a href="#extensions">9. IOMMU Extensions</a>
<ul class="sectlevel2">
<li><a href="#QOSID">9.1. Quality-of-Service (QoS) Identifiers Extension, Version 1.0</a>
<ul class="sectlevel3">
<li><a href="#reset-behavior-2">9.1.1. Reset Behavior</a></li>
<li><a href="#sizing-qos-identifiers">9.1.2. Sizing QoS Identifiers</a></li>
<li><a href="#iommu-atc-capacity-allocation-and-monitoring">9.1.3. IOMMU ATC Capacity Allocation and Monitoring</a></li>
</ul>
</li>
<li><a href="#NLINV">9.2. Non-leaf PTE Invalidation Extension, Version 1.0</a>
<ul class="sectlevel3">
<li><a href="#non-leaf-pte-invalidation-by-iotinval-vma">9.2.1. Non-leaf PTE Invalidation by <code>IOTINVAL.VMA</code></a></li>
<li><a href="#non-leaf-pte-invalidation-by-iotinval-gvma">9.2.2. Non-leaf PTE Invalidation by <code>IOTINVAL.GVMA</code></a></li>
</ul>
</li>
<li><a href="#ARINV">9.3. Address Range Invalidation Extension, Version 1.0</a></li>
</ul>
</li>
</ul>
</div>
<div id="preamble">
<div class="sectionbody">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="title">This document is <a href="http://riscv.org/spec-state">Ratified</a>.</div>
<div class="paragraph">
<p>No changes are allowed. Any desired or needed changes can be the subject of a
follow-on new extension. Ratified extensions are never revised.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="copyright-and-license-information"><a class="anchor" href="#copyright-and-license-information"></a>Copyright and license information</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This specification is licensed under the Creative Commons
Attribution 4.0 International License (CC-BY 4.0). The full
license text is available at
<a href="https://creativecommons.org/licenses/by/4.0/" class="bare">creativecommons.org/licenses/by/4.0/</a>.</p>
</div>
<div class="paragraph">
<p>Copyright 2023 by RISC-V International.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="contributors"><a class="anchor" href="#contributors"></a>Contributors</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This RISC-V specification has been contributed to directly or indirectly by (in alphabetical order):</p>
</div>
<div class="paragraph">
<p>Aaron Durbin, Allen Baum, Anup Patel, Daniel Gracia Pérez, David Kruckemyer, Greg Favor, Ahmad Fawal, Guerney D Hunt, John Hauser, Josh Scheid, Matt Evans, Manuel Rodriguez, Nick Kossifidis, Paul Donahue, Paul Walmsley, Perrine Peresse, Philipp Tomsich, Rieul Ducousso, Scott Nelson, Siqi Zhao, Sunil V.L, Tomasz Jeznach, Vassilis Papaefstathiou, Vedvyas Shanbhogue</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="preface"><a class="anchor" href="#preface"></a>1. Preface</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong class="big"><em>Preface to Version 20250620</em></strong></p>
</div>
<div class="paragraph">
<p>This document describes the RISC-V IOMMU architecture. This release, version
20250620, includes the following versions of the RISC-V IOMMU Base Architecture
specification and standard extensions:</p>
</div>
<table class="tableblock frame-all grid-all fit-content center">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Specification</th>
<th class="tableblock halign-center valign-top">Version</th>
<th class="tableblock halign-center valign-top">Status</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>RISC-V IOMMU Base Architecture Specification</strong>  <br>
 <strong>Quality-of-Service (QoS) Identifiers Extension</strong><br>
 <strong>Non-leaf PTE Invalidation Extension</strong>           <br>
 <strong>Address Range Invalidation Extension</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>1.0</strong> <br>
                                                    <strong>1.0</strong> <br>
                                                    <strong>1.0</strong> <br>
                                                    <strong>1.0</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Ratified</strong><br>
                                                             <strong>Ratified</strong><br>
                                                             <strong>Ratified</strong><br>
                                                             <strong>Ratified</strong></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The following backward-compatible changes&#8212;&#8203;comprising a set of clarifications
and corrections&#8212;&#8203;have been made since version 20240901:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Typographic errors have been corrected, and editorial updates have been made.</p>
</li>
<li>
<p>Clarified that the translation size is implementation-defined when both
stages are bare.</p>
</li>
<li>
<p>Clarified that the size of a queue is one less than the number of its entries.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These changes were made through PR#441, cite:[PR441].</p>
</div>
<div class="paragraph">
<p><strong class="big"><em>Preface to Version 20240901</em></strong></p>
</div>
<div class="paragraph">
<p>Chapters 2 through 8 of this document form the RISC-V IOMMU Base Architecture
Specification. Chapter 9 includes the standard extensions to the base
architecture. This release, version 20240901, contains the following versions
of the RISC-V IOMMU Base Architecture specification and standard extensions:</p>
</div>
<table class="tableblock frame-all grid-all fit-content center">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Specification</th>
<th class="tableblock halign-center valign-top">Version</th>
<th class="tableblock halign-center valign-top">Status</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>RISC-V IOMMU Base Architecture specification</strong>  <br>
 <strong>Quality-of-Service (QoS) Identifiers Extension</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>1.0</strong> <br>
                                                    <strong>1.0</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Ratified</strong><br>
                                                             <strong>Ratified</strong></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The following backward-compatible changes, comprising a set of clarifications
and corrections, have been made since version 1.0.0:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A set of typographic errors and editorial updates were made.</p>
</li>
<li>
<p>Translations cached, if any, in <code>Bare</code> mode do not require invalidation.</p>
</li>
<li>
<p>Clarified that memory faults encountered by commands also set the <code>cqmf</code> flag.</p>
</li>
<li>
<p>Values tested by algorithms in SW Guidelines are before modifications made by
the algorithms.</p>
</li>
<li>
<p>Included SW guidelines for modifying non-leaf PDT entries.</p>
</li>
<li>
<p>Clarified the behavior for in-flight transactions observed at the time of <code>ddtp</code>
write operations.</p>
</li>
<li>
<p>Clarified the behavior when <code>IOTINVAL</code> is invoked with an invalid address.</p>
</li>
<li>
<p>Stated that faults leading to UR/CA ATS responses are reported in the Fault Queue.</p>
</li>
<li>
<p>Added a detailed description of the <code>capabilities.PAS</code> field.</p>
</li>
<li>
<p>SW guidelines for changing IOMMU modes and programming <code>tr_req_ctl</code> and HPM
counters.</p>
</li>
<li>
<p>PCIe ATS Translation Resp. grants execute permission only if requested.</p>
</li>
<li>
<p>Clarified the handling of hardware implementations that internally split
8-byte transactions.</p>
</li>
<li>
<p>Shadow stack encodings introduced by Zicfiss are reserved for IOMMU use.</p>
</li>
<li>
<p>Listed the fault codes reported for faults detected by Page Request.</p>
</li>
<li>
<p>Updated Fig 31 to remove the unused Destination ID field for ATS.PRGR</p>
</li>
<li>
<p>Included a software guideline for IOMMU emulation.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These changes were made through PR#243 cite:[PR243].</p>
</div>
<div class="paragraph">
<p><strong class="big"><em>Preface to Version 1.0.0</em></strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Ratified version of the RISC-V IOMMU Architecture Specification.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="introduction"><a class="anchor" href="#introduction"></a>2. Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Input-Output Memory Management Unit (IOMMU), sometimes referred to as a
System MMU (SMMU), is a system-level Memory Management Unit (MMU) that connects
direct-memory-access-capable Input/Output (I/O) devices to system memory.</p>
</div>
<div class="paragraph">
<p>For each I/O device connected to the system through an IOMMU, software can
configure at the IOMMU a device context, which associates with the device a
specific virtual address space and other per-device parameters. By giving
each device its own separate device context at an IOMMU, each device can be
individually configured for a separate operating system, which may be a guest OS
or the main (host) OS. On every memory access initiated by a device, the IOMMU
identifies the originating device by some form of unique device
identifier, which the IOMMU then uses to locate the appropriate device context
within data structures supplied by software. For PCIe cite:[PCI], for example,
the originating device may be identified by the unique 16-bit triplet of PCI bus
number (8-bit), device number (5-bit), and function number (3-bit) (collectively
known as routing identifier or RID) and optionally up to 8-bit segment number
when the IOMMU supports multiple Hierarchies. This specification refers to such
unique device identifier as <code>device_id</code> and supports up to 24-bit wide
identifiers.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A Hierarchy is a PCI Express I/O interconnect topology, wherein the
Configuration Space addresses, referred to as the tuple of Bus/Device/Function
Numbers, are unique. In some contexts, a Hierarchy is also called a Segment, and
in Flit Mode, the Segment number is sometimes included in the ID of a Function.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Some devices may support shared virtual addressing which is the ability to
share process address spaces with devices. Sharing process address spaces with
devices allows to rely on core kernel memory management for DMA, removing some
complexity from application and device drivers. After binding to a device,
applications can instruct it to perform DMA on statically or dynamically
allocated buffers. To support such addressing, software can configure one or
more process contexts into the device context. Every memory access initiated
by such a device is accompanied by a unique process identifier, which the IOMMU
uses in conjunction with the unique device identifier to locate the appropriate
process context configured by software in the device context. For PCIe, for
example, the process context may be identified by the unique 20-bit process
address space identifier (PASID). This specification refers to such unique
process identifiers as <code>process_id</code> and supports up to 20-bit wide identifiers.</p>
</div>
<div class="paragraph">
<p>The IOMMU employs a two-stage address translation process to translate the IOVA
to an SPA and to enforce memory protections for the DMA. To perform address
translation and memory protection the IOMMU uses same page table formats as used
by the CPU&#8217;s MMU for the first-stage and second-stage address translation. Using
the same page table formats as the CPU’s MMU removes some of the memory
management complexity for DMA. Use of an identical format also allows the same
page tables to be used simultaneously by both the CPU MMU and the IOMMU.</p>
</div>
<div class="paragraph">
<p>Although there is no option to disable two-stage address translation, either
stage may be effectively disabled by configuring the virtual memory scheme for
that stage to be <code>Bare</code> i.e. perform no address translation or memory protection.</p>
</div>
<div class="paragraph">
<p>The virtual memory scheme employed by the IOMMU may be configured individually
per device in the IOMMU. Devices perform DMA using an I/O virtual address (IOVA).
Depending on the virtual memory scheme selected for a device, the IOVA used by
the device may be a supervisor physical address (SPA), guest physical address
(GPA), or a virtual address (VA).</p>
</div>
<div class="paragraph">
<p>If the virtual memory scheme selected for both stages is <code>Bare</code> then the IOVA is
a SPA. There is no address translation or protection performed by the IOMMU.</p>
</div>
<div class="paragraph">
<p>If the virtual memory scheme selected for first-stage is <code>Bare</code> but the scheme
for the second-stage is not <code>Bare</code> then the IOVA is a GPA. The first-stage is
effectively disabled. The second-stage translates the GPA to SPA and enforces the configured
memory protections. Such a configuration would be typically employed when the
device control is passed through to a virtual machine but the Guest OS in the VM
does not use first-stage address translation to further constrain memory accesses
from such devices. Comparing to a RISC-V hart, this configuration is analogous
to two-stage address translation being in effect on a RISC-V hart with the
G-stage active and the VS-stage set to Bare.</p>
</div>
<div class="paragraph">
<p>If the virtual memory scheme selected for first-stage is not <code>Bare</code> but the
scheme for the second-stage is <code>Bare</code> then IOVA is a VA. The second-stage is
effectively disabled. The first-stage translates the VA to a SPA and enforces the configured
memory protections. This configuration would be typically employed when the
IOMMU is used by a native OS or when the control of the device is retained by
the hypervisor itself. Comparing to a RISC-V hart, this configuration is
analogous to single-stage address translation being in effect on a RISC-V hart.</p>
</div>
<div class="paragraph">
<p>If the virtual memory scheme selected for neither stage is <code>Bare</code> then the IOVA
is a VA. Two-stage address translation is in effect. The first-stage translates
the VA to a GPA and the second-stage translates the GPA to a SPA. Each stage
enforces the configured memory protections. Such a configuration would be
typically be employed when the device control is passed-through to a virtual
machine and the Guest OS in the VM uses the first-stage address translation to
further constrain the memory accessed by such devices and associated privileges
and memory protections. Comparing to a RISC-V hart, this configuration is
analogous to two-stage address translation being in effect on a RISC-V hart with
both G-stage and VS-stage active (not Bare).</p>
</div>
<div class="paragraph">
<p>DMA address translation in the IOMMU has certain performance implications for
DMA accesses as the access time may be lengthened by the time required to
determine the SPA using the software provided data structures.
Similar overheads in the CPU MMU are mitigated typically through the use of a
translation look-aside buffer (TLB) to cache these address translations such
that they may be re-used to reduce the translation overhead on subsequent
accesses. The IOMMU may employ similar address translation caches, referred as
IOMMU Address Translation Cache (IOATC). The IOMMU provides mechanisms for
software to synchronize the IOATC with the memory resident data structures used
for address translation when they are modified. Software may configure the
device context with a software defined context identifier called guest
soft-context identifier (<code>GSCID</code>) to indicate that a collection of devices are
assigned to the same VM and thus access a common virtual address space.
Software may configure the process context with a software defined context
identifier called process soft-context identifier (<code>PSCID</code>) to identify a
collection of processes that share a common virtual address space.
The IOMMU may use the <code>GSCID</code> and <code>PSCID</code> to tag entries in the IOATC to avoid
duplication and simplify invalidation operations.</p>
</div>
<div class="paragraph">
<p>Some devices may participate in the translation process and provide a device
side ATC (DevATC) for its own memory accesses. By providing a DevATC, the
device shares the translation caching responsibility and thereby reduce
probability of "thrashing" in the IOATC. The DevATC may be sized by the device
to suit its unique performance requirements and may also be used by the device
to optimize DMA latency by prefetching translations. Such mechanisms require
close cooperation of the device and the IOMMU using a protocol. For PCIe, for
example, the Address Translation Services (ATS) protocol may be used by the
device to request translations to cache in the DevATC and to synchronize it
with updates made by software address translation data structures. The
device participating in the address translation process also enables the use
of I/O page faults to avoid the core kernel memory manager from having to make
all physical memory that may be accessed by the device resident at all times.
For PCIe, for example, the device may implement the Page Request Interface (PRI)
to dynamically request the memory manager to make a page resident if it
discovers the page for which it requested a translation was not available. An
IOMMU may support specialized software interfaces and protocols with the device
to enable services such as PCIe ATS and PCIe PRI cite:[PCI].</p>
</div>
<div class="paragraph">
<p>In systems built with an Incoming Message-Signaled Interrupt Controller (IMSIC),
the IOMMU may be programmed by the hypervisor to direct message-signaled
interrupts (MSI) from devices controlled by the guest OS to a guest interrupt
file in an IMSIC. Because MSIs from devices are simply memory writes, they
would naturally be subject to the same address translation that an IOMMU
applies to other memory writes. However, the RISC-V Advanced Interrupt
Architecture cite:[AIA] requires that IOMMUs treat MSIs directed to virtual
machines specially, in part to simplify software, and in part to allow optional
support for memory-resident interrupt files. The device context is configured by
software with parameters to identify memory accesses to a virtual interrupt file
and to be translated using a MSI address translation table configured by software
in the device context.</p>
</div>
<div class="sect2">
<h3 id="glossary"><a class="anchor" href="#glossary"></a>2.1. Glossary</h3>
<table class="tableblock frame-all grid-all" style="width: 90%;">
<caption class="title">Table 1. Terms and definitions</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 80%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Term</th>
<th class="tableblock halign-center valign-top">Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">AIA</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">RISC-V Advanced Interrupt Architecture cite:[AIA].</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ATS / PCIe ATS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Address Translation Services: A PCIe protocol to support
                    DevATC cite:[PCI].</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CXL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Compute Express Link bus standard.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DC /
  Device Context</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A hardware representation of state that identifies a
                    device and the VM to which the device is assigned.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DDT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Device-directory-table: A radix-tree structure traversed
                    using the unique device identifier to locate the Device
                    Context structure.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DDI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Device-directory-index: A sub-field of the unique device
                    identifier used as a index into a leaf or non-leaf DDT
                    structure.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Device ID</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An identification number that is up to 24-bits to identify
                    the source of a DMA or interrupt request. For PCIe devices
                    this is the routing identifier (RID) cite:[PCI].</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DevATC</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An address translation cache at the device.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DMA</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Direct Memory Access.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GPA</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Guest Physical Address: An address in the virtualized
                    physical memory space of a virtual machine.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GSCID</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Guest soft-context identifier: An identification number used
                    by software to uniquely identify a collection of devices
                    assigned to a virtual machine. An IOMMU may tag IOATC
                    entries with the GSCID. Device contexts programmed with the
                    same GSCID must also be programmed with identical
                    second-stage page tables.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Guest</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Software in a virtual machine.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HPM</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hardware Performance Monitor.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hypervisor</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Software entity that controls virtualization.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ID</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Identifier.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">IMSIC</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Incoming Message-signaled Interrupt Controller.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">IOATC</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IOMMU Address Translation Cache: cache in IOMMU that caches
                    data structures used for address translations.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">IOVA</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">I/O Virtual Address: Virtual address for DMA by devices.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MSI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Message Signaled Interrupts.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">OS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Operating System.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PASID</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Process Address Space Identifier: It identifies the
                    address space of a process. The PASID value is provided in
                    the PASID TLP prefix of the request.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PBMT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Page-Based Memory Types.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PC</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Process Context.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PCIe</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Peripheral Component Interconnect Express bus standard
                    cite:[PCI].</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PDI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Process-directory-index: a sub field of the unique process
                    identifier used to index into a leaf or non-leaf PDT
                    structure.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PDT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Process-directory-table: A radix tree data structure
                    traversed using the unique Process identifier to locate the
                    process context structure.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PMA</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Physical Memory Attributes.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PMP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Physical Memory Protection.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PPN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Physical Page Number.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Page Request Interface - a PCIe protocol cite:[PCI] that enables
                    devices to request OS memory manager services to make pages
                    resident.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Process ID</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An identification number that is up to 20-bits to identify
                    a process context. For PCIe devices this is the PASID
                    cite:[PCI].</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PSCID</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Process soft-context identifier: An identification number
                    used by software to identify a unique address space. The
                    IOMMU may tag IOATC entries with PSCID.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Page Table.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PTE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Page Table Entry. A leaf or non-leaf entry in a page table.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A register or data structure field reserved for future use.
                    Reserved fields in data structures must be set to 0 by
                    software. Software must ignore reserved fields in registers
                    and preserve the value held in these fields when writing
                    values to other fields in the same register.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">RID / PCIe RID</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PCIe routing identifier cite:[PCI].</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Read-only - Register bits are read-only and cannot be altered
                    by software. Where explicitly defined, these bits are used
                    to reflect changing hardware state, and as a result bit
                    values can be observed to change at run time.<br>
                    If the optional feature that would Set the bits is not
                    implemented, the bits must be hardwired to Zero</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">RW</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Read-Write - Register bits are read-write and are permitted
                    to be either Set or Cleared by software to the desired
                    state.<br>
                    If the optional feature that is associated with the bits is
                    not implemented, the bits are permitted to be hardwired to
                    Zero.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">RW1C</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Write-1-to-clear status - Register bits indicate status when
                    read. A Set bit indicates a status event which is Cleared by
                    writing a 1b. Writing a 0b to RW1C bits has no effect.<br>
                    If the optional feature that would Set the bit is not
                    implemented, the bit must be read-only and hardwired to Zero</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">RW1S</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Read-Write-1-to-set - register bits indicate status when
                    read. The bit may be Set by writing 1b. Writing a 0b to RW1S
                    bits has no effect.<br>
                    If the optional feature that introduces the bit is not
                    implemented, the bit must be read-only and hardwired to Zero</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SOC</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">System on a chip, also referred as system-on-a-chip and
                    system-on-chip.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SPA</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Supervisor Physical Address: Physical address used to
                    to access memory and memory-mapped resources.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">TLP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Transaction Layer Packet.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">VA</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Virtual Address.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">VM</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Virtual Machine: An efficient, isolated duplicate of a real
                    computer system. In this specification it refers to the
                    collection of resources and state that is accessible when
                    a RISC-V hart supporting the hypervisor extension executes
                    with the virtualization mode set to 1.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">VMM</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Virtual Machine Monitor. Also referred to as hypervisor.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">VS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Virtual Supervisor: Supervisor privilege in virtualization
                    mode.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">WARL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Write Any values, Reads Legal values: Attribute of a
                    register field that is only defined for a subset of bit
                    encodings, but allow any value to be written while
                    guaranteeing to return a legal value whenever read.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Writes Preserve values, Reads Ignore values:
                    Attribute of a register field that is reserved for future
                    use.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="usage-models"><a class="anchor" href="#usage-models"></a>2.2. Usage models</h3>
<div class="sect3">
<h4 id="non-virtualized-os"><a class="anchor" href="#non-virtualized-os"></a>2.2.1. Non-virtualized OS</h4>
<div class="paragraph">
<p>A non-virtualized OS may use the IOMMU for the following significant system-level
functionalities:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Protect the operating system from bad memory accesses from errant devices</p>
</li>
<li>
<p>Support 32-bit devices in 64-bit environment (avoidance of bounce buffers)</p>
</li>
<li>
<p>Support mapping of contiguous virtual addresses to an underlying fragmented
physical addresses (avoidance of scatter/gather lists)</p>
</li>
<li>
<p>Support shared virtual addressing</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In the absence of an IOMMU a device could access any memory, such as privileged
memory, and cause malicious or unintended corruptions. This may be due to
hardware bugs, device driver bugs, or due to malicious software/hardware.</p>
</div>
<div class="paragraph">
<p>The IOMMU offers a mechanism for the OS to defend against such unintended
corruptions by limiting the memory that can be accessed by devices.  As depicted
in <a href="#fig:device-isolation">Figure 1</a> the OS may configure the IOMMU with a page table to
translate the IOVA and thereby limit the addresses that may be accessed to those
allowed by the page table.</p>
</div>
<div id="fig:device-isolation" class="imageblock text-center unresolved">
<div class="content">
<img src="images/non-virt-OS.svg" alt="non virt OS" width="300" height="300">
</div>
<div class="title">Figure 1. Device isolation in non-virtualized OS</div>
</div>
<div class="paragraph">
<p>Legacy 32-bit devices cannot access the memory above 4 GiB. The IOMMU, through
its address remapping capability, offers a simple mechanism for the device to
directly access any address in the system (with appropriate access permission).
Without an IOMMU, the OS must resort to copying data through buffers (also
known as bounce buffers) allocated in memory below 4 GiB. In this scenario the
IOMMU improves the system performance.</p>
</div>
<div class="paragraph">
<p>The IOMMU can be useful to perform scatter/gather DMA as it permits to allocate
large regions of memory for I/O without the need for all of the memory to be
contiguous. A contiguous virtual address range can map to such fragmented
physical addresses and the device programmed with the virtual address range.</p>
</div>
<div class="paragraph">
<p>The IOMMU can be used to support shared virtual addressing which is the ability
to share a process address space with devices. The virtual addresses used for
DMA are then translated by the IOMMU to an SPA.</p>
</div>
<div class="paragraph">
<p>When the IOMMU is used by a non-virtualized OS, the first-stage suffices to
provide the required address translation and protection function and the
second-stage may be set to Bare.</p>
</div>
</div>
<div class="sect3">
<h4 id="hypervisor"><a class="anchor" href="#hypervisor"></a>2.2.2. Hypervisor</h4>
<div class="paragraph">
<p>IOMMU makes it possible for a guest operating system, running in a virtual
machine, to be given direct control of an I/O device with only minimal
hypervisor intervention.</p>
</div>
<div class="paragraph">
<p>A guest OS with direct control of a device will program the device with guest
physical addresses, because that is all the OS knows. When the device then
performs memory accesses using those addresses, an IOMMU is responsible for
translating those guest physical addresses into supervisor physical addresses,
referencing address-translation data structures supplied by the hypervisor.</p>
</div>
<div class="paragraph">
<p><a href="#fig:dma-translation-direct-device-assignment">Figure 2</a> illustrates the concept.
The device D1 is directly assigned to VM-1 and device D2 is directly assigned
to VM-2. The VMM configures a second-stage page table to be used for each device
and restricts the memory that can be accessed by D1 to VM-1 associated memory
and from D2 to VM-2 associated memory.</p>
</div>
<div id="fig:dma-translation-direct-device-assignment" class="imageblock text-center unresolved">
<div class="content">
<img src="images/hypervisor.svg" alt="hypervisor" width="300" height="300">
</div>
<div class="title">Figure 2. DMA translation to enable direct device assignment</div>
</div>
<div class="paragraph">
<p>To handle MSIs from a device controlled by a guest OS, the hypervisor configures
an IOMMU to redirect those MSIs to a guest interrupt file in an IMSIC
(see <a href="#MSI_REDIR">Figure 3</a>) or to a memory-resident interrupt file. The IOMMU is
responsible to use the MSI address-translation data structures supplied by the
hypervisor to perform the MSI redirection. Because every interrupt file, real or
virtual, occupies a naturally aligned 4-KiB page of address space, the required
address translation is from a virtual (guest) page address to a physical page
address, the same as supported by regular RISC-V page-based address translation.</p>
</div>
<div id="MSI_REDIR" class="imageblock text-center unresolved">
<div class="content">
<img src="images/msi-imsic.svg" alt="msi imsic" width="500" height="400">
</div>
<div class="title">Figure 3. MSI address translation to direct guest programmed MSI to IMSIC guest interrupt files</div>
</div>
</div>
<div class="sect3">
<h4 id="guest-os"><a class="anchor" href="#guest-os"></a>2.2.3. Guest OS</h4>
<div class="paragraph">
<p>The hypervisor may provide a virtual IOMMU facility, through hardware
emulation or by enlightening the guest OS to use a software interface with
the Hypervisor (also known as para-virtualization). The guest OS may then use
the facilities provided by the virtual IOMMU to avail the same benefits as
those discussed for a non-virtualized OS through the use of a first-stage page
table that it controls. The hypervisor establishes a second-stage page table
that it controls to virtualize the address space for the virtual machine and to
contain memory accesses from the devices passed through to the VM to the memory
associated with the VM.</p>
</div>
<div class="paragraph">
<p>With two-stage address translations active, the IOVA is first translated to
a GPA using the first-stage page tables managed by the guest OS and the GPA
translated to a SPA using the second-stage page tables managed by the
hypervisor.</p>
</div>
<div class="paragraph">
<p><a href="#fig:iommu-for-guest-os">Figure 4</a> illustrates the concept.</p>
</div>
<div id="fig:iommu-for-guest-os" class="imageblock text-center unresolved">
<div class="content">
<img src="images/guest-OS.svg" alt="guest OS" width="500" height="400">
</div>
<div class="title">Figure 4. Address translation in IOMMU for Guest OS</div>
</div>
<div class="paragraph">
<p>The IOMMU is configured to perform address translation using a first-stage
and second-stage page table for device D1. The second-stage is typically used by
the hypervisor to translate GPA to SPA and limit the device D1 to memory
associated with VM-1. The first-stage is typically configured by the Guest OS to
translate a VA to a GPA and contain device D1 access to a subset of VM-1 memory.</p>
</div>
<div class="paragraph">
<p>For device D2 only the second-stage is active and the first-stage is set to Bare.</p>
</div>
<div class="paragraph">
<p>The host OS or hypervisor may also retain a device, such as D3, for its own use.
The first-stage suffices to provide the required address translation and
protection function for device D3 and the second-stage is set to Bare.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="placement-and-data-flow"><a class="anchor" href="#placement-and-data-flow"></a>2.3. Placement and data flow</h3>
<div class="paragraph">
<p><a href="#fig:example-soc-with-iommu">Figure 5</a> shows an example of a typical system on a chip
(SOC) with RISC-V hart(s). The SOC incorporates memory controllers and several
IO devices. This SOC also incorporates two instances of the IOMMU. A device
may be directly connected to the IO Bridge and the system interconnect or may
be connected through a Root Port when a IO protocol transaction to system
interconnect transaction translation is required. In case of PCIe cite:[PCI],
for example, the Root Port is a PCIe port that maps a portion of a hierarchy
through an associated virtual PCI-PCI bridge and maps the PCIe IO protocol
transactions to the system interconnect transactions.</p>
</div>
<div class="paragraph">
<p>The first IOMMU instance, IOMMU 0 (associated with the IO Bridge 0), interfaces
a Root Port to the system fabric/interconnect. One or more endpoint devices are
interfaced to the SoC through this Root Port. In the case of PCIe, the Root Port
incorporates an ATS interface to the IOMMU that is used to support the PCIe ATS
protocol by the IOMMU.  The example shows an endpoint device with a device side
ATC (DevATC) that holds translations obtained by the device from IOMMU 0 using
the PCIe ATS protocol cite:[PCI].</p>
</div>
<div style="page-break-after: always;"></div>
<div class="paragraph">
<p>When such IO-protocol-to-system-fabric-protocol translation using a Root Port
is not required, the devices may interface directly with the system fabric.
The second IOMMU instance, IOMMU 1 (associated with the IO Bridge 1),
illustrates interfacing devices (IO Devices A and B) to the system fabric
without the use of a Root Port.</p>
</div>
<div class="paragraph">
<p>The IO Bridge is placed between the device(s) and the system interconnect to
process DMA transactions. IO Devices may perform DMA transactions using IO
Virtual Addresses (VA, GVA or GPA). The IO Bridge invokes the associated IOMMU
to translate the IOVA to a Supervisor Physical Addresses (SPA).</p>
</div>
<div class="paragraph">
<p>The IOMMU is not invoked for outbound transactions.</p>
</div>
<div id="fig:example-soc-with-iommu" class="imageblock unresolved">
<div class="content">
<img src="images/placement.svg" alt="placement" width="800">
</div>
<div class="title">Figure 5. Example of IOMMUs integration in SoC.</div>
</div>
<div class="paragraph">
<p>The IOMMU is invoked by the IO Bridge for address translation and protection for
inbound transactions. The data associated with the inbound transactions is not
processed by the IOMMU. The IOMMU behaves like a look-aside IP to the IO Bridge
and has several interfaces (see <a href="#fig:iommu-interfaces">Figure 6</a>):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Host interface: it is an interface to the IOMMU for the harts to access
its memory-mapped registers and perform global configuration and/or
maintenance operations.</p>
</li>
<li>
<p>Device Translation Request interface: it is an interface, which receives
the translation requests from the IO Bridge. On this interface the IO Bridge
provides information about the request such as:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>The hardware identities associated with transaction - the <code>device_id</code> and
if applicable the <code>process_id</code> and its validity. The IOMMU uses the hardware
identities to retrieve the context information to perform the requested
address translations.</p>
</li>
<li>
<p>The IOVA and the type of the transaction (Translated or Untranslated).</p>
</li>
<li>
<p>Whether the request is for a read, write, execute, or an atomic operation.</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>Execute requested must be explicitly associated with the request
(e.g., using a PCIe PASID). When not explicitly requested, the default must
be 0.</p>
</li>
</ol>
</div>
</li>
<li>
<p>The privilege mode associated with the request. When a privilege mode is not
explicitly associated with the request (e.g., using a PCIe PASID), the default
privilege mode must be User. For requests without a <code>process_id</code> the privilege
mode must be User.</p>
</li>
<li>
<p>The number of bytes accessed by the request.</p>
</li>
<li>
<p>The IO Bridge may also provide some additional opaque information (e.g. tags)
that are not interpreted by the IOMMU but returned along with the response
from the IOMMU to the IO Bridge. As the IOMMU is allowed to complete
translation requests out of order, such information may be used by the IO
Bridge to correlate completions to previous requests.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Data Structure interface: it is used by the IOMMU for implicit access to
memory. It is a requester interface to the IO Bridge and is used to fetch the
required data structure from main memory. This interface is used to access:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>The device and process directories to get the context information and
translation rules.</p>
</li>
<li>
<p>The first-stage and/or second-stage page table entries to translate the IOVA.</p>
</li>
<li>
<p>The in-memory queues (command-queue, fault-queue, and page-request-queue)
used to interface with software.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Device Translation Completion interface: it is an interface which
provides the completion response from the IOMMU for previously requested
address translations. The completion interface may provide information
such as:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>The status of the request, indicating if the request completed successfully
or a fault occurred.</p>
</li>
<li>
<p>If the request was completed successfully; the Supervisor Physical Address
(SPA).</p>
</li>
<li>
<p>Opaque information (e.g. tags), if applicable, associated with the request.</p>
</li>
<li>
<p>The page-based memory types (PBMT), if Svpbmt is supported, obtained from the
IOMMU address translation page tables. The IOMMU provides the page-based
memory type as resolved between the first-stage and second-stage page table
entries.</p>
</li>
</ol>
</div>
</li>
<li>
<p>ATS interface: The ATS interface, if the optional PCIe ATS capability is
supported by the IOMMU, is used to communicate with ATS capable endpoints
through the PCIe Root Port. This interface is used:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>To receive ATS translation requests from the endpoints and to return the
completions to the endpoints. The Root Port may provide an indication if the
endpoint originating the request is a CXL type 1 or type 2 device.</p>
</li>
<li>
<p>To send ATS "Invalidation Request" messages to the endpoints and to receive
the "Invalidation Completion" messages from the endpoints.</p>
</li>
<li>
<p>To receive "Page Request" and "Stop Marker" messages from the endpoints and
to send "Page Request Group Response" messages to the endpoints.</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The interfaces related to recording an incoming MSI in a memory-resident
interrupt file (MRIF) (See RISC-V Advanced Interrupt Architecture cite:[AIA])
are implementation-specific. The partitioning of responsibility between
the IOMMU and the IO bridge for recording the incoming MSI in an MRIF and
generating the associated <em>notice</em> MSI are implementation-specific.</p>
</div>
<div id="fig:iommu-interfaces" class="imageblock unresolved">
<div class="content">
<img src="images/interfaces.svg" alt="interfaces" width="800">
</div>
<div class="title">Figure 6. IOMMU interfaces.</div>
</div>
<div class="paragraph">
<p>Similar to the RISC-V harts, physical memory attributes (PMA) and physical
memory protection (PMP) checks must be completed on all inbound IO transactions
even when the IOMMU is in bypass (<code>Bare</code> mode). The placement and integration of
the PMA and PMP checkers is a platform choice. PMA and PMP checkers reside
outside the IOMMU. The example above is showing them in the IO Bridge.</p>
</div>
<div class="paragraph">
<p>Implicit accesses by the IOMMU itself through the Data Structure interface are
checked by the PMA checker. PMAs are tightly tied to a given physical platform’s
organization, and many details are inherently platform-specific.</p>
</div>
<div class="paragraph">
<p>The memory accesses performed by the IOMMU using the Data Structure interface
need not be ordered in general with the device-initiated memory accesses.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The IOMMU may generate implicit memory accesses on the Data Structure interface
to access data structures needed to perform the address translations. Such
accesses must not be blocked by the original device-initiated memory access.</p>
</div>
<div class="paragraph">
<p>The IO bridge may perform ordering of memory accesses on the Data Structure
interface to satisfy the necessary hazard checks and other rules as defined by
the IO bridge and the system interconnect.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The IOMMU provides the resolved PBMT (PMA, IO, NC) along with the translated
address on the device translation completion interface to the IO Bridge. The
PMA checker in the IO Bridge may use the provided PBMT to override the PMA(s)
for the associated memory pages.</p>
</div>
<div class="paragraph">
<p>The PMP checker may use the hardware ID of the bus access initiator to determine
physical memory access privileges. As the IOMMU itself is a bus access initiator
for its implicit accesses, the IOMMU hardware ID may be used by the PMP checker
to select the appropriate access control rules.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The IOMMU does not validate the authenticity of the hardware IDs provided by
the IO bridge.</p>
</div>
<div class="paragraph">
<p>The IO bridge and/or the root ports must include suitable mechanisms to
authenticate the hardware IDs. In some SOCs this may be trivially achieved as a
property of the devices being integrated into the SOC and their IDs being
immutable. For PCIe, for example, the PCIe defined Access Control Services (ACS)
Source Validation capabilities may be used to authenticate the hardware IDs.
Other implementation-specific methods in the IO bridge may be provided to
perform such authentication.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="iommu-features"><a class="anchor" href="#iommu-features"></a>2.4. IOMMU features</h3>
<div class="paragraph">
<p>Version 1.0 of the RISC-V IOMMU specification supports the following
features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Memory-based device context to locate parameters and address translation
structures. The device context is located using the hardware-provided
unique <code>device_id</code>. The supported <code>device_id</code> width may be up to 24 bits.</p>
</li>
<li>
<p>Memory-based process context to locate parameters and address translation
structures using hardware-provided unique <code>process_id</code>. The supported
<code>process_id</code> may be up to 20 bits.</p>
</li>
<li>
<p>16-bit GSCIDs and 20-bit PSCIDs.</p>
</li>
<li>
<p>Two-stage address translation.</p>
</li>
<li>
<p>Page based virtual-memory system as specified by the RISC-V Privileged
specification cite:[PRIV] to allow software flexibility to either use a
common page table for the CPU MMU as well as the IOMMU or to use a
separate page table for the IOMMU.</p>
</li>
<li>
<p>Up to 57-bit virtual-address width, 56-bit system-physical-address, and
59-bit guest-physical-address width.</p>
</li>
<li>
<p>Hardware updating of PTE Accessed and Dirty bits.</p>
</li>
<li>
<p>Identifying memory accesses to a virtual interrupt file and MSI address
translation using MSI page tables specified by the RISC-V Advanced
Interrupt Architecture cite:[AIA].</p>
</li>
<li>
<p>Svnapot and Svpbmt extensions.</p>
</li>
<li>
<p>PCIe ATS and PRI services cite:[PCI]. Support for translating an IOVA to a
GPA instead of a SPA in response to a translation request.</p>
</li>
<li>
<p>A hardware performance monitor (HPM).</p>
</li>
<li>
<p>MSI and wire-signaled interrupts to request service from software.</p>
</li>
<li>
<p>A register interface for software to request an address translation to
support debug.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Features supported by the IOMMU may be discovered using the <code>capabilities</code>
register <a href="#CAP">Section 6.3</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="DATA_STRUCTURES"><a class="anchor" href="#DATA_STRUCTURES"></a>3. Data Structures</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A data structure called device-context (<code>DC</code>) is used by the IOMMU to associate
a device with an address space and to hold other per-device parameters used
by the IOMMU to perform address translations. A radix-tree data structure called
device directory table (DDT) that is traversed using the <code>device_id</code> is used to
locate the <code>DC</code>.</p>
</div>
<div class="paragraph">
<p>The address space used by a device may require second-stage address translation
and protection when the control of the device is passed through to a Guest OS.
A Guest OS may optionally provide a first-stage page table for translating IOVA
used by a device controlled by the Guest OS to a GPA. When the use of a
first-stage is not required, then it may be effectively disabled by selecting the
first-stage address translation scheme to be <code>Bare</code>. The second-stage is used to
translate the GPA to a SPA.</p>
</div>
<div class="paragraph">
<p>When the control of the device is retained by the hypervisor or Host OS itself
then only the first-stage suffices to perform necessary address translations and
protections; the second-stage scheme may be effectively disabled for the device by
programming the second-stage address translation scheme to be <code>Bare</code>.</p>
</div>
<div class="paragraph">
<p>When second-stage address translation is not Bare, the <code>DC</code> holds the PPN of the
root second-stage page table; a guest-soft-context-ID (<code>GSCID</code>), which
facilitates invalidation of cached address translations on a per-virtual-machine
basis; and the second-stage address translation scheme.</p>
</div>
<div class="paragraph">
<p>Some devices support multiple process contexts where each context may be
associated with a different process and thus a different virtual address space.
The context in such devices may be configured with a <code>process_id</code> that
identifies the address space. When making a memory access, such devices signal
the <code>process_id</code> along with the <code>device_id</code> to identify the accessed address
space. An example of such a device may be a GPU that supports multiple process
contexts, where each context is associated with a different user process, such
that the GPU may access memory using the virtual address provided by the user
process itself. To support selecting an address space associated with the
<code>process_id</code>, the <code>DC</code> holds the PPN of the root Process Directory Table (PDT),
a radix-tree data structure, indexed using fields of the <code>process_id</code> to locate
a data structure called the Process Context (<code>PC</code>).</p>
</div>
<div class="paragraph">
<p>When a PDT is active, the controls for first-stage address translation are held
in the (<code>PC</code>).</p>
</div>
<div class="paragraph">
<p>When a PDT is not active, the controls for first-stage address translation are
held in the <code>DC</code> itself.</p>
</div>
<div class="paragraph">
<p>The first-stage address translation controls include the PPN of the root
first-stage page table; a process-soft-context-ID (<code>PSCID</code>), which facilitates
invalidation of cached address translations on a per-address-space basis; and
the first-stage address translation scheme.</p>
</div>
<div class="paragraph">
<p>To handle MSIs from a device controlled by a guest OS, an IOMMU must be able to
redirect those MSIs to a guest interrupt file in an IMSIC. Because MSIs from
devices are simply memory writes, they would naturally be subject to the same
address translation that an IOMMU applies to other memory writes. However,
the IOMMU architecture may treat MSIs directed to virtual machines specially, in
part to simplify software, and in part to allow optional support for
memory-resident interrupt files. To support this capability, the architecture
adds to the device contexts an MSI address mask and address pattern, used together
to identify pages in the guest physical address space that are the destinations
of MSIs; and the real physical address of an MSI page table for controlling the
translation and/or conversion of MSIs from the device. The IOMMU support for
MSIs to virtual machines is specified by the Advanced Interrupt Architecture
specification.</p>
</div>
<div class="paragraph">
<p>The <code>DC</code> further holds controls for the type of transactions that a device is
allowed to generate. One example of such a control is whether the device is
allowed to use the PCIe defined Address Translation Service (ATS) cite:[PCI].</p>
</div>
<div class="paragraph">
<p>Two formats of the device-context structure are supported:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Base Format</strong> - is 32-bytes in size used when the special treatment of MSI
as specified in <a href="#MSI_TRANS">Section 3.3.3</a> is not supported by the IOMMU.</p>
</li>
<li>
<p><strong>Extended Format</strong> - is 64-bytes in size and extends the base format <code>DC</code> with
additional fields to translate MSIs as specified in <a href="#MSI_TRANS">Section 3.3.3</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If <code>capabilities.MSI_FLAT</code> is 1 then the Extended Format is used else the Base
Format is used.</p>
</div>
<div class="paragraph">
<p>The DDT used to locate the <code>DC</code> may be configured to be a 1, 2, or 3 level
radix-tree depending on the maximum width of the <code>device_id</code> supported. The
partitioning of the <code>device_id</code> to obtain the device directory indexes (DDI) to
traverse the DDT radix-tree are as follows:</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjDXUchLzE21UlB3cfGMNohVr9VBSFqiSBqiSlqgSBqBJWN1FJLz89Iy062qcxLzUoGqDHUUMooLEpNTrQwNjEx0FNLy80qKM6uA2gzNamsBjykqKA==" alt="Base format `device_id` partitioning">
</div>
<div class="title">Figure 7. Base format <code>device_id</code> partitioning</div>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjDTUchLzE21UlB3cfGMNohVr9VBSFqiSBrikzQCS8bqKCTn56VlpltV5yTmpQJVGeooZBQXJCanWhkaGJnoKKTl55UUZ1YBtRma1dYCAI7vKig=" alt="Extended format `device_id` partitioning">
</div>
<div class="title">Figure 8. Extended format <code>device_id</code> partitioning</div>
</div>
<div class="paragraph">
<p>The PDT may be configured to be a 1, 2, or 3 level radix-tree depending on the
maximum width of the <code>process_id</code> supported by that device.  The partitioning
of the <code>process_id</code> to obtain the process directory indices (PDI) to traverse
the PDT radix-tree are as follows:</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UrDQUchLzE21UlAPcPGMNohVr9VBSFqiSBqiShqjSBqBJWN1FJLz89Iy062qcxLzUoGqDHUUMooLEpNTrQwNjEx0FNLy80qKM6uA2gzNamsBmo8qSA==" alt="`process_id` partitioning for PDT radix-tree traversal">
</div>
<div class="title">Figure 9. <code>process_id</code> partitioning for PDT radix-tree traversal</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>process_id</code> partitioning is designed to require a maximum of 4 KiB, a
page, of memory for each process directory table. The root of the table when
using a 20-bit wide <code>process_id</code> is not fully populated. The option of making
the root table occupy 32 KiB was considered but not adopted as these tables
are allocated at run time and contiguous memory allocation larger than a page
may stress the Guest and hypervisor memory allocators.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>All RISC-V IOMMU implementations are required to support DDT and PDT located
in main memory. Supporting data structures in I/O memory is not required but
is not prohibited by this specification.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="device-directory-table-ddt"><a class="anchor" href="#device-directory-table-ddt"></a>3.1. Device-Directory-Table (DDT)</h3>
<div class="paragraph">
<p>The DDT is a 1, 2, or 3-level radix-tree indexed using the device directory
index (DDI) bits of the <code>device_id</code> to locate a <code>DC</code>.</p>
</div>
<div style="page-break-after: always;"></div>
<div class="paragraph">
<p>The following diagrams illustrate the DDT radix-tree. The PPN of the root
device-directory-table is held in a memory-mapped register called the
device-directory-table pointer (<code>ddtp</code>).</p>
</div>
<div class="paragraph">
<p>Each valid non-leaf (<code>NL</code>) entry is 8-bytes in size and holds the PPN of the
next device-directory-table.</p>
</div>
<div class="paragraph">
<p>A valid leaf device-directory-table entry holds the device-context (<code>DC</code>).</p>
</div>
<div class="imageblock text-center unresolved">
<div class="content">
<img src="images/ddt-ext.svg" alt="ddt ext" width="800" height="400">
</div>
<div class="title">Figure 10. Three, two and single-level device directory with extended format <code>DC</code></div>
</div>
<div class="imageblock text-center unresolved">
<div class="content">
<img src="images/ddt-base.svg" alt="ddt base" width="800" height="400">
</div>
<div class="title">Figure 11. Three, two and single-level device directory with base format <code>DC</code></div>
</div>
<div class="sect3">
<h4 id="non-leaf-ddt-entry"><a class="anchor" href="#non-leaf-ddt-entry"></a>3.1.1. Non-leaf DDT entry</h4>
<div class="paragraph">
<p>A valid (<code>V==1</code>) non-leaf DDT entry provides the PPN of the next level DDT.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjDUUVDIS8xNtVJQD1MHsiEgsaSkCChiqF6rg1BqqQNTWZRanFpUlpoC1ABVaYmi0sQErjQgwA9mLFSpiQmKWkMDhAswzTU0ACmO1VFIzs9Ly0y3qs5JzEsF6jLSUcgoLkhMTrUyNDAC2paWn1dSnFkFNMTQrLYWAH4yQUg=" alt="Non-leaf device-directory-table entry">
</div>
<div class="title">Figure 12. Non-leaf device-directory-table entry</div>
</div>
<div style="page-break-after: always;"></div>
</div>
<div class="sect3">
<h4 id="leaf-ddt-entry"><a class="anchor" href="#leaf-ddt-entry"></a>3.1.2. Leaf DDT entry</h4>
<div class="paragraph">
<p>The leaf DDT page is indexed by <code>DDI[0]</code> and holds the device-context (<code>DC</code>).</p>
</div>
<div class="paragraph">
<p>In base-format the <code>DC</code> is 32-bytes. In extended-format the <code>DC</code> is 64-bytes.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNp1jjEOgkAQRXtPMR2YQKLGUHAAo5WNnbEYYFg2wV0yMxiVcHdXLLSQ8v3k_byByeRwXgAMhVXJIdsmAA6vlEN0YnTSolrv0tI7Zd9CrOUyGpP_wuEI-0dHfLPiGUxPooBVxSQC-j0DdBV07JXKCWPrG4PazR__lqAq26JXkhCD887OsmgqioamerorxLV88i8JhK22Jh9adBTUYDbSYRnU9WoTqA6O2Oebs3F8AbjJYUk=" alt="Base-format device-context">
</div>
<div class="title">Figure 13. Base-format device-context</div>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqNkEFLw0AQhe_-irk1QgJWpEh-gNiD9KA3kTJJJulgsrvMTEUN-e_uhoI9mOLxDe8b3nujUFfC6xXAWLFpCZu7HMDhQCWsXgSd9mjsXVF7Z-J7yKy-Xk3538B2B49fgeSD1Qt0R1IDbBohVbDfZ4CugSDeqJ5lxv7QoYXlx-dJ0Ey4OhppDIPLzAOLWqGGHc3p6dMga_VC_KfnbRGS3bDqCYLnSAlkg3K4lC5xp5rFgPo-E_t02Sf5PzDEXiTujD1dlvHIxa2pSYa3HGLJlrty7NFRdN7ncNCAdXSub24j1sYRlL-T3kzTDx4Zo_Q=" alt="Extended-format device-context">
</div>
<div class="title">Figure 14. Extended-format device-context</div>
</div>
<div class="paragraph">
<p>The <code>DC</code> is interpreted as four 64-bit doublewords in base-format and as eight
64-bit doublewords in extended-format.  The byte order of each of the
doublewords in memory, little-endian or big-endian, is the endianness as
determined by <code>fctl.BE</code> (<a href="#FCTRL">Section 6.4</a>). The IOMMU may read the <code>DC</code> fields in any
order.</p>
</div>
</div>
<div class="sect3">
<h4 id="device-context-fields"><a class="anchor" href="#device-context-fields"></a>3.1.3. Device-context fields</h4>
<div class="sect4">
<h5 id="translation-control-tc"><a class="anchor" href="#translation-control-tc"></a>3.1.3.1. Translation control (<code>tc</code>)</h5>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNp9zkELgjAcBfB7n-J_87JDWkTstphJEDF0RBARZtOEnOGsQ7Lvnh0KBv49Pn7vwesaVVA4TgC6S9kaCj4B0GmlKHh7z5JBCHdnJpMRFfEGUxlEgmHI5RojwSX6R8QixixiPMQsGTEu8NkKp8PWpYD8qFFGNS91dXz55-xp2rpycDY8PhHIap2XBe3uqVZ9cU7gZh5p1jf9adCnvNatKd_fvHCTtR_YoI1y" alt="Translation control (`tc`) field">
</div>
<div class="title">Figure 15. Translation control (<code>tc</code>) field</div>
</div>
<div class="paragraph">
<p><code>DC</code> is valid if the <code>V</code> bit is 1; If it is 0, all other bits in <code>DC</code> are
don&#8217;t-care and may be freely used by software.</p>
</div>
<div class="paragraph">
<p>If the IOMMU supports PCIe ATS specification cite:[PCI] (see <code>capabilities</code>
register), the <code>EN_ATS</code> bit is used to enable ATS transaction processing. If
<code>EN_ATS</code> is set to 1, IOMMU supports the following inbound transactions;
otherwise they are treated as unsupported requests.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Translated read for execute transaction</p>
</li>
<li>
<p>Translated read transaction</p>
</li>
<li>
<p>Translated write/AMO transaction</p>
</li>
<li>
<p>PCIe ATS Translation Request</p>
</li>
<li>
<p>PCIe ATS Invalidation Completion Message</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the <code>EN_ATS</code> bit is 1 and the <code>T2GPA</code> bit is set to 1 the IOMMU performs the
two-stage address translation to determine the permissions and the size of the
translation to be provided in the completion of a PCIe ATS Translation Request
from the device. However, the IOMMU returns a GPA, instead of a SPA, as the
translation of an IOVA in the response. In this mode of operation, the ATC in the
device caches a GPA as a translation for an IOVA and uses the GPA as the address
in subsequent translated memory access transactions. Usually, translated requests
use a SPA and need no further translation to be performed by the IOMMU. However
when <code>T2GPA</code> is 1, translated requests from a device use a GPA and are
translated by the IOMMU using the second-stage page table to a SPA. The <code>T2GPA</code>
control enables a hypervisor to contain DMA from a device, even if the device
misuses the ATS capability and attempts to access memory that is not associated
with the VM.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When <code>T2GPA</code> is enabled, the addresses provided to the device in response to a
PCIe ATS Translation Request cannot be directly routed by the I/O fabric
(e.g. PCI switches) that connect the device to other peer devices and to host.
Such addresses also cannot be routed within the device when peer-to-peer
transactions within the device (e.g. between functions of a device) are
supported.</p>
</div>
<div class="paragraph">
<p>Use of <code>T2GPA</code> set to 1 may not be compatible with devices that implement caches
tagged by the translated address returned in response to a PCIe ATS Translation
Request.</p>
</div>
</td>
</tr>
</table>
</div>
<div style="page-break-after: always;"></div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Hypervisors that configure <code>T2GPA</code> to 1 must ensure through protocol-specific
means that translated accesses are routed through the host such that the IOMMU
may translate the GPA and then route the transaction based on PA to memory or
to a peer device. For PCIe, for example, the Access Control Service (ACS) must
be configured to always redirect peer-to-peer (P2P) requests upstream to the
host.</p>
</div>
<div class="paragraph">
<p>As an alternative to setting <code>T2GPA</code> to 1, the hypervisor may establish a trust
relationship with the device if authentication protocols are supported by the
device. For PCIe, for example, the PCIe component measurement and authentication
(CMA) capability provides a mechanism to verify the device&#8217;s configuration and
firmware/executable (Measurement) and hardware identities (Authentication) to
establish such a trust relationship.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code>EN_PRI</code> bit is 0, then PCIe "Page Request" messages from the device are
invalid requests. A "Page Request" message received from a device is responded to
with a "Page Request Group Response" message. Normally, a software handler
generates this response message. However, under some conditions the IOMMU itself
may generate a response. For IOMMU-generated "Page Request Group Response"
messages the PRG-response-PASID-required (<code>PRPR</code>) bit when set to 1 indicates
that the IOMMU response message should include a PASID if the associated
"Page Request" had a PASID.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Functions that support PASID and have the "PRG Response PASID Required"
capability bit set to 1, expect that "Page Request Group Response" messages will
contain a PASID if the associated "Page Request" message had a PASID. If the
capability bit is 0, the function does not expect PASID on any "Page Request
Group Response" message and the behavior of the function if it receives the
response with a PASID is undefined. The <code>PRPR</code> bit should be configured
with the value held in the "PRG Response PASID Required" capability bit.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Setting the disable-translation-fault (<code>DTF</code>) bit to 1 disables reporting of
faults encountered in the address translation process. Setting <code>DTF</code> to 1 does
not disable error responses from being generated to the device in response to
faulting transactions. Setting <code>DTF</code> to 1 does not disable reporting of faults
from the IOMMU that are not related to the address translation process. The
faults that are not reported when <code>DTF</code> is 1 are listed in <a href="#FAULT_CAUSE">Table 11</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A hypervisor may set <code>DTF</code> to 1 to disable fault reporting when it has
identified conditions that may lead to a flurry of errors such as due to an
abnormal termination of a virtual machine.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>DC.fsc</code> field holds the context for first-stage translation. If the
<code>PDTV</code> bit is 1, the field holds the process-directory table pointer (<code>pdtp</code>).
If the <code>PDTV</code> bit is 0, the <code>DC.fsc</code> field holds (<code>iosatp</code>).</p>
</div>
<div class="paragraph">
<p>The <code>PDTV</code> bit is expected to be set to 1 when <code>DC</code> is associated with a device
that supports multiple process contexts and thus generates a valid <code>process_id</code>
with its memory accesses. For PCIe, for example, if the request has a PASID
then the PASID is used as the <code>process_id</code>.</p>
</div>
<div class="paragraph">
<p>When <code>PDTV</code> is 1, the <code>DPE</code> bit may set to 1 to enable the use of 0 as the
default value of <code>process_id</code> for translating requests without a valid
<code>process_id</code>. When <code>PDTV</code> is 0, the <code>DPE</code> bit is reserved for future standard
extension.</p>
</div>
<div class="paragraph">
<p>The IOMMU supports the 1 setting of <code>GADE</code> and <code>SADE</code> bits if
<code>capabilities.AMO_HWAD</code> is 1. When <code>capabilities.AMO_HWAD</code> is 0, these bits are
reserved.</p>
</div>
<div class="paragraph">
<p>If <code>GADE</code> is 1, the IOMMU updates A and D bits in second-stage PTEs atomically.
If <code>GADE</code> is 0, the IOMMU causes a guest-page-fault corresponding to the original
access type if the A bit is 0 or if the memory access is a store and the D bit
is 0.</p>
</div>
<div class="paragraph">
<p>If <code>SADE</code> is 1, the IOMMU updates A and D bits in first-stage PTEs atomically. If
<code>SADE</code> is 0, the IOMMU causes a page-fault corresponding to the original access
type if the A bit is 0 or if the memory access is a store and the D bit is 0.</p>
</div>
<div class="paragraph">
<p>If <code>SBE</code> is 0, implicit memory accesses to PDT entries and first-stage PTEs are
little-endian else they are big-endian. The supported values of <code>SBE</code> are the
same as that of the <code>fctl.BE</code> field.</p>
</div>
<div class="paragraph">
<p>The <code>SXL</code> field controls the supported paged virtual-memory schemes as defined
in <a href="#IOSATP_MODE_ENC">Table 3</a>. If <code>fctl.GXL</code> is 1 then the <code>SXL</code> field must be 1;
otherwise the legal values for the <code>SXL</code> field are the same as those for the
<code>fctl.GXL</code> field.</p>
</div>
<div class="paragraph">
<p>When <code>SXL</code> is 1, the following rules apply:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the first-stage is not Bare, then a page fault corresponding to the original
access type occurs if the <code>IOVA</code> has bits beyond bit 31 set to 1.</p>
</li>
<li>
<p>If the second-stage is not Bare, then a guest page fault corresponding to the
original access type occurs if the incoming GPA has bits beyond bit 33 set to 1.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="io-hypervisor-guest-address-translation-and-protection-iohgatp"><a class="anchor" href="#io-hypervisor-guest-address-translation-and-protection-iohgatp"></a>3.1.3.2. IO hypervisor guest address translation and protection (<code>iohgatp</code>)</h5>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjAx0VHIS8xNtVJQDwjwU6_VQUgZmsGl3IOdPV1QJIHaYJK-_i6uILlYHYXk_Ly0zHSr6pzEvFSgIiMdhYzigsRkoCpDAyOglrT8vJLizCoQ36y2FgAe0ykT" alt="IO hypervisor guest address translation and protection (`iohgatp`) field">
</div>
<div class="title">Figure 16. IO hypervisor guest address translation and protection (<code>iohgatp</code>) field</div>
</div>
<div class="paragraph">
<p>The <code>iohgatp</code> field holds the PPN of the root second-stage page table and a
virtual machine identified by a guest soft-context ID (<code>GSCID</code>), to facilitate
address-translation fences on a per-virtual-machine basis. If multiple devices
are associated to a VM with a common second-stage page table, the hypervisor is
expected to program the same <code>GSCID</code> in each <code>iohgatp</code>. The <code>MODE</code> field is used
to select the second-stage address translation scheme.</p>
</div>
<div class="paragraph">
<p>The second-stage page table formats are as defined by the Privileged
specification.  The <code>fctl.GXL</code> field controls the supported address-translation
schemes for guest physical addresses as defined in <a href="#IOHGATP_MODE_ENC">Table 2</a>.</p>
</div>
<div class="paragraph">
<p>The <code>iohgatp</code> <code>MODE</code> field identifies the paged virtual-memory schemes and its
encodings are as follows:</p>
</div>
<table id="IOHGATP_MODE_ENC" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 2. Encodings of <code>iohgatp.MODE</code> field</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="3"><code>fctl.GXL=0</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Value</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Name</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Description</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>Bare</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No translation or protection.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1-7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">&#8201;&#8212;&#8201;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>Sv39x4</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Page-based 41-bit virtual addressing (2-bit extension
                    of Sv39).</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">9</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>Sv48x4</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Page-based 50-bit virtual addressing (2-bit extension
                    of Sv48).</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>Sv57x4</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Page-based 59-bit virtual addressing (2-bit extension
                    of Sv57).</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">11-15</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">&#8201;&#8212;&#8201;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="3"><p class="tableblock"><code>fctl.GXL=1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Value</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Description</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>Bare</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No translation or protection.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1-7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">&#8201;&#8212;&#8201;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>Sv32x4</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Page-based 34-bit virtual addressing (2-bit extension
                    of Sv32).</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">9-15</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">&#8201;&#8212;&#8201;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Implementations are not required to support all defined mode settings for
<code>iohgatp</code>. The IOMMU only needs to support the modes also supported by the MMU
in the harts integrated into the system or a subset thereof.</p>
</div>
<div class="paragraph">
<p>The root page table as determined by <code>iohgatp.PPN</code> is 16 KiB and must be aligned
to a 16-KiB boundary.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>GSCID</code> field of <code>iohgatp</code> identifies an address space. If an identical
<code>GSCID</code> is configured in two <code>DC</code> when the second-stage page-table referenced by
the two <code>DC</code> are not identical then it is unpredictable whether the IOMMU uses
the PTEs from the first page table or the second page table. These are the only
expected behaviors.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="DC_TA"><a class="anchor" href="#DC_TA"></a>3.1.3.3. Translation attributes (<code>ta</code>)</h5>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjA00lHIS8xNtVJQL0otTi0qS01Rr9VByBsZwOUDgp09XVAkLfDrRTI7CF0rkpwvVC5WRyE5Py8tM92qOicxLxVkuY5CRnFBYjJQlaGBkYmOQlp-XklxZhWIb1ZbCwBTDjzG" alt="Translation attributes (`ta`) field">
</div>
<div class="title">Figure 17. Translation attributes (<code>ta</code>) field</div>
</div>
<div class="paragraph">
<p>The <code>PSCID</code> field of <code>ta</code> provides the process soft-context ID that identifies
the address-space of the process. <code>PSCID</code> facilitates address-translation
fences on a per-address-space basis. The <code>PSCID</code> field in <code>ta</code> is used as the
address-space ID if <code>DC.tc.PDTV</code> is 0 and the <code>iosatp.MODE</code> field is not <code>Bare</code>.
When <code>DC.tc.PDTV</code> is 1, the <code>PSCID</code> field in <code>ta</code> is ignored.</p>
</div>
<div class="paragraph">
<p>The <code>RCID</code> and <code>MCID</code> fields are added by the QoS ID extension. If
<code>capabilities.QOSID</code> is 0, these bits are reserved and must be set to 0.
IOMMU-initiated requests for accessing the following data structures use the
value configured in the <code>RCID</code> and <code>MCID</code> fields of <code>DC.ta</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Process directory table (<code>PDT</code>)</p>
</li>
<li>
<p>Second-stage page table</p>
</li>
<li>
<p>First-stage page table</p>
</li>
<li>
<p>MSI page table</p>
</li>
<li>
<p>Memory-resident interrupt file (<code>MRIF</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>RCID</code> and <code>MCID</code> configured in <code>DC.ta</code> are provided to the IO bridge on
successful address translations. The IO bridge should associate these QoS IDs
with device-initiated requests.</p>
</div>
</div>
<div class="sect4">
<h5 id="first-stage-context-fsc"><a class="anchor" href="#first-stage-context-fsc"></a>3.1.3.4. First-Stage context (<code>fsc</code>)</h5>
<div class="paragraph">
<p>If <code>DC.tc.PDTV</code> is 0, the <code>DC.fsc</code> field holds the <code>iosatp</code> that provides
the controls for first-stage address translation and protection.</p>
</div>
<div id="IOSATP_FORMAT" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjAx0VHIS8xNtVJQDwjwU6_VQUgZmsGlilKLU4vKUlNQ5IE6YfK-_i6uILlYHYXk_Ly0zHSr6pzEvFSgIiMdhYzigsRkoCpDAyOglrT8vJLizCoQ36y2FgD3HysJ?id=IOSATP_FORMAT" alt="IO Supervisor address translation and prot. (`iosatp`) field">
</div>
<div class="title">Figure 18. IO Supervisor address translation and prot. (<code>iosatp</code>) field</div>
</div>
<div class="paragraph">
<p>The first-stage page table formats are as defined by the Privileged specification.</p>
</div>
<div class="paragraph">
<p>The <code>DC.tc.SXL</code> field controls the supported paged virtual-memory schemes.</p>
</div>
<div class="paragraph">
<p>The <code>iosatp.MODE</code> identifies the paged virtual-memory schemes and is encoded
as defined in <a href="#IOSATP_MODE_ENC">Table 3</a>. The <code>iosatp.PPN</code> field holds the PPN of the
root page of a first-stage page table.</p>
</div>
<div class="paragraph">
<p>When second-stage address translation is not <code>Bare</code>, the <code>iosatp.PPN</code> is a guest
PPN. The GPA of the root page is then converted by guest physical address
translation process, as controlled by the <code>iohgatp</code>, into a supervisor physical
address.</p>
</div>
<table id="IOSATP_MODE_ENC" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 3. Encodings of <code>iosatp.MODE</code> field</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="3"><code>DC.tc.SXL=0</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Value</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Name</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Description</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>Bare</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No translation or protection.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1-7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">&#8201;&#8212;&#8201;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>Sv39</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Page-based 39-bit virtual addressing.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">9</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>Sv48</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Page-based 48-bit virtual addressing.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>Sv57</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Page-based 57-bit virtual addressing.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">11-13</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">&#8201;&#8212;&#8201;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">14-15</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">&#8201;&#8212;&#8201;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Designated for custom use.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="3"><p class="tableblock"><code>DC.tc.SXL=1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Value</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Description</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>Bare</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No translation or protection.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1-7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">&#8201;&#8212;&#8201;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>Sv32</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Page-based 32-bit virtual addressing.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">9-15</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">&#8201;&#8212;&#8201;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>When <code>DC.tc.PDTV</code> is 1, the <code>DC.fsc</code> field holds the process-directory table
pointer (<code>pdtp</code>). When the device supports multiple process contexts, selected
by the <code>process_id</code>, the PDT is used to determine the first-stage page table and
associated <code>PSCID</code> for virtual address translation and protection.</p>
</div>
<div class="paragraph">
<p>The <code>pdtp</code> field holds the PPN of the root PDT and the <code>MODE</code> field that
determines the number of levels of the PDT.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjAx0VHIS8xNtVJQDwjwU6_VQUgZmsGlilKLU4vKUlNQ5IE6YfK-_i6uILlYHYXk_Ly0zHSr6pzEvFSgIiMdhYzigsRkoCpDAyOglrT8vJLizCoQ36y2FgD3HysJ" alt="Process-directory table pointer (`pdtp`) field">
</div>
<div class="title">Figure 19. Process-directory table pointer (<code>pdtp</code>) field</div>
</div>
<div class="paragraph">
<p>When second-stage address translation is not Bare, the <code>pdtp.PPN</code> field holds a
guest PPN. The GPA of the root PDT is then converted by guest physical address
translation process, as controlled by the <code>iohgatp</code>, into a supervisor physical
address. Translating addresses of PDT using a second-stage page table, allows the
PDT to be held in memory allocated by the guest OS and allows the guest OS to
directly edit the PDT to associate a virtual-address space identified by a
first-stage page table with a <code>process_id</code>.</p>
</div>
<table id="PDTP_MODE_ENC" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 4. Encodings of <code>pdtp.MODE</code> field</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Value</th>
<th class="tableblock halign-center valign-top">Name</th>
<th class="tableblock halign-center valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>Bare</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No first-stage address translation or protection.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>PD8</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8-bit process ID enabled. The directory has 1 levels with
                    256 entries.The bits 19:8 of <code>process_id</code> must be 0.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>PD17</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">17-bit process ID enabled. The directory has 2 levels.
                    The root PDT page has 512 entries and leaf level has
                    256 entries. The bits 19:17 of <code>process_id</code> must be 0.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>PD20</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20-bit process ID enabled. The directory has 3 levels.
                    The root PDT has 8 entries and the next non-leaf
                    level has 512 entries. The leaf level has 256 entries.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">4-13</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">&#8201;&#8212;&#8201;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">14-15</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">&#8201;&#8212;&#8201;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Designated for custom use.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="msi-page-table-pointer-msiptp"><a class="anchor" href="#msi-page-table-pointer-msiptp"></a>3.1.3.5. MSI page table pointer (<code>msiptp</code>)</h5>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjAx0VHIS8xNtVJQDwjwU6_VQUgZmsGlilKLU4vKUlNQ5IE6YfK-_i6uILlYHYXk_Ly0zHSr6pzEvFSgIiMdhYzigsRkoCpDAyOglrT8vJLizCoQ36y2FgD3HysJ" alt="MSI page table pointer (`msiptp`) field">
</div>
<div class="title">Figure 20. MSI page table pointer (<code>msiptp</code>) field</div>
</div>
<div class="paragraph">
<p>The <code>msiptp.PPN</code> field holds the PPN of the root MSI page table used to direct
an MSI to a guest interrupt file in an IMSIC. The MSI page table formats are
defined by the Advanced Interrupt Architecture specification.</p>
</div>
<div class="paragraph">
<p>The <code>msiptp.MODE</code> field is used to select the MSI address translation scheme.</p>
</div>
<div style="page-break-after: always;"></div>
<table class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 5. Encodings of <code>msiptp.MODE</code> field</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Value</th>
<th class="tableblock halign-center valign-top">Name</th>
<th class="tableblock halign-center valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>Off</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Recognition of accesses to
                    a virtual interrupt file using MSI address mask and
                    pattern is not performed.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>Flat</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Flat MSI page table</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">2-13</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">&#8201;&#8212;&#8201;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">14-15</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">&#8201;&#8212;&#8201;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Designated for custom use.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="MSI_ID"><a class="anchor" href="#MSI_ID"></a>3.1.3.6. MSI address mask (<code>msi_addr_mask</code>) and pattern (<code>msi_addr_pattern</code>)</h5>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjA10lHIS8xNtVJQz00szlav1UHIGSLkilKLU4vKUlNA8rE6Csn5eWmZ6VbVOYl5qUCFQHUZxQWJyUCVhgZGJjoKafl5JcWZVSC-WW0tADOtJDo=" alt="MSI address mask (`msi_addr_mask`) field">
</div>
<div class="title">Figure 21. MSI address mask (<code>msi_addr_mask</code>) field</div>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNpFyjEOgCAMQNHdU3RzYRCiDlzFOCAWJNFqoHGQcHdxcvx5P0f0GqYGIC-Bk4ZBCSBzoIb2MswYqS3iZ_lzxITxxvXzWYA9yQWv824I61i_LV3G1lN2qhfgTuIUnq_HUl7D6SWM" alt="MSI address pattern (`msi_addr_pattern`) field">
</div>
<div class="title">Figure 22. MSI address pattern (<code>msi_addr_pattern</code>) field</div>
</div>
<div class="paragraph">
<p>The MSI address mask (<code>msi_addr_mask</code>) and pattern (<code>msi_addr_pattern</code>) fields
are used to identify the 4-KiB pages of virtual interrupt files in the guest
physical address space of the relevant VM. An incoming memory access made by a
device is recognized as an access to a virtual interrupt file if the destination
guest physical page matches the supplied address pattern in all bit positions
that are zeros in the supplied address mask. In detail, a memory access to guest
physical address <code>A</code> is recognized as an access to a virtual interrupt file&#8217;s
memory-mapped page if:</p>
</div>
<div class="paragraph">
<p><code>(A &gt;&gt; 12) &amp; ~msi_addr_mask = (msi_addr_pattern &amp; ~msi_addr_mask)</code></p>
</div>
<div class="paragraph">
<p>where &gt;&gt; 12 represents shifting right by 12 bits, an ampersand (&amp;) represents
bitwise logical AND, and <code>~msi_addr_mask</code> is the bitwise logical complement of
the address mask.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="DC_MISCONFIG"><a class="anchor" href="#DC_MISCONFIG"></a>3.1.4. Device-context configuration checks</h4>
<div class="paragraph">
<p>A <code>DC</code> with <code>DC.tc.V=1</code> is considered as misconfigured if any of the following
conditions are true. If misconfigured then, stop and report "DDT entry
misconfigured" (cause = 259).</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If any bits or encodings that are reserved for future standard use are set.</p>
</li>
<li>
<p><code>capabilities.ATS</code> is 0 and <code>DC.tc.EN_ATS</code>, or <code>DC.tc.EN_PRI</code>,
or <code>DC.tc.PRPR</code> is 1</p>
</li>
<li>
<p><code>DC.tc.EN_ATS</code> is 0 and <code>DC.tc.T2GPA</code> is 1</p>
</li>
<li>
<p><code>DC.tc.EN_ATS</code> is 0 and <code>DC.tc.EN_PRI</code> is 1</p>
</li>
<li>
<p><code>DC.tc.EN_PRI</code> is 0 and <code>DC.tc.PRPR</code> is 1</p>
</li>
<li>
<p><code>capabilities.T2GPA</code> is 0 and <code>DC.tc.T2GPA</code> is 1</p>
</li>
<li>
<p><code>DC.tc.T2GPA</code> is 1 and <code>DC.iohgatp.MODE</code> is <code>Bare</code></p>
</li>
<li>
<p><code>DC.tc.PDTV</code> is 1 and <code>DC.fsc.pdtp.MODE</code> is not a supported mode</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>capabilities.PD20</code> is 0 and <code>DC.fsc.pdtp.MODE</code> is <code>PD20</code></p>
</li>
<li>
<p><code>capabilities.PD17</code> is 0 and <code>DC.fsc.pdtp.MODE</code> is <code>PD17</code></p>
</li>
<li>
<p><code>capabilities.PD8</code> is 0 and <code>DC.fsc.pdtp.MODE</code> is <code>PD8</code></p>
</li>
</ol>
</div>
</li>
<li>
<p><code>DC.tc.PDTV</code> is 0 and <code>DC.fsc.iosatp.MODE</code> encoding is not a valid
encoding as determined by <a href="#IOSATP_MODE_ENC">Table 3</a></p>
</li>
<li>
<p><code>DC.tc.PDTV</code> is 0 and <code>DC.tc.SXL</code> is 0 <code>DC.fsc.iosatp.MODE</code>
is not one of the supported modes</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>capabilities.Sv39</code> is 0 and <code>DC.fsc.iosatp.MODE</code> is <code>Sv39</code></p>
</li>
<li>
<p><code>capabilities.Sv48</code> is 0 and <code>DC.fsc.iosatp.MODE</code> is <code>Sv48</code></p>
</li>
<li>
<p><code>capabilities.Sv57</code> is 0 and <code>DC.fsc.iosatp.MODE</code> is <code>Sv57</code></p>
</li>
</ol>
</div>
</li>
<li>
<p><code>DC.tc.PDTV</code> is 0 and <code>DC.tc.SXL</code> is 1 <code>DC.fsc.iosatp.MODE</code>
is not one of the supported modes</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>capabilities.Sv32</code> is 0 and <code>DC.fsc.iosatp.MODE</code> is <code>Sv32</code></p>
</li>
</ol>
</div>
</li>
<li>
<p><code>DC.tc.PDTV</code> is 0 and <code>DC.tc.DPE</code> is 1</p>
</li>
<li>
<p><code>DC.iohgatp.MODE</code> encoding is not a valid encoding as determined
by <a href="#IOHGATP_MODE_ENC">Table 2</a></p>
</li>
<li>
<p><code>fctl.GXL</code> is 0 and <code>DC.iohgatp.MODE</code> is not a supported mode</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>capabilities.Sv39x4</code> is 0 and <code>DC.iohgatp.MODE</code> is <code>Sv39x4</code></p>
</li>
<li>
<p><code>capabilities.Sv48x4</code> is 0 and <code>DC.iohgatp.MODE</code> is <code>Sv48x4</code></p>
</li>
<li>
<p><code>capabilities.Sv57x4</code> is 0 and <code>DC.iohgatp.MODE</code> is <code>Sv57x4</code></p>
</li>
</ol>
</div>
</li>
<li>
<p><code>fctl.GXL</code> is 1 and <code>DC.iohgatp.MODE</code> is not a supported mode</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>capabilities.Sv32x4</code> is 0 and <code>DC.iohgatp.MODE</code> is <code>Sv32x4</code></p>
</li>
</ol>
</div>
</li>
<li>
<p><code>capabilities.MSI_FLAT</code> is 1 and <code>DC.msiptp.MODE</code> is not <code>Off</code>
and not <code>Flat</code></p>
</li>
<li>
<p><code>DC.iohgatp.MODE</code> is not <code>Bare</code> and the root page table determined by
<code>DC.iohgatp.PPN</code> is not aligned to a 16-KiB boundary.</p>
</li>
<li>
<p><code>capabilities.AMO_HWAD</code> is 0 and <code>DC.tc.SADE</code> or <code>DC.tc.GADE</code> is 1</p>
</li>
<li>
<p><code>capabilities.END</code> is 0 and <code>fctl.BE != DC.tc.SBE</code></p>
</li>
<li>
<p><code>DC.tc.SXL</code> value is not a legal value. If <code>fctl.GXL</code> is 1, then
<code>DC.tc.SXL</code> must be 1. If <code>fctl.GXL</code> is 0 and is writable, then
<code>DC.tc.SXL</code> may be 0 or 1. If <code>fctl.GXL</code> is 0 and is not writable
then <code>DC.tc.SXL</code> must be 0.</p>
</li>
<li>
<p><code>DC.tc.SBE</code> value is not a legal value. If <code>fctl.BE</code> is writable
then <code>DC.tc.SBE</code> may be 0 or 1. If <code>fctl.BE</code> is not writable then
<code>DC.tc.SBE</code> must be the same as <code>fctl.BE</code>.</p>
</li>
<li>
<p><code>capabilities.QOSID</code> is 1 and <code>DC.ta.RCID</code> or <code>DC.ta.MCID</code> values
are wider than that supported by the IOMMU.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Some <code>DC</code> fields hold supervisor physical addresses or
guest physical addresses. Some implementations may verify the validity of the
addresses - e.g. the supervisor physical address is not wider than that
supported as determined by <code>capabilities.PAS</code>, etc. at the time of locating the
<code>DC</code>. Such implementations may cause a "DDT entry misconfigured" (cause = 259)
fault.</p>
</div>
<div class="paragraph">
<p>Other implementations only detect such addresses to be invalid when the data
structure referenced by these fields needs to be accessed. Such
implementations may detect access-violation faults in the process of making
the access.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="process-directory-table-pdt"><a class="anchor" href="#process-directory-table-pdt"></a>3.2. Process-Directory-Table (PDT)</h3>
<div class="paragraph">
<p>The PDT is a 1, 2, or 3-level radix-tree indexed using the process directory
index (<code>PDI</code>) bits of the <code>process_id</code>.</p>
</div>
<div class="paragraph">
<p>The following diagrams illustrate the PDT radix-tree. The root
process-directory page number is located using the process-directory-table
pointer (<code>pdtp</code>) field of the device-context. Each non-leaf (<code>NL</code>) entry
provides the PPN of the next level process-directory-table. The leaf
process-directory-table entry holds the process-context (<code>PC</code>).</p>
</div>
<div class="imageblock unresolved">
<div class="content">
<img src="images/pdt.svg" alt="pdt" width="800" height="400">
</div>
<div class="title">Figure 23. Three, two and single-level process directory</div>
</div>
<div class="sect3">
<h4 id="non-leaf-pdt-entry"><a class="anchor" href="#non-leaf-pdt-entry"></a>3.2.1. Non-leaf PDT entry</h4>
<div class="paragraph">
<p>A valid (<code>V==1</code>) non-leaf PDT entry holds the PPN of the next-level PDT.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UlAw1FHIS8xNtVJQD1PXUYCCxJKSIqCIoXqtDpJSS7jSotTi1KKy1BSgDqhSSxSlJiZwpQEBfjBzoUpNTFDUGhrgMdbQAKQ2VkchOT8vLTPdqjonMS8VqMlIRyGjuCAxOdXK0MAIaFlafl5JcWYV0BBDs9paAHD8QUg=" alt="Non-leaf process-directory-table entry">
</div>
<div class="title">Figure 24. Non-leaf process-directory-table entry</div>
</div>
</div>
<div class="sect3">
<h4 id="leaf-pdt-entry"><a class="anchor" href="#leaf-pdt-entry"></a>3.2.2. Leaf PDT entry</h4>
<div class="paragraph">
<p>The leaf PDT page is indexed by <code>PDI[0]</code> and holds the 16-byte process-context
(<code>PC</code>).</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNptzEEKwjAQheG9p5hdKySgRbrIATyBu-JiGiZxoKaSGUEacvdG1y7fD98rmaKD6QBQZlZxMF4MQMInOehuGZMsqLwmi6qZ57eSQK947Kr5b66cRa0oRrJ-TUofhT6I_4m7gdYCR1cWTNToYOAhL_SNnk9D-wnNCG_fPda6A92dMuk=" alt="Process-context">
</div>
<div class="title">Figure 25. Process-context</div>
</div>
<div class="paragraph">
<p>The <code>PC</code> is interpreted as two 64-bit doublewords. The byte order of each of the
doublewords in memory, little-endian or big-endian, is the endianness as
determined by <code>DC.tc.SBE</code>. The IOMMU may read the <code>PC</code> fields in any order.</p>
</div>
</div>
<div class="sect3">
<h4 id="process-context-fields"><a class="anchor" href="#process-context-fields"></a>3.2.3. Process-context fields</h4>
<div class="sect4">
<h5 id="translation-attributes-ta"><a class="anchor" href="#translation-attributes-ta"></a>3.2.3.1. Translation attributes (<code>ta</code>)</h5>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjDUUVDIS8xNtVJQD1MHsiEgsaSkCChiqF6rg1Wpq18wVDEhlcGhvhCVWBVa6sDUFaUWpxaVpaYAFUNVWqKoNDKAKw0IdvZ0QTHUyABFrbERHmONjUBqY3UUkvPz0jLTrapzEvNSgZpMdBQyigsSk4G6DA2MgLy0_LyS4swqEN-sthYAPxhWxg==" alt="Translation attributes (`ta`) field">
</div>
<div class="title">Figure 26. Translation attributes (<code>ta</code>) field</div>
</div>
<div class="paragraph">
<p><code>PC</code> is valid if the <code>V</code> bit is 1; If it is 0, all other bits in <code>PC</code> are don&#8217;t
care and may be freely used by software.</p>
</div>
<div class="paragraph">
<p>When Enable-Supervisory-access (<code>ENS</code>) is 1, transactions requesting supervisor
privilege are allowed with this <code>process_id</code> else the transaction is treated as
an unsupported request.</p>
</div>
<div class="paragraph">
<p>When <code>ENS</code> is 1, the <code>SUM</code> (permit Supervisor User Memory access) bit modifies
the privilege with which supervisor privilege transactions access virtual
memory. When <code>SUM</code> is 0, supervisor privilege transactions to pages mapped with
<code>U</code> bit in PTE set to 1 are disallowed.</p>
</div>
<div class="paragraph">
<p>When <code>ENS</code> is 1, supervisor privilege transactions that read with execute
intent to pages mapped with <code>U</code> bit in PTE set to 1 are disallowed, regardless
of the value of <code>SUM</code>.</p>
</div>
<div class="paragraph">
<p>The software assigned process soft-context ID (<code>PSCID</code>) is used as the address
space ID for the process identified by the first-stage page table when
first-stage address translation is not Bare.</p>
</div>
</div>
<div class="sect4">
<h5 id="first-stage-context-fsc-2"><a class="anchor" href="#first-stage-context-fsc-2"></a>3.2.3.2. First-Stage context (<code>fsc</code>)</h5>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjAx0VHIS8xNtVJQDwjwU6_VQUgZmsGlilKLU4vKUlNQ5IE6YfK-_i6uILlYHYXk_Ly0zHSr6pzEvFSgIiMdhYzigsRkoCpDAyOglrT8vJLizCoQ36y2FgD3HysJ" alt="Process First-Stage context">
</div>
<div class="title">Figure 27. Process First-Stage context</div>
</div>
<div class="paragraph">
<p>The <code>PC.fsc</code> field provides the controls for first-stage address translation and
protection.</p>
</div>
<div class="paragraph">
<p>The <code>PC.fsc.MODE</code> is used to determine the first-stage paged virtual-memory
scheme and its encodings are as defined in <a href="#IOSATP_MODE_ENC">Table 3</a>. The <code>DC.tc.SXL</code>
field controls the supported paged virtual-memory schemes. When <code>PC.fsc.MODE</code> is
not <code>Bare</code>, the <code>PC.fsc.PPN</code> field holds the PPN of the root page of a
first-stage page table.</p>
</div>
<div class="paragraph">
<p>When second-stage address translation is not Bare, the <code>PC.fsc.PPN</code> field holds
a guest PPN of the root of a first-stage page table. Addresses of the first-stage
page table entries are then converted by guest physical address translation
process, as controlled by the <code>DC.iohgatp</code>, into a supervisor physical address.
A guest OS may thus directly edit the first-stage page table to limit access by
the device to a subset of its memory and specify permissions for the device
accesses.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>PC.ta.PSCID</code> identifies an address space. If an identical
<code>PSCID</code> is configured in two <code>PC</code> when the page-table referenced by the two <code>PC</code>
are not identical then it is unpredictable whether the IOMMU uses the PTEs from
the first page table or the second page table. These are the only expected
behaviors.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="PC_MISCONFIG"><a class="anchor" href="#PC_MISCONFIG"></a>3.2.4. Process-context configuration checks</h4>
<div class="paragraph">
<p>A <code>PC</code> with <code>PC.ta.V=1</code> is considered as misconfigured if any of the following
conditions are true. If misconfigured then stop and report "PDT entry
misconfigured" (cause = 267).</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If any bits or encoding that are reserved for future standard use are set</p>
</li>
<li>
<p><code>PC.fsc.MODE</code> encoding is not valid as determined by <a href="#IOSATP_MODE_ENC">Table 3</a></p>
</li>
<li>
<p><code>DC.tc.SXL</code> is 0 and <code>PC.fsc.MODE</code> is not one of the supported modes</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>capabilities.Sv39</code> is 0 and <code>PC.fsc.MODE</code> is <code>Sv39</code></p>
</li>
<li>
<p><code>capabilities.Sv48</code> is 0 and <code>PC.fsc.MODE</code> is <code>Sv48</code></p>
</li>
<li>
<p><code>capabilities.Sv57</code> is 0 and <code>PC.fsc.MODE</code> is <code>Sv57</code></p>
</li>
</ol>
</div>
</li>
<li>
<p><code>DC.tc.SXL</code> is 1 and <code>PC.fsc.MODE</code> is not one of the supported modes</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>capabilities.Sv32</code> is 0 and <code>PC.fsc.MODE</code> is <code>Sv32</code></p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div style="page-break-after: always;"></div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Some <code>PC</code> fields hold supervisor physical addresses or
guest physical addresses. Some implementations may verify the validity of the
addresses - e.g. the supervisor physical address is not wider than that supported
as determined by <code>capabilities.PAS</code>, etc. at the time of locating the <code>PC</code>.
Such implementations may cause a "PDT entry misconfigured" (cause = 267) fault.</p>
</div>
<div class="paragraph">
<p>Other implementations only detect such addresses to be invalid when the data
structure referenced by these fields needs to be accessed. Such implementations
may detect access-violation faults in the process of making the access.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="P2IOVA"><a class="anchor" href="#P2IOVA"></a>3.3. Process to translate an IOVA</h3>
<div class="paragraph">
<p>The process to translate an IOVA uses the hardware IDs (<code>device_id</code> and
<code>process_id</code>) to locate the Device-Context and the Process-Context. The
Device-context and Process-context provide the root PPN of the page tables,
<code>PSCID</code>, <code>GSCID</code>, and other control parameters that affect the address
translation and protection process. When address translation caches
(<a href="#CACHING">Section 3.8</a>) are implemented, the translation process may use the <code>GSCID</code> and
<code>PSCID</code> to associate the cached translations with their address spaces.</p>
</div>
<div class="paragraph">
<p>The process to translate an <code>IOVA</code> is as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If <code>ddtp.iommu_mode == Off</code> then stop and report "All inbound transactions
disallowed" (cause = 256).</p>
</li>
<li>
<p>If <code>ddtp.iommu_mode == Bare</code> and any of the following conditions hold then
stop and report "Transaction type disallowed" (cause = 260); else go to step
20 with translated address same as the <code>IOVA</code>.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Transaction type is a Translated request (read, write/AMO, read-for-execute)
or is a PCIe ATS Translation request.</p>
</li>
</ol>
</div>
</li>
<li>
<p>If <code>capabilities.MSI_FLAT</code> is 0 then the IOMMU uses base-format device
context. Let <code>DDI[0]</code> be <code>device_id[6:0]</code>, <code>DDI[1]</code> be <code>device_id[15:7]</code>, and
<code>DDI[2]</code> be <code>device_id[23:16]</code>.</p>
</li>
<li>
<p>If <code>capabilities.MSI_FLAT</code> is 1 then the IOMMU uses extended-format device
context. Let <code>DDI[0]</code> be <code>device_id[5:0]</code>, <code>DDI[1]</code> be <code>device_id[14:6]</code>, and
<code>DDI[2]</code> be <code>device_id[23:15]</code>.</p>
</li>
<li>
<p>If the <code>device_id</code> is wider than that supported by the IOMMU mode, as
determined by the following checks then stop and report "Transaction type
disallowed" (cause = 260).</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>ddtp.iommu_mode</code> is <code>2LVL</code> and <code>DDI[2]</code> is not 0</p>
</li>
<li>
<p><code>ddtp.iommu_mode</code> is <code>1LVL</code> and either <code>DDI[2]</code> is not 0 or <code>DDI[1]</code> is not 0</p>
</li>
</ol>
</div>
</li>
<li>
<p>Use <code>device_id</code> to then locate the device-context (<code>DC</code>) as specified in
<a href="#GET_DC">Section 3.3.1</a>.</p>
</li>
<li>
<p>If any of the following conditions hold then stop and report
"Transaction type disallowed" (cause = 260).</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Transaction type is a Translated request (read, write/AMO, read-for-execute)
or is a PCIe ATS Translation request and <code>DC.tc.EN_ATS</code> is 0.</p>
</li>
<li>
<p>Transaction has a valid <code>process_id</code> and <code>DC.tc.PDTV</code> is 0.</p>
</li>
<li>
<p>Transaction has a valid <code>process_id</code> and <code>DC.tc.PDTV</code> is 1 and the
<code>process_id</code> is wider than that supported by <code>pdtp.MODE</code>.</p>
</li>
<li>
<p>Transaction type is not supported by the IOMMU.</p>
</li>
</ol>
</div>
</li>
<li>
<p>If request is a Translated request and <code>DC.tc.T2GPA</code> is 0 then the translation
process is complete. Go to step 20.</p>
</li>
<li>
<p>If request is a Translated request and <code>DC.tc.T2GPA</code> is 1 then the IOVA is a
GPA. Go to step 17 with following page table information:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Let <code>A</code> be the <code>IOVA</code> (the <code>IOVA</code> is a GPA).</p>
</li>
<li>
<p>Let <code>iosatp.MODE</code> be <code>Bare</code></p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>The <code>PSCID</code> value is not used when first-stage is Bare.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Let <code>iohgatp</code> be the value in the <code>DC.iohgatp</code> field</p>
</li>
</ol>
</div>
</li>
<li>
<p>If <code>DC.tc.PDTV</code> is set to 0 then go to step 17 with the following page table
information:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Let <code>iosatp.MODE</code> be the value in the <code>DC.fsc.MODE</code> field</p>
</li>
<li>
<p>Let <code>iosatp.PPN</code> be the value in the <code>DC.fsc.PPN</code> field</p>
</li>
<li>
<p>Let <code>PSCID</code> be the value in the <code>DC.ta.PSCID</code> field</p>
</li>
<li>
<p>Let <code>iohgatp</code> be the value in the <code>DC.iohgatp</code> field</p>
</li>
</ol>
</div>
</li>
<li>
<p>If <code>DPE</code> is 1 and there is no <code>process_id</code> associated with the transaction
then let <code>process_id</code> be the default value of 0.</p>
</li>
<li>
<p>If <code>DPE</code> is 0 and there is no <code>process_id</code> associated with the transaction
then then go to step 17 with the following page table information:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Let <code>iosatp.MODE</code> be <code>Bare</code></p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>The <code>PSCID</code> value is not used when first-stage is Bare.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Let <code>iohgatp</code> be the value in the <code>DC.iohgatp</code> field</p>
</li>
</ol>
</div>
</li>
<li>
<p>If <code>DC.fsc.pdtp.MODE = Bare</code> then go to step 17 with the following page table
information:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Let <code>iosatp.MODE</code> be <code>Bare</code></p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>The <code>PSCID</code> value is not used when first-stage is Bare.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Let <code>iohgatp</code> be value in <code>DC.iohgatp</code> field</p>
</li>
</ol>
</div>
</li>
<li>
<p>Locate the process-context (<code>PC</code>) as specified in <a href="#GET_PC">Section 3.3.2</a>.</p>
</li>
<li>
<p>if any of the following conditions hold then stop and report
"Transaction type disallowed" (cause = 260).</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>The transaction requests supervisor privilege but <code>PC.ta.ENS</code> is not set.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Go to step 17 with the following page table information:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Let <code>iosatp.MODE</code> be the value in the <code>PC.fsc.MODE</code> field</p>
</li>
<li>
<p>Let <code>iosatp.PPN</code> be the value in the <code>PC.fsc.PPN</code> field</p>
</li>
<li>
<p>Let <code>PSCID</code> be the value in the <code>PC.ta.PSCID</code> field</p>
</li>
<li>
<p>Let <code>iohgatp</code> be the value in the <code>DC.iohgatp</code> field</p>
</li>
</ol>
</div>
</li>
<li>
<p>Use the process specified in Section "Two-Stage Address Translation" of the
RISC-V Privileged specification cite:[PRIV] to determine the GPA accessed by
the transaction. If a fault is detected by the first stage address translation
process then stop and report the fault. If the translation process is completed
successfully then let <code>A</code> be the translated GPA.</p>
</li>
<li>
<p>If MSI address translations using MSI page tables is enabled
(i.e., <code>DC.msiptp.MODE != Off</code>) then the MSI address translation process
specified in <a href="#MSI_TRANS">Section 3.3.3</a> is invoked. If the GPA <code>A</code> is not determined to be
the address of a virtual interrupt file then the process continues at step 19.
If a fault is detected by the MSI address translation process then stop and
report the fault else the process continues at step 20.</p>
</li>
<li>
<p>Use the second-stage address translation process specified in Section
"Two-Stage Address Translation" of the RISC-V Privileged specification
cite:[PRIV] to translate the GPA <code>A</code> to determine the SPA accessed by the
transaction. If a fault is detected by the address translation process then
stop and report the fault.</p>
</li>
<li>
<p>Translation process is complete</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>When checking the <code>U</code> bit in a second-stage PTE, the transaction is treated as
not requesting supervisor privilege. The <code>pte.xwr=010</code> encoding, as specified by
the Zicfiss cite:[CFI] extension for the Shadow Stack page type in single-stage
and VS-stage page tables, remains a reserved encoding for IO transactions.</p>
</div>
<div class="paragraph">
<p>When the translation process reports a fault, and the request is an Untranslated
request or a Translated request, the IOMMU requests the IO bridge to abort the
transaction. Guidelines for handling faulting transactions in the IO bridge are
provided in <a href="#IOBR_FAULT_RESP">Section 8.3</a>. The fault may be reported using the fault/event
reporting mechanism and fault record formats specified in <a href="#FAULT_QUEUE">Section 4.2</a>.</p>
</div>
<div class="paragraph">
<p>If the fault was detected by a PCIe ATS Translation Request then the IOMMU may
provide a PCIe protocol defined response instead of reporting fault to software
or causing an abort. The handling of faulting PCIe ATS Translation Requests is
specified in <a href="#ATS_FAULTS">Section 3.6</a>.</p>
</div>
<div class="sect3">
<h4 id="GET_DC"><a class="anchor" href="#GET_DC"></a>3.3.1. Process to locate the Device-context</h4>
<div class="paragraph">
<p>The process to locate the Device-context for transaction using its <code>device_id</code>
is as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Let <code>a</code> be <code>ddtp.PPN x 2<sup>12</sup></code> and let <code>i = LEVELS - 1</code>. When
<code>ddtp.iommu_mode</code> is <code>3LVL</code>, <code>LEVELS</code> is three. When <code>ddtp.iommu_mode</code> is
<code>2LVL</code>, <code>LEVELS</code> is two. When <code>ddtp.iommu_mode</code> is <code>1LVL</code>, <code>LEVELS</code> is one.</p>
</li>
<li>
<p>If <code>i == 0</code> go to step 8.</p>
</li>
<li>
<p>Let <code>ddte</code> be the value of the eight bytes at address <code>a + DDI[i] x 8</code>. If accessing
<code>ddte</code> violates a PMA or PMP check, then stop and report "DDT entry load
access fault" (cause = 257).</p>
</li>
<li>
<p>If <code>ddte</code> access detects a data corruption (a.k.a. poisoned data), then
stop and report "DDT data corruption" (cause = 268).</p>
</li>
<li>
<p>If <code>ddte.V == 0</code>, stop and report "DDT entry not valid" (cause = 258).</p>
</li>
<li>
<p>If any bits or encoding that are reserved for future standard use are
set within <code>ddte</code>, stop and report "DDT entry misconfigured"
(cause = 259).</p>
</li>
<li>
<p>Let <code>i = i - 1</code> and let <code>a = ddte.PPN x 2<sup>12</sup></code>. Go to step 2.</p>
</li>
<li>
<p>Let <code>DC</code> be the value of <code>DC_SIZE</code> bytes at address <code>a + DDI[0] * DC_SIZE</code>. If
<code>capabilities.MSI_FLAT</code> is 1 then <code>DC_SIZE</code> is 64-bytes else it is 32-bytes.
If accessing <code>DC</code> violates a PMA or PMP check, then stop and report
"DDT entry load access fault" (cause = 257). If <code>DC</code> access detects a data
corruption (a.k.a. poisoned data), then stop and report "DDT data corruption"
(cause = 268).</p>
</li>
<li>
<p>If <code>DC.tc.V == 0</code>, stop and report "DDT entry not valid" (cause = 258).</p>
</li>
<li>
<p>If the <code>DC</code> is misconfigured as determined by rules outlined in
<a href="#DC_MISCONFIG">Section 3.1.4</a> then stop and report "DDT entry misconfigured" (cause = 259).</p>
</li>
<li>
<p>The device-context has been successfully located.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="GET_PC"><a class="anchor" href="#GET_PC"></a>3.3.2. Process to locate the Process-context</h4>
<div class="paragraph">
<p>The device-context provides the PDT root page PPN (<code>pdtp.ppn</code>).  When
<code>DC.iohgatp.mode</code> is not <code>Bare</code>, <code>pdtp.PPN</code> as well as <code>pdte.PPN</code> are Guest
Physical Addresses (GPA) which must be translated into Supervisor Physical
Addresses (SPA) using the second-stage page table pointed to by <code>DC.iohgatp</code>.
The memory accesses to the PDT are treated as implicit read memory accesses
by the second-stage.</p>
</div>
<div class="paragraph">
<p>The process to locate the Process-context for a transaction using its
<code>process_id</code> is as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Let <code>a</code> be <code>pdtp.PPN x 2<sup>12</sup></code> and let <code>i = LEVELS - 1</code>. When
<code>pdtp.MODE</code> is <code>PD20</code>, <code>LEVELS</code> is three. When <code>pdtp.MODE</code> is
<code>PD17</code>, <code>LEVELS</code> is two. When <code>pdtp.MODE</code> is <code>PD8</code>, <code>LEVELS</code> is one.</p>
</li>
<li>
<p>If <code>DC.iohgatp.mode != Bare</code>, then <code>a</code> is a GPA. Invoke the process
to translate <code>a</code> to a SPA as an implicit memory access. If faults occur during
second-stage address translation of <code>a</code> then stop and report the fault detected
by the second-stage address translation process. The translated <code>a</code> is used in
subsequent steps.</p>
</li>
<li>
<p>If <code>i == 0</code> go to step 9.</p>
</li>
<li>
<p>Let <code>pdte</code> be the value of the eight bytes at address <code>a + PDI[i] x 8</code>. If
accessing <code>pdte</code> violates a PMA or PMP check, then stop and report
"PDT entry load access fault" (cause = 265).</p>
</li>
<li>
<p>If <code>pdte</code> access detects a data corruption (a.k.a. poisoned data), then
stop and report "PDT data corruption" (cause = 269).</p>
</li>
<li>
<p>If <code>pdte.V == 0</code>, stop and report "PDT entry not valid" (cause = 266).</p>
</li>
<li>
<p>If any bits or encoding that are reserved for future standard use are
set within <code>pdte</code>, stop and report "PDT entry misconfigured" (cause = 267).</p>
</li>
<li>
<p>Let <code>i = i - 1</code> and let <code>a = pdte.PPN x 2<sup>12</sup></code>. Go to step 2.</p>
</li>
<li>
<p>Let <code>PC</code> be the value of the 16-bytes at address <code>a + PDI[0] x 16</code>. If accessing <code>PC</code>
violates a PMA or PMP check, then stop and report "PDT entry load access
fault" (cause = 265). If <code>PC</code> access detects a data corruption
(a.k.a. poisoned data), then stop and report "PDT data corruption"
(cause = 269).</p>
</li>
<li>
<p>If <code>PC.ta.V == 0</code>, stop and report "PDT entry not valid" (cause = 266).</p>
</li>
<li>
<p>If the <code>PC</code> is misconfigured as determined by rules outlined in
<a href="#PC_MISCONFIG">Section 3.2.4</a> then stop and report "PDT entry misconfigured" (cause = 267).</p>
</li>
<li>
<p>The Process-context has been successfully located.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="MSI_TRANS"><a class="anchor" href="#MSI_TRANS"></a>3.3.3. Process to translate addresses of MSIs</h4>
<div class="paragraph">
<p>When an I/O device is configured directly by a guest operating system, MSIs
from the device are expected to be targeted to virtual IMSICs within the guest
OS&#8217;s virtual machine, using guest physical addresses that are inappropriate
and unsafe for the real machine. An IOMMU must recognize certain incoming
writes from such devices as MSIs and convert them as needed for the real
machine.</p>
</div>
<div class="paragraph">
<p>MSIs originating from a single device that require conversion are expected
to have been configured at the device by a single guest OS running within one
RISC-V virtual machine. Assuming the VM itself conforms to the RISC-V Advanced
Interrupt Architecture cite:[AIA], MSIs are sent to virtual harts within the VM by writing
to the memory-mapped registers of the interrupt files of virtual IMSICs. Each of
these virtual interrupt files occupies a separate 4-KiB page in the VM&#8217;s guest
physical address space, the same as real interrupt files do in a real machine&#8217;s
physical address space. A write to a guest physical address can thus be
recognized as an MSI to a virtual hart if the write is to a page occupied by
an interrupt file of a virtual IMSIC within the VM.</p>
</div>
<div class="paragraph">
<p>When MSI address translation is supported (<code>capabilities.MSI_FLAT</code>, <a href="#CAP">Section 6.3</a>),
the process to identify an incoming <code>IOVA</code> as the address of a virtual interrupt
file and translating the address using the MSI page table is as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Let <code>A</code> be the <code>GPA</code></p>
</li>
<li>
<p>Let <code>DC</code> be the device-context located using the <code>device_id</code> of the device
using the process outlined in <a href="#GET_DC">Section 3.3.1</a>.</p>
</li>
<li>
<p>Determine if the address <code>A</code> is an access to a virtual interrupt file as
specified in <a href="#MSI_ID">Section 3.1.3.6</a>.</p>
</li>
<li>
<p>If the address is not determined to be that of a virtual interrupt file then
stop this process and instead use the regular translation data structures to
do the address translation.</p>
</li>
<li>
<p>Extract an interrupt file number <code>I</code> from <code>A</code> as
<code>I = extract(A &gt;&gt; 12, DC.msi_addr_mask)</code>. The bit extract function
<code>extract(x, y)</code> discards all bits from <code>x</code> whose matching bits in the same
positions in the mask <code>y</code> are zeros, and packs the remaining bits from <code>x</code>
contiguously at the least-significant end of the result, keeping the same bit
order as <code>x</code> and filling any other bits at the most-significant end of the
result with zeros. For example, if the bits of <code>x</code> and <code>y</code> are:</p>
<div class="ulist">
<ul>
<li>
<p><code>x = a b c d e f g h</code></p>
</li>
<li>
<p><code>y = 1 0 1 0 0 1 1 0</code></p>
</li>
<li>
<p>then the value of <code>extract(x, y)</code> has bits <code>0 0 0 0 a c f g</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Let <code>m</code> be <code>(DC.msiptp.PPN x 2<sup>12</sup>)</code>.</p>
</li>
<li>
<p>Let <code>msipte</code> be the value of sixteen bytes at address <code>(m | (I x 16))</code>. If
accessing <code>msipte</code> violates a PMA or PMP check, then stop and report
"MSI PTE load access fault" (cause = 261).</p>
</li>
<li>
<p>If <code>msipte</code> access detects a data corruption (a.k.a. poisoned data), then
stop and report "MSI PT data corruption" (cause = 270).</p>
</li>
<li>
<p>If <code>msipte.V == 0</code>, then stop and report "MSI PTE not valid" (cause = 262).</p>
</li>
<li>
<p>If <code>msipte.C == 1</code>, then further processing to interpret the PTE is
implementation defined.</p>
</li>
<li>
<p>If <code>msipte.C == 0</code> then the process is outlined in subsequent steps.</p>
</li>
<li>
<p>If <code>msipte.M == 0</code> or <code>msipte.M == 2</code>, then stop and report
"MSI PTE misconfigured" (cause = 263).</p>
</li>
<li>
<p>If <code>msipte.M == 3</code> the PTE is in basic translate mode and the translation
process is as follows:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>If any bits or encoding that are reserved for future standard use are set
within <code>msipte</code>, stop and report "MSI PTE misconfigured" (cause = 263).</p>
</li>
<li>
<p>Compute the translated address as <code>msipte.PPN &lt;&lt; 12 | A[11:0]</code>.</p>
</li>
</ol>
</div>
</li>
<li>
<p>If <code>msipte.M == 1</code> the PTE is in MRIF mode and the translation process
is as follows:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>If <code>capabilities.MSI_MRIF == 0</code>, stop and report "MSI PTE misconfigured"
(cause = 263).</p>
</li>
<li>
<p>If any bits or encoding that are reserved for future standard use are
set within <code>msipte</code>, stop and report "MSI PTE misconfigured" (cause = 263).</p>
</li>
<li>
<p>The address of the destination MRIF is <code>msipte.MRIF_Address[55:9] * 512</code>.</p>
</li>
<li>
<p>The destination address of the notice MSI is <code>msipte.NPPN &lt;&lt; 12</code>.</p>
</li>
<li>
<p>Let <code>NID</code> be <code>(msipte.N10 &lt;&lt; 10) | msipte.N[9:0]</code>. The data value for notice
MSI is the 11-bit <code>NID</code> value zero-extended to 32-bits.</p>
</li>
</ol>
</div>
</li>
<li>
<p>The access permissions associated with the translation determined through this
process are equivalent to that of a regular RISC-V second-stage PTE with
<code>R</code>=<code>W</code>=<code>U</code>=1 and <code>X</code>=0. Similar to a second-stage PTE, when checking the <code>U</code>
bit, the transaction is treated as not requesting supervisor privilege.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>If the transaction is an Untranslated or Translated read-for-execute then stop
and report "Instruction access fault" (cause = 1).</p>
</li>
</ol>
</div>
</li>
<li>
<p>MSI address translation process is complete.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In MRIF mode, the Advanced Interrupt Architecture Specification defines the operation to
store the incoming MSIs into the destination MRIF and to generate the notice
MSI. These operations may be performed by the IOMMU itself or the IOMMU may
provide the destination MRIF address, the notice MSI address, and the notice MSI
data value to the I/O bridge in response to the translation request and the
operations may be performed by the I/O bridge.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="iommu-updating-of-pte-accessed-a-and-dirty-d-updates"><a class="anchor" href="#iommu-updating-of-pte-accessed-a-and-dirty-d-updates"></a>3.4. IOMMU updating of PTE accessed (A) and dirty (D) updates</h3>
<div class="paragraph">
<p>When <code>capabilities.AMO_HWAD</code> is 1, the IOMMU supports updating the A and D bits in
PTEs atomically. When updating of A and D bits in second-stage PTEs is enabled
(<code>DC.tc.GADE=1</code>) and/or updating of A and D bits in first-stage PTEs is enabled
(<code>DC.tc.SADE=1</code>) the following rules apply:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The A and/or D bit updates by the IOMMU must follow the rules specified by the
Privileged specification for validity, permission checking, and atomicity.</p>
</li>
<li>
<p>The PTE update must be globally visible before a memory access using the
translated address provided by the IOMMU becomes globally visible.
Specifically, when a translated address is provided to a device in an ATS
Translation completion, the PTE update must be globally visible before a
memory access from the device using the translated address becomes globally
visible.</p>
</li>
</ol>
</div>
<div style="page-break-after: always;"></div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The A and D bits are never cleared by the IOMMU. If the supervisor software does
not rely on accessed and/or dirty bits, e.g. if it does not swap memory pages to
secondary storage or if the pages are being used to map I/O space, it should
set them to 1 in the PTE to improve performance.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="faults-from-virtual-address-translation-process"><a class="anchor" href="#faults-from-virtual-address-translation-process"></a>3.5. Faults from virtual address translation process</h3>
<div class="paragraph">
<p>Faults detected during the two-stage address translation specified in the RISC-V
Privileged specification cite:[PRIV] cause the IOVA translation process to stop
and report the detected fault.</p>
</div>
</div>
<div class="sect2">
<h3 id="ATS_FAULTS"><a class="anchor" href="#ATS_FAULTS"></a>3.6. PCIe ATS translation request handling</h3>
<div class="paragraph">
<p>ATS cite:[PCI] translation requests that encounter a configuration error results
in a Completer Abort (CA) response to the requester. The following cause codes
belong to this category:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Instruction access fault (cause = 1)</p>
</li>
<li>
<p>Read access fault (cause = 5)</p>
</li>
<li>
<p>Write/AMO access fault (cause = 7)</p>
</li>
<li>
<p>MSI PTE load access fault (cause = 261)</p>
</li>
<li>
<p>MSI PTE misconfigured (cause = 263)</p>
</li>
<li>
<p>PDT entry load access fault (cause = 265)</p>
</li>
<li>
<p>PDT entry misconfigured (cause = 267)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If there is a permanent error or if ATS transactions are disabled then an
Unsupported Request (UR) response is generated. The following cause codes
belong to this category:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>All inbound transactions disallowed (cause = 256)</p>
</li>
<li>
<p>DDT entry load access fault (cause = 257)</p>
</li>
<li>
<p>DDT entry not valid (cause = 258)</p>
</li>
<li>
<p>DDT entry misconfigured (cause = 259)</p>
</li>
<li>
<p>Transaction type disallowed (cause = 260)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When translation could not be completed due to the following causes a Success
Response with R and W bits set to 0 is generated. No faults are logged in
the fault queue on these errors. The translated address returned with such
completions is <code>UNSPECIFIED</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Instruction page fault (cause = 12)</p>
</li>
<li>
<p>Read page fault (cause = 13)</p>
</li>
<li>
<p>Write/AMO page fault (cause = 15)</p>
</li>
<li>
<p>Instruction guest page fault (cause = 20)</p>
</li>
<li>
<p>Read guest-page fault (cause = 21)</p>
</li>
<li>
<p>Write/AMO guest-page fault (cause = 23)</p>
</li>
<li>
<p>PDT entry not valid (cause = 266)</p>
</li>
<li>
<p>MSI PTE not valid (cause = 262)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the translation request has a PASID with "Privilege Mode Requested" field set
to 0, or the request does not have a PASID then the request does not target
privileged memory. If the U-bit that indicates if the memory is accessible to
user mode is 0 then a Success response with R and W bits set to 0 is generated.</p>
</div>
<div class="paragraph">
<p>If the translation request has a PASID with "Privilege Mode Requested" field set
to 1, then the request targets privileged memory. If the U-bit that indicates if
the page is accessible to user mode is 1 and the <code>SUM</code> bit in the <code>ta</code> field of the
process-context is 0 then a Success response with R and W bits set to 0 is
generated.</p>
</div>
<div class="paragraph">
<p>If the translation could be successfully completed but the requested
permissions are not present in either stage (Execute requested but no execute permission;
no-write not requested and no write permission; no read permission)
then a Success response is returned with the denied permission (R, W or X)
set to 0 and the other permission bits set to the value determined from the
page tables. The X permission is granted only if the R permission is also
granted and the execute permission was requested. Execute-only translations are
not compatible with PCIe ATS as PCIe requires read permission to be granted
if the execute permission is granted.</p>
</div>
<div class="paragraph">
<p>When a Success response is generated for an ATS translation request, no fault
records are reported to software through the fault/event reporting mechanism,
even when the response indicates no access was granted or some permissions were
denied. Conversely, when a UR or CA response is generated for an ATS translation
request, the corresponding fault is reported to software through the fault/event
reporting mechanism.</p>
</div>
<div class="paragraph">
<p>If the translation request has an address determined to be an MSI address using
the rules defined by the <a href="#MSI_ID">Section 3.1.3.6</a> but the MSI PTE is configured in MRIF
mode then a Success response is generated with R, W, and U bit set to 1. The U
bit being set to 1 in the response instructs the device that it must only use
Untranslated requests to access the implied 4 KiB memory range.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When a MSI PTE is configured in MRIF mode, a MSI write with data value <code>D</code>
requires the IOMMU to set the interrupt-pending bit for interrupt identity <code>D</code>
in the MRIF. A translation request from a device to a GPA that is mapped
through a MRIF mode MSI PTE is not eligible to receive a translated address.
This is accomplished by setting "Untranslated Access Only" (U) field of the
returned response to 1.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The translation range size returned in a Success response to an ATS translation
request, when either stages of address translation are Bare, is
implementation-defined. However, it is recommended that the translation range
size be large, such as 2 MiB or 1 GiB.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When a Success response is generated for an ATS translation request, the setting
of the Priv, N, CXL.io, Global, and AMA fields is as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Priv field of the ATS translation completion is always set to 0 if the request
does not have a PASID. When a PASID is present then the Priv field is set to
the value in "Privilege Mode Requested" field as the permissions provided
correspond to those the privilege mode indicate in the request.</p>
</li>
<li>
<p>N field of the ATS translation completion is always set to 0. The device may
use other means to determine if the No-snoop flag should be set in the
translated requests.</p>
</li>
<li>
<p>Global field is set to the value determined from the first-stage page tables
if translation could be successfully completed and the request had a PASID
present. In all other cases, including MSI address translations, this field
is set to 0.</p>
</li>
<li>
<p>If requesting device is not a CXL device then CXL.io is set to 0.</p>
</li>
<li>
<p>If requesting device is a CXL type 1 or type 2 device</p>
<div class="ulist">
<ul>
<li>
<p>If the address is determined to be a MSI then the CXL.io bit is set to 1.</p>
</li>
<li>
<p>Else if <code>T2GPA</code> is 1 in the device context then the CXL.io bit is set to 1.</p>
</li>
<li>
<p>Else if the memory type, as determined by the Svpbmt extension, is NC or IO
then the CXL.io bit is set to 1. If the memory type is PMA then the
determination of the setting of this bit is <code>UNSPECIFIED</code>. If the Svpbmt
extension is not supported then the setting of this bit is <code>UNSPECIFIED</code>.</p>
</li>
<li>
<p>In all other cases the setting of this bit is <code>UNSPECIFIED</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>The AMA field is by default set to 000b. The IOMMU may support an
implementation-specific method to provide other encodings.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The IO bridge may override the CXL.io bit in the ATS translation completion
based on the PMA of the translated address. Other implementations may provide
an implementation-defined method for determining PMA for the translated address
to set the CXL.io bit.</p>
</div>
<div class="paragraph">
<p>Use of <code>T2GPA</code> set to 1 may not be compatible with CXL type 1 or type 2 devices
as they use the CXL.cache protocol to implement caches tagged by the translated
address returned in response to a PCIe ATS Translation Request. The IOMMU may
not be invoked for translating addresses in CXL.cache transactions.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="ATS_PRI"><a class="anchor" href="#ATS_PRI"></a>3.7. PCIe ATS Page Request handling</h3>
<div class="paragraph">
<p>To process a "Page Request" or "Stop Marker" message cite:[PCI], the IOMMU first locates
the device-context to determine if ATS and PRI are enabled for the requester.
If ATS and PRI are enabled, i.e. <code>EN_ATS</code> and <code>EN_PRI</code> are both set to 1, the
 IOMMU queues the message into an in-memory queue called the
page-request-queue (<code>PQ</code>) (See <a href="#PRQ">Section 4.3</a>). Following suitable processing of the
"Page Request", a software handler may generate a "Page Request Group Response"
message to the device.</p>
</div>
<div class="paragraph">
<p>When PRI is enabled for a device, the IOMMU may still be unable to report
"Page Request" or "Stop Marker" messages through the <code>PQ</code> due to error
conditions such as the queue being disabled, queue being full, or the IOMMU
encountering access faults when attempting to access queue memory. These error
conditions are specified in <a href="#PRQ">Section 4.3</a>.</p>
</div>
<div class="paragraph">
<p>If the <code>ddtp.iommu_mode</code> is <code>Bare</code> or is <code>Off</code>, then the IOMMU cannot locate a
device-context for the requester.</p>
</div>
<div class="paragraph">
<p>If <code>EN_PRI</code> is set to 0, or <code>EN_ATS</code> is set to 0, or if the IOMMU is unable
to locate the <code>DC</code> to determine the <code>EN_PRI</code> configuration, or the request
could not be queued into <code>PQ</code> then the IOMMU behavior depends on the type
of "Page Request".</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the "Page Request" does not require a response, i.e. the "Last Request in
PRG" field of the message is set to 0, then such messages are silently
discarded. "Stop Marker" messages do not require a response and are always
silently discarded on such errors.</p>
</li>
<li>
<p>If the "Page Request" needs a response, then the IOMMU itself may generate
a "Page Request Group Response" message to the device.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When the IOMMU generates the response, the status field of the response depends
on the cause of the error. If a fault condition prevents locating a valid device
context then the <code>PRPR</code> value assumed is 0.</p>
</div>
<div style="page-break-after: always;"></div>
<div class="paragraph">
<p>The status is set to Response Failure if the following faults are encountered:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ddtp.iommu_mode</code> is <code>Off</code> (cause = 256)</p>
</li>
<li>
<p>DDT entry load access fault (cause = 257)</p>
</li>
<li>
<p>DDT entry misconfigured (cause = 259)</p>
</li>
<li>
<p>DDT entry not valid (cause = 258)</p>
</li>
<li>
<p>Page-request queue is not enabled (<code>pqcsr.pqen == 0</code> or <code>pqcsr.pqon == 0</code>)</p>
</li>
<li>
<p>Page-request queue encountered a memory access fault (<code>pqcsr.pqmf == 1</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The status is set to Invalid Request if the following faults are encountered:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ddtp.iommu_mode</code> is <code>Bare</code> (cause = 260)</p>
</li>
<li>
<p><code>EN_PRI</code> is set to 0 (cause = 260)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The status is set to Success if no other faults were encountered but the
"Page Request" could not be queued due to the page-request queue being full
(<code>pqt == pqh - 1</code>) or had a overflow (<code>pqcsr.pqof == 1</code>).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When SR-IOV VF is used as a unit of allocation, a hypervisor may disable page
requests from one of the virtual functions by setting <code>EN_PRI</code> to 0. However the
page-request interface is shared by the PF and all VFs.  The IOMMU protocol
specific logic classifies this condition (cause = 260) as a non-catastrophic
failure, an Invalid Request, in its response to avoid the shared PRI in the
device being disabled for all PFs/VFs.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A "Stop Marker" is encoded as a "Page Request" with a PASID but with the L, W,
and R fields set to 1, 0, and 0 respectively.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For IOMMU-generated "Page Request Group Response" messages that have status
Invalid Request or Success, the PRG-response-PASID-required (<code>PRPR</code>) bit when
set to 1 indicates that the IOMMU response message should include a PASID if the
associated "Page Request" had a PASID.</p>
</div>
<div class="paragraph">
<p>For IOMMU-generated "Page Request Group Response" with response code set to
Response Failure, if the "Page Request" had a PASID then response is generated
with a PASID.</p>
</div>
<div class="paragraph">
<p>No faults are logged in the fault queue for PCIe ATS "Page Request" messages for
the following conditions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Page-request queue is not enabled (<code>pqcsr.pqen == 0</code> or <code>pqcsr.pqon == 0</code>)</p>
</li>
<li>
<p>Page-request queue encountered a memory access fault (<code>pqcsr.pqmf == 1</code>)</p>
</li>
<li>
<p>"Page Request" could not be queued due to the page-request queue being full
(<code>pqt == pqh - 1</code>) or had a overflow (<code>pqcsr.pqof == 1</code>).</p>
</li>
</ul>
</div>
<div style="page-break-after: always;"></div>
</div>
<div class="sect2">
<h3 id="CACHING"><a class="anchor" href="#CACHING"></a>3.8. Caching in-memory data structures</h3>
<div class="paragraph">
<p>To speed up Direct Memory Access (DMA) translations, the IOMMU may make use of
translation caches to hold entries from device-directory-table,
process-directory-table, first-stage and second-stage translation tables, and
MSI page tables. These caches are collectively referred to as the IOMMU Address
Translation Caches (IOATC).</p>
</div>
<div class="paragraph">
<p>This specification does not allow the caching of first/second-stage PTEs whose
<code>V</code> (valid) bit is clear, non-leaf DDT entries whose <code>V</code> (valid) bit is clear,
Device-context whose <code>V</code> (valid) bit is clear, non-leaf PDT entries whose <code>V</code>
(valid) bit is clear, Process-context whose <code>V</code> (valid) bit is clear, or MSI
PTEs whose <code>V</code> bit is clear.</p>
</div>
<div class="paragraph">
<p>These IOATC do not observe modifications to the in-memory data structures using
explicit loads and stores by RISC-V harts or by device DMA. Software must use
the IOMMU commands to invalidate the cached data structure entries using IOMMU
commands to synchronize the IOMMU operations to observe updates to in-memory
data structures. A simpler implementation may not implement IOATC for some or
any of the in-memory data structures. The IOMMU commands may use one or
more IDs to tag the cached entries to identify a specific entry or a
group of entries.</p>
</div>
<table class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 6. Identifiers used to tag IOATC entries</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Data Structure cached</th>
<th class="tableblock halign-center valign-top">IDs used to tag entries</th>
<th class="tableblock halign-center valign-top">Invalidation command</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Device Directory Table</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>device_id</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#IDDT">IODIR.INVAL_DDT</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Process Directory Table</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>device_id</code>, <code>process_id</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#IPDT">IODIR.INVAL_PDT</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">First-stage page table
 (when second-stage is
  not Bare)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GSCID</code>, <code>PSCID</code>, and IOVA</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#IVMA">IOTINVAL.VMA</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">First-stage page table
 (when second-stage is
  Bare)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PSCID</code>, and IOVA</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#IVMA">IOTINVAL.VMA</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Second-stage page table</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GSCID</code>, <code>GPA</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#IGVMA">IOTINVAL.GVMA</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MSI page table</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GSCID</code>, <code>GPA</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#IGVMA">IOTINVAL.GVMA</a></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="updating-in-memory-data-structure-entries"><a class="anchor" href="#updating-in-memory-data-structure-entries"></a>3.9. Updating in-memory data structure entries</h3>
<div class="paragraph">
<p>The RISC-V memory model requires memory access from a hart to be single-copy
atomic. When RV32 is implemented the size of a single-copy atomic memory access
is up to 32-bits. When RV64 is implemented the size of a single-copy atomic
memory access is up to 64-bits. The size of a single-copy atomic memory access
implemented by the IOMMU is <code>UNSPECIFIED</code> but is required to be at least 32-bits
if all of the harts in the system implement RV32 and is required to be at least
64-bits if any of the harts in the system implement RV64.</p>
</div>
<div class="paragraph">
<p>The IOMMU data structure entries have a <code>V</code> bit that when set to 1 indicates
that the entry is valid.</p>
</div>
<div class="paragraph">
<p>Software is allowed to make updates to a data structure entry that has the <code>V</code>
bit set to 1. However, some rules as outlined below must be followed.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is generally unsafe for software to update fields of a valid data structure
entry using a set of stores of width less than the minimal single-copy atomic
memory access supported by an IOMMU as it is legal for an IOMMU to read the
entry at any time, including when only some of the partial stores have taken
effect.<br></p>
</li>
<li>
<p>For an update to an IOMMU data structure entry to be atomic, software must use
a single store of width equal to the minimal single-copy atomic memory access
supported by an IOMMU.<br></p>
</li>
<li>
<p>If the update to a field will make the field inconsistent with another field
of the entry then software must first set the <code>V</code> field to 0 and use the commands
outlined in <a href="#CACHING">Section 3.8</a> to invalidate any previous copies of that entry that
may be in IOMMU caches before updating other fields of that entry.<br></p>
</li>
<li>
<p>The IOMMU is not required to immediately observe the software update to an
entry. Software must use the commands outlined in <a href="#CACHING">Section 3.8</a> to invalidate
any previous copies of that entry that may be in IOMMU caches to synchronize
the updates to the entry with the operation of the IOMMU.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If a data structure entry is changed, the IOMMU may use the old value of the
entry or the new value of the entry and the choice is unpredictable until
software uses the commands outlined in <a href="#CACHING">Section 3.8</a> to invalidate any previous
copies of that entry that may be in IOMMU caches to synchronize updates to the
entry with the operation of the IOMMU. These are the only behaviors expected.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="endianness-of-in-memory-data-structures"><a class="anchor" href="#endianness-of-in-memory-data-structures"></a>3.10. Endianness of in-memory data structures</h3>
<div class="paragraph">
<p>The RISC-V memory model specifies byte-invariance for the entire address space.
When mixed-endian mode of operation is supported, the IO bridge and the IOMMU
must implement byte-invariant addressing such that a byte access to a given
address accesses the same memory location in both little-endian and big-endian
mode of operation.</p>
</div>
<div class="paragraph">
<p>The endianness of implicit memory access to in-memory data structures is
determined by <code>fctl.BE</code> or by <code>DC.tc.SBE</code> as follows:</p>
</div>
<table id="ENDIAN_CONFIG" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 7. Endianness of memory access to data structures</caption>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Data Structure</th>
<th class="tableblock halign-center valign-top">Controlled by</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Device directory table</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fctl.BE</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Second-stage page table</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fctl.BE</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MSI page table</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fctl.BE</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Process directory Table</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DC.tc.SBE</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">First-stage page table</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DC.tc.SBE</code></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>PSCID</code> field of first-stage context, along with the <code>GSCID</code> (when two-stage
address translation is active), identifies an address space. Configuring an
identical <code>GSCID</code> and <code>PSCID</code> in two DC but with different <code>SBE</code> is not expected
and if done may lead to the IOMMU interpreting a first-stage PTE as big-endian
or little-endian. These are the only behaviors expected.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Software must use an appropriate software sequence to swap bytes as necessary to
create a mutually agreed to data representation when sharing data with an IO
agent that does not share its endianness. Software must use an LR/SC sequence to
perform atomic operations in non-native endian format when the data shared with
such IO agents must be accessed atomically.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="in-memory-queue-interface"><a class="anchor" href="#in-memory-queue-interface"></a>4. In-memory queue interface</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Software and IOMMU interact using 3 in-memory queue data structures.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A command-queue (<code>CQ</code>) used by software to queue commands to the IOMMU.</p>
</li>
<li>
<p>A fault/event queue (<code>FQ</code>) used by IOMMU to bring faults and events to
software&#8217;s attention.</p>
</li>
<li>
<p>A page-request queue (<code>PQ</code>) used by IOMMU to report “Page Request” messages
received from PCIe devices. This queue is supported if the IOMMU supports
PCIe cite:[PCI] defined Page Request Interface.</p>
</li>
</ul>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/ditaa/svg/eNpTUEAAbV1dXRjGC-CKtLkgusDArkZPT6FGAYQhwDk_NzcxL0UhsDS1NBXJHqgikGouBbhqcu2vQTI4ToFIEMelDTRBG8lFRIIarhrnQKcacjSCXU2mjR6IMNEm10YFkmwMIRgLWOIFxUZqJye3xNKcEszENNSTkxvdk5Mb3ZOT2yBMTgGJ6akKQamFpanFqKlqaCenALonpwC6J6cASpITAMKLIBY=?shadows=false&separation=false&font=courier" alt="IOMMU in-memory queues">
</div>
<div class="title">Figure 28. IOMMU in-memory queues</div>
</div>
<div class="paragraph">
<p>Each queue is a circular buffer with a head controlled by the consumer of data
from the queue and a tail controlled by the producer of data into the queue.
IOMMU is the producer of records into <code>PQ</code> and <code>FQ</code> and controls the tail register.
IOMMU is the consumer of commands produced by software into the CQ and controls
the head register. The tail register holds the index into the queue where the
next entry will be written by the producer. The head register holds the index
into the queue where the consumer will read the next entry to process.</p>
</div>
<div class="paragraph">
<p>A queue is empty if the head is equal to the tail. A queue is full if the tail
is the head minus one. The head and tail wrap around when they reach the end of
the circular buffer.</p>
</div>
<div class="paragraph">
<p>The producer of data must ensure that the data written to a queue and the
tail update are ordered such that the consumer that observes an update to the
tail register must also observe all data produced into the queue between the
offsets determined by the head and the tail.</p>
</div>
<div style="page-break-after: always;"></div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>All RISC-V IOMMU implementations are required to support in-memory queues
located in main memory. Supporting in-memory queues in I/O memory is not required
but is not prohibited by this specification.</p>
</div>
<div class="paragraph">
<p>The implication of the queue being considered full when tail is head minus one
is that the effective size of the queue is one less than the number of entries
in the queue.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="command-queue-cq"><a class="anchor" href="#command-queue-cq"></a>4.1. Command-Queue (CQ)</h3>
<div class="paragraph">
<p>Command queue is used by software to queue commands to be processed by the
IOMMU. Each command is 16 bytes.</p>
</div>
<div class="paragraph">
<p>The PPN of the base of this in-memory queue and the size of the queue is
configured into a memory-mapped register called command-queue base (<code>cqb</code>).</p>
</div>
<div class="paragraph">
<p>The tail of the command-queue resides in a software-controlled read/write
memory-mapped register called command-queue tail (<code>cqt</code>). The <code>cqt</code> is an
index into the next command queue entry that software will write. Subsequent
to writing the command(s), software advances the <code>cqt</code> by the count of the
number of commands written.</p>
</div>
<div class="paragraph">
<p>The head of the command-queue resides in a read-only memory-mapped IOMMU
controlled register called command-queue head (<code>cqh</code>). The <code>cqh</code> is an index
into the command queue that IOMMU should process next. Subsequent to reading
each command the IOMMU may advance the <code>cqh</code> by 1. If <code>cqh</code> == <code>cqt</code>, the
command-queue is empty. If <code>cqt</code> == (<code>cqh</code> - 1) the command-queue is full.</p>
</div>
<div class="paragraph">
<p>When an error bit or the <code>fence_w_ip</code> bit  in <code>cqcsr</code> is 1, the command-queue
interrupt pending (<code>cip</code>) bit is set in the <code>ipsr</code> if interrupts from
command-queue are enabled (i.e. <code>cqcsr.cie</code> is 1).</p>
</div>
<div class="paragraph">
<p>IOMMU commands are grouped into a major command group determined by the <code>opcode</code>
and within each group the <code>func3</code> field specifies the function invoked by that
command. The <code>opcode</code> defines the format of the operand fields. One or more of
those fields may be used by the specific function invoked. The <code>opcode</code>
encodings 64 to 127 are designated for custom use.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNpVyzESgjAQRuHeU_wdzRYEHHH2Ko5FCBvMjG4Ygo2Z3B1sROrvvTzLyLidgNyHJTE6gtqXMKo4uThIVWjH9of-ra49mDHXv1Vmq0P6BneCi-rDyPlpVbayITzSZJ2wqZszwUddUvhso7mUsgK1Yy0M" alt="Format of an IOMMU command">
</div>
<div class="title">Figure 29. Format of an IOMMU command</div>
</div>
<div class="paragraph">
<p>The commands are interpreted as two 64-bit doublewords. The byte order of each
of the doublewords in memory, little-endian or big-endian, is the endianness as
determined by <code>fctl.BE</code> (<a href="#FCTRL">Section 6.4</a>).</p>
</div>
<div class="paragraph">
<p>The following command opcodes are defined:</p>
</div>
<table class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 8. IOMMU command opcodes</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><code>opcode</code></th>
<th class="tableblock halign-center valign-top">Encoding</th>
<th class="tableblock halign-center valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IOTINVAL</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IOMMU page-table cache invalidation commands.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IOFENCE</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IOMMU command-queue fence commands.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IODIR</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IOMMU directory cache invalidation commands.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ATS</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IOMMU PCIe cite:[PCI] ATS commands.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">5-63</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for future standard use.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Custom</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">64-127</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Designated for custom use.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>All undefined functions of command opcodes 0 through 63 are reserved for
future standard use.</p>
</div>
<div class="paragraph">
<p>A command is determined to be illegal if it uses a reserved encoding or if a
reserved bit is set to 1. A command is unsupported if it is defined but not
implemented as determined by the IOMMU <code>capabilities</code> register. If an illegal or
unsupported command is fetched and decoded by the command-queue then the
command-queue sets the <code>cqcsr.cmd_ill</code> bit and stops processing commands from
the command-queue. To re-enable command processing software should clear the
<code>cmd_ill</code> bit by writing 1 to it.</p>
</div>
<div class="sect3">
<h4 id="iommu-page-table-cache-invalidation-commands"><a class="anchor" href="#iommu-page-table-cache-invalidation-commands"></a>4.1.1. IOMMU Page-Table cache invalidation commands</h4>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNp9kF0LgjAUhu_7FbtbgcE2-6DdSUIIZpHhjXhhNkuoGboiEv97A2Mmtu7Oex6el8OpCnaiIBwAUB0yUVIwNwCPr4wCmN-S_MigAWIhCpmdzd7xAssdoicewdpoHVM56Z0nplQ-TgiDtTVGTyRXcNXMGEbfLlauFcDfoCgfxw4iSLGtv3RsjSeZrnKlA57bAQv9EXjWtvWOmOi9f5UK-Z39lLRPsu1dODMpJlH3Jb3WyABJztPsRKtLzFlz1Lm8xQmjGBEZ0pyLMnvJSOr6DTx4lR4=" alt="Diagram">
</div>
</div>
<div class="paragraph">
<p>IOMMU operations cause implicit reads to PDT, first-stage and second-stage page
tables. To reduce latency of such reads, the IOMMU may cache entries from the
first-stage and/or second-stage page tables in the
IOMMU-address-translation-cache (IOATC). These caches might not observe
modifications performed by software to these data structures in memory.</p>
</div>
<div class="paragraph">
<p>The IOMMU translation-table cache invalidation commands, <code>IOTINVAL.VMA</code> and
<code>IOTINVAL.GVMA</code> synchronize updates to in-memory first-stage and second-stage
page table data structures respectively with the operation of the IOMMU and
invalidate the matching IOATC entries.</p>
</div>
<div class="paragraph">
<p>The <code>GV</code> operand indicates if the Guest-Soft-Context ID (<code>GSCID</code>) operand is
valid. The <code>PSCV</code> operand indicates if the Process Soft-Context ID (<code>PSCID</code>)
operand is valid. Setting <code>PSCV</code> to 1 is allowed only for <code>IOTINVAL.VMA</code>. The
<code>AV</code> operand indicates if the address (<code>ADDR</code>) operand is valid. When <code>GV</code> is 0,
the translations associated with the host (i.e. those where the second-stage
is Bare) are operated on. When <code>GV</code> is 0, the <code>GSCID</code> operand is ignored.
When <code>AV</code> is 0, the <code>ADDR</code> operand is ignored. When <code>PSCV</code> operand is 0, the
<code>PSCID</code> operand is ignored. When the <code>AV</code> operand is set to 1, if the <code>ADDR</code>
operand specifies an invalid address, the command may or may not perform any
invalidations.</p>
</div>
<div class="paragraph">
<p>The definition of the <code>NL</code> bit is provided by the non-leaf PTE invalidation
extension <a href="#NLINV">Section 9.2</a>. The definition of the <code>S</code> bit is provided by the address
range invalidation extension <a href="#ARINV">Section 9.3</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When an invalid address is specified, an implementation may either complete the
command with no effect or may complete the command using an alternate, yet
<code>UNSPECIFIED</code>, legal value for the address. Note that entries may generally be
invalidated from the address translation cache at any time.</p>
</div>
</td>
</tr>
</table>
</div>
<div style="page-break-after: always;"></div>
<div class="paragraph">
<p><code>IOTINVAL.VMA</code> ensures that previous stores made to the first-stage page
tables by the harts are observed by the IOMMU before all subsequent implicit
reads from IOMMU to the corresponding first-stage page tables.</p>
</div>
<table id="IVMA" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 9. <code>IOTINVAL.VMA</code> operands and operations</caption>
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top"><code>GV</code></th>
<th class="tableblock halign-center valign-top"><code>AV</code></th>
<th class="tableblock halign-center valign-top"><code>PSCV</code></th>
<th class="tableblock halign-left valign-top">Operation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Invalidates all address-translation cache entries, including
                   those that contain global mappings, for all host address
                   spaces.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Invalidates all address-translation cache entries for the
                   host address space identified by <code>PSCID</code> operand, except for
                   entries containing global mappings.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Invalidates all address-translation cache entries that
                   contain first-stage leaf page table entries, including those
                   that contain global mappings, corresponding to the IOVA in
                   <code>ADDR</code> operand, for all host address spaces.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Invalidates all address-translation cache entries that
                   contain first-stage leaf page table entries corresponding to
                   the IOVA in <code>ADDR</code> operand and that match the host address
                   space identified by <code>PSCID</code> operand, except for entries
                   containing global mappings.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Invalidates all address-translation cache entries, including
                   those that contain global mappings, for all VM address spaces
                   associated with <code>GSCID</code> operand.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Invalidates all address-translation cache entries
                   for the VM address space identified by <code>PSCID</code> and <code>GSCID</code>
                   operands, except for entries containing global mappings.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Invalidates all address-translation cache entries that
                   contain first-stage leaf page table entries, including those
                   that contain global mappings, corresponding to the IOVA in
                   <code>ADDR</code> operand, for all VM address spaces associated with the
                   <code>GSCID</code> operand.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Invalidates all address-translation cache entries that
                   contain first-stage leaf page table entries corresponding to
                   the IOVA in <code>ADDR</code> operand, for the VM address space
                   identified by <code>PSCID</code> and <code>GSCID</code> operands, except for
                   entries containing global mappings.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><code>IOTINVAL.GVMA</code> ensures that previous stores made to the second-stage page
tables are observed before all subsequent implicit reads from IOMMU to the
corresponding second-stage page tables. Setting <code>PSCV</code> to 1 with <code>IOTINVAL.GVMA</code>
is illegal.</p>
</div>
<table id="IGVMA" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 10. <code>IOTINVAL.GVMA</code> operands and operations</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top"><code>GV</code></th>
<th class="tableblock halign-center valign-top"><code>AV</code></th>
<th class="tableblock halign-left valign-top">Operation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">ignored</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Invalidates information cached from any level of the
                  second-stage page table, for all VM address spaces.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Invalidates information cached from any level of the
                  second-stage page tables, but only for VM address spaces
                  identified by the <code>GSCID</code> operand.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Invalidates information cached from leaf second-stage page
                  table entries corresponding to the guest-physical-address in
                  <code>ADDR</code> operand, but only for VM address spaces identified
                  by the <code>GSCID</code> operand.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Conceptually, an implementation might contain two address-translation caches:
one that maps guest virtual addresses to guest physical addresses, and another
that maps guest physical addresses to supervisor physical addresses.
<code>IOTINVAL.GVMA</code> need not invalidate the former cache, but it must invalidate
entries from the latter cache that match the <code>IOTINVAL.GVMA</code> address and
<code>GSCID</code> operands.</p>
</div>
</td>
</tr>
</table>
</div>
<div style="page-break-after: always;"></div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>More commonly, implementations contain address-translation caches that map
guest virtual addresses directly to supervisor physical addresses, removing a
level of indirection. For such implementations, any entry whose guest virtual
address maps to a guest physical address that matches the <code>IOTINVAL.GVMA</code>
address and <code>GSCID</code> arguments must be invalidated. Selectively invalidating
entries in this fashion requires tagging them with the guest physical address,
which is costly, and so a common technique is to invalidate all entries that
match the <code>GSCID</code> argument, regardless of the address argument.</p>
</div>
<div class="paragraph">
<p>Simpler implementations may ignore the operand of <code>IOTINVAL.VMA</code> and/or
<code>IOTINVAL.GVMA</code> and perform a global invalidation of all
address-translation entries.</p>
</div>
<div class="paragraph">
<p>Some implementations may cache an identity-mapped translation for the stage of
address translation operating in <code>Bare</code> mode. Since these identity mappings
are invariably correct, an explicit invalidation is unnecessary.</p>
</div>
<div class="paragraph">
<p>A consequence of this specification is that an implementation may use any
translation for an address that was valid at any time since the most recent
<code>IOTINVAL</code> that subsumes that address. In particular, if a leaf PTE is
modified but a subsuming <code>IOTINVAL</code> is not executed, either the old translation
or the new translation will be used, but the choice is unpredictable. The
behavior is otherwise well-defined.</p>
</div>
<div class="paragraph">
<p>In a conventional TLB design, it is possible for multiple entries to match a
single address if, for example, a page is upgraded to a larger page without
first clearing the original non-leaf PTE’s valid bit and executing an
<code>IOTINVAL.VMA</code> or <code>IOTINVAL.GVMA</code> as applicable with <code>AV=0</code>. In this case, a
similar remark applies: it is unpredictable whether the old non-leaf PTE or
the new leaf PTE is used, but the behavior is otherwise well defined.</p>
</div>
<div class="paragraph">
<p>Another consequence of this specification is that it is generally unsafe to
update a PTE using a set of stores of a width less than the width of the PTE,
as it is legal for the implementation to read the PTE at any time, including
when only some of the partial stores have taken effect.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="iommu-command-queue-fence-commands"><a class="anchor" href="#iommu-command-queue-fence-commands"></a>4.1.2. IOMMU Command-queue Fence commands</h4>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNp1jkELgjAYhu_9iu9mwYI5w2I3UQMvFRZ5EA9Lpwk1xVlI4n9vl5QRHl-e5_n4-oYXFOIFQH8rW0lhi0CwJ6dgVHVaZdxAwNq2UTs47v2D6y9xR1bGgKbEGpP8JVJLFb_EXeMOa645us51BkTnYIacwjkQ6WA3kka-M_1ZMjLPuTgasyfmeF4Y2xYliWaQv8MJgrQSeVnQ_sEEV84GwV3WLOXUxESNvBKtLD9qkmH4AgOKaYY=" alt="Diagram">
</div>
</div>
<div class="paragraph">
<p>The IOMMU fetches commands from the CQ in order but the IOMMU may execute the
fetched commands out of order. The IOMMU advancing <code>cqh</code> is not a guarantee
that the commands fetched by the IOMMU have been executed or committed.</p>
</div>
<div class="paragraph">
<p>A <code>IOFENCE.C</code> command completion, as determined by <code>cqh</code> advancing past the
index of the <code>IOFENCE.C</code> command in the CQ, guarantees that all previous
commands fetched from the CQ have been completed and committed.</p>
</div>
<div class="paragraph">
<p>If the <code>IOFENCE.C</code> times out waiting on completion of previous commands that are
specified to have a timeout, then the <code>cmd_to</code> bit in <code>cqcsr</code> <a href="#CSR">Section 6.15</a> is set to
signal this condition. The <code>cqh</code> holds the index of the <code>IOFENCE.C</code> that timed
out and all previous commands that are not specified to have a timeout have been
completed and committed.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In this version of the specification, only the <code>ATS.INVAL</code> command is specified
to have a timeout.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The commands may be used to order memory accesses from I/O devices connected to
the IOMMU as viewed by the IOMMU, other RISC-V harts, and external devices or
co-processors.</p>
</div>
<div class="paragraph">
<p>The <code>PR</code> bit, when set to 1, can be used to request that the IOMMU ensure
that all previous read requests from devices that have already been processed
by the IOMMU be committed to a global ordering point such that they can be
observed by all RISC-V harts and IOMMUs in the system.</p>
</div>
<div class="paragraph">
<p>The <code>PW</code> bit, when set to 1, can be used to request that the IOMMU ensure
that all previous write requests from devices that have already been processed
by the IOMMU be committed to a global ordering point such that they can be
observed by all RISC-V harts and IOMMUs in the system.</p>
</div>
<div class="paragraph">
<p>The wire-signaled-interrupts (<code>WSI</code>) bit when set to 1 causes a wired-interrupt
from the command queue to be generated (by setting <code>cqcsr.fence_w_ip</code> - <a href="#CSR">Section 6.15</a>)
on completion of <code>IOFENCE.C</code>. This bit is reserved if the IOMMU does not support
wired-interrupts or wired-interrupts have not been enabled
(i.e., <code>fctl.WSI == 0</code>).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Software should ensure that all previous read and writes processed by the IOMMU
have been committed to a global ordering point before reclaiming memory that was
previously made accessible to a device. A safe sequence for such memory
reclamation is to first update the page tables to disallow access to the memory
from the device and then use the <code>IOTINVAL.VMA</code> or <code>IOTINVAL.GVMA</code> appropriately
to synchronize the IOMMU with the update to the page table. As part of the
synchronization if the memory reclaimed was previously made read accessible to
the device then request ordering of all previous reads; else if the memory
reclaimed was previously made write accessible to the device then request
ordering of all previous reads and writes. Ordering previous reads may be
required if the reclaimed memory will be used to hold data that must not be made
visible to the device.</p>
</div>
<div class="paragraph">
<p>The <code>IOFENCE.C</code> with <code>PR</code> and/or <code>PW</code> set to 1 only ensures that requests that
have been already processed by the IOMMU are committed to the global ordering
point. Software must perform an interconnect-specific fence action if there
is a need to ensure that all in-flight requests from a device that have not yet
been processed by the IOMMU are observed. For PCIe, for example, a completion
from device in response to a read from the device memory has the property of
ensuring that previous posted writes are observed by the IOMMU as completions
may not pass previous posted writes.</p>
</div>
<div class="paragraph">
<p>The ordering guarantees are made for accesses to main-memory. For accesses to
I/O memory, the ordering guarantees are implementation and I/O protocol
defined. Simpler implementations may unconditionally order all previous memory
accesses globally.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>AV</code> command operand indicates if <code>ADDR[63:2]</code> and <code>DATA</code> operands are
valid. If <code>AV</code>=1, the IOMMU writes <code>DATA</code> to memory at a 4-byte aligned address
<code>ADDR[63:2] * 4</code> as a 4-byte store when the command completes. When <code>AV</code> is 0,
the <code>ADDR[63:2]</code> and <code>DATA</code> operands are ignored. If the attempt to perform this
write encounters a memory fault, the <code>cmd_mf</code> bit in <code>cqcsr</code> <a href="#CSR">Section 6.15</a> is set to
signal this condition, and the <code>cqh</code> holds the index of the <code>IOFENCE.C</code> that
encountered such a memory fault and did not complete.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Software may configure the <code>ADDR[63:2]</code> command operand to specify the address
of the <code>seteipnum_le</code>/<code>seteipnum_be</code> register in an IMSIC to cause an external
interrupt notification on <code>IOFENCE.C</code> completion. Alternatively, software may
program <code>ADDR[63:2]</code> to a memory location and use <code>IOFENCE.C</code> to set a flag in
memory indicating command completion.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="iommu-directory-cache-invalidation-commands"><a class="anchor" href="#iommu-directory-cache-invalidation-commands"></a>4.1.3. IOMMU directory cache invalidation commands</h4>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjDXUchLzE21UlDPL0jOT0lV11FILCkpAvI9_V08gzQMKow11Wt1EBqM4RrSSvOSjYHqoRqi1T39whx94l1cQnQNKgyAElCBALCAoXossjFGcGOKistSUGwwMoDLBXi6oEgZ4taFkHIJQ5Eww2OTCUITmk1mJhjaYnUUkvPz0jLTrapzEvNSgYqAajKKCxKTU60MDUBmpeXnlRRnVgG5RrW1APcDaYI=" alt="Diagram">
</div>
</div>
<div class="paragraph">
<p>IOMMU operations cause implicit reads to DDT and/or PDT. To reduce latency of
such reads, the IOMMU may cache entries from the DDT and/or PDT in IOMMU
directory caches. These caches might not observe modifications performed by
software to these data structures in memory.</p>
</div>
<div id="IDDT" class="paragraph">
<p>The IOMMU DDT cache invalidation command, <code>IODIR.INVAL_DDT</code>, synchronizes updates
to DDT with the operation of the IOMMU and flushes the matching cached entries.</p>
</div>
<div id="IPDT" class="paragraph">
<p>The IOMMU PDT cache invalidation command, <code>IODIR.INVAL_PDT</code>, synchronizes updates
to PDT with the operation of the IOMMU and flushes the matching cached entries.</p>
</div>
<div class="paragraph">
<p>The <code>DV</code> operand indicates if the device ID (<code>DID</code>) operand is valid. The <code>DV</code>
operand must be 1 for <code>IODIR.INVAL_PDT</code> else the command is illegal. When <code>DV</code>
operand is 1, the value of the <code>DID</code> operand must not be wider than that
supported by the <code>ddtp.iommu_mode</code>.</p>
</div>
<div class="paragraph">
<p><code>IODIR.INVAL_DDT</code> guarantees that any previous stores made by a RISC-V hart to
the DDT are observed before all subsequent implicit reads from IOMMU to DDT.
If <code>DV</code> is 0, then the command invalidates all  DDT and PDT entries cached for
all devices; the <code>DID</code> operand is ignored. If <code>DV</code> is 1, then the command
invalidates cached leaf-level DDT entry for the device identified by <code>DID</code>
operand and all associated PDT entries. The <code>PID</code> operand is reserved for the
<code>IODIR.INVAL_DDT</code> command.</p>
</div>
<div class="paragraph">
<p><code>IODIR.INVAL_PDT</code> guarantees that any previous stores made by a RISC-V hart to
the PDT are observed before all subsequent implicit reads from IOMMU to PDT.
The command invalidates cached leaf PDT entry for the specified <code>PID</code> and <code>DID</code>.
The <code>PID</code> operand of <code>IODIR.INVAL_PDT</code> must not be wider than the width
supported by the IOMMU (see <a href="#CAP">Section 6.3</a>).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Some fields in the Device-context or Process-context may be guest-physical
addresses. An implementation when caching the device-context or process-context
may cache these fields after translating them to a supervisor physical address.
Other implementations may cache them as guest-physical addresses and
translate them to supervisor physical addresses using a second-stage page table
just prior to accessing memory referenced by these addresses.</p>
</div>
<div class="paragraph">
<p>If second-stage page tables used for these translations are modified, software
must issue the appropriate <code>IODIR</code> command as some implementations may choose to
cache the translated supervisor physical address pointer in the IOMMU directory
caches.</p>
</div>
<div class="paragraph">
<p>The <code>IOTINVAL</code> command has no effect on the IOMMU directory caches.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="iommu-pcie-ats-commands"><a class="anchor" href="#iommu-pcie-ats-commands"></a>4.1.4. IOMMU PCIe ATS commands</h4>
<div class="paragraph">
<p>This command is supported if <code>capabilities.ATS</code> is set to 1.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNp1jl0LgjAUhu_7FbtbwYL5QcXuBoYIUqIhRHhhc5pQU3SFJP73RoQfgXd79zzvOaeteEbAZQFAe81lTcAWARE_OAGwKFmRcIhALGWlMj0FS9yYK9ihQTd6PX0KZij7p1-gcwipu8YNVp_Q821fvTUYjdt6367qVzIZrOOeeY41QdpAwhlgBVOymV-kDcz_W7Qbzdvb04HmcAQ9u0f6bUYIsEKkeUbaeyy48pR2q8uYcaJhXYW0ELLO3yrqXfcBpmRtMQ==" alt="Diagram">
</div>
</div>
<div class="paragraph">
<p>The <code>ATS.INVAL</code> command instructs the IOMMU to send an “Invalidation Request”
message to the PCIe device function identified by <code>RID</code>. An
“Invalidation Request” message is used to clear a specific subset of the
address range from the address translation cache in a device function. The
<code>ATS.INVAL</code> command completes when an “Invalidation Completion” response message
is received from the device or a protocol-defined timeout occurs while waiting
for a response. The IOMMU may advance the <code>cqh</code> and fetch more commands from
CQ while a response is awaited. If a timeout occurs, it is reported when a
subsequent <code>IOFENCE.C</code> command is executed.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Software that needs to know if the invalidation operation completed on the
device may use the IOMMU command-queue fence command (<code>IOFENCE.C</code>) to wait for
the responses to all prior “Invalidation Request” messages. The <code>IOFENCE.C</code> is
guaranteed to not complete before all previously fetched commands were executed
and completed. A previously fetched ATS command to invalidate device ATC does
not complete until either the request times out or a valid response is received
from the device.</p>
</div>
<div class="paragraph">
<p>If one or more ATS invalidation commands preceding the <code>IOFENCE.C</code> have timed
out, then software may make the CQ operational again and resubmit the
invalidation commands that may have timed out. If the <code>ATS.INVAL</code> commands
queued before the <code>IOFENCE.C</code> were directed at multiple devices then software
may resubmit these commands as <code>ATS.INVAL</code> and <code>IOFENCE.C</code> pairs to identify
the device that caused the timeout.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>ATS.PRGR</code> command instructs the IOMMU to send a “Page Request Group
Response” message to the PCIe device function identified by the <code>RID</code>. The
“Page Request Group Response” message is used by system hardware and/or
software to communicate with the device functions page-request interface to
signal completion of a “Page Request”, or the catastrophic failure of the
interface.</p>
</div>
<div class="paragraph">
<p>If the <code>PV</code> operand is set to 1, the message is generated with a PASID with the
PASID field set to the <code>PID</code> operand. if <code>PV</code> operand is set to 0, then the
<code>PID</code> operand is ignored and the message is generated without a PASID.</p>
</div>
<div class="paragraph">
<p>The <code>PAYLOAD</code> operand of the command is used to form the message body and its
fields are as specified by the PCIe specification cite:[PCI]. The <code>PAYLOAD</code> field is
formatted as follows:</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNp9jTsOwjAQBXtOsV0aF_4giu2oOACiilKYZBMshQ3yuorluwNCCrihfDMavRxpQmh3APkakiAYBezvhNCcmqJ-uN6ErsXGzxW33-DCKXqW2Sca4DgMkURaZ9DYrkqc_Z8cHLpP0inoFx7DhHn2TO87BTd5-J7QaLtXMC6cJKyvaUt5AmgdRdA=" alt="`PAYLOAD` of an `ATS.INVAL` command">
</div>
<div class="title">Figure 30. <code>PAYLOAD</code> of an <code>ATS.INVAL</code> command</div>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjA20lHIS8xNtVJQN1Cv1UFIWMLFAxLTUxWCUgtLU4tLFNyL8ksLFDzzUlIrUJQb4zDGBC4elFpckJ9XnKrgnJ-SiqLG0AxVc6yOQnJ-XlpmulV1TmJeKlAF0JEZxQWJyalWhgZGQCPT8vNKijOrgFyj2loAODw__g==" alt="`PAYLOAD` of an `ATS.PRGR` command">
</div>
<div class="title">Figure 31. <code>PAYLOAD</code> of an <code>ATS.PRGR</code> command</div>
</div>
<div class="paragraph">
<p>If the <code>DSV</code> operand is 1, then a valid destination segment number is specified
by the <code>DSEG</code> operand. If the <code>DSV</code> operand is 0, then the <code>DSEG</code> operand is
ignored.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A Hierarchy is a PCI Express I/O interconnect topology, wherein the
Configuration Space addresses, referred to as the tuple of Bus/Device/Function
Numbers, are unique. In some contexts, a Hierarchy is also called a Segment, and
in Flit Mode, the Segment number is sometimes included in the ID of a Function.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="FAULT_QUEUE"><a class="anchor" href="#FAULT_QUEUE"></a>4.2. Fault/Event-Queue (<code>FQ</code>)</h3>
<div class="paragraph">
<p>Fault/Event queue is an in-memory queue data structure used to report events
and faults raised when processing transactions. Each fault record is 32 bytes.</p>
</div>
<div class="paragraph">
<p>The PPN of the base of this in-memory queue and the size of the queue is
configured into a memory-mapped register called fault-queue base (<code>fqb</code>).</p>
</div>
<div class="paragraph">
<p>The tail of the fault-queue resides in an IOMMU controlled read-only
memory-mapped register called <code>fqt</code>.  The <code>fqt</code> is an index into the next fault
record that IOMMU will write in the fault-queue. Subsequent to writing the
record, the IOMMU advances the <code>fqt</code> by 1. The head of the fault-queue resides
in a read/write memory-mapped software controlled register called <code>fqh</code>. The <code>fqh</code>
is an index into the fault record that SW should process next. Subsequent
to processing fault record(s) software advances the <code>fqh</code> by the count of the
number of fault records processed. If <code>fqh</code> == <code>fqt</code>, the fault-queue is empty. If
<code>fqt</code> == (<code>fqh</code> - 1) the fault-queue is full.</p>
</div>
<div class="paragraph">
<p>The fault records are interpreted as four 64-bit doublewords. The byte order of
each of the doublewords in memory, little-endian or big-endian, is the endianness
as determined by <code>fctl.BE</code> (<a href="#FCTRL">Section 6.4</a>).</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNp9zrEOgjAYBODdp_g3lg5QDTHdjDCwEUUTYxwq_mATaE1bGCS8u7DQQILj5bvkrtNYMrhvALqnsIZBQAlIXiMD73i4nGOvJw6pP2GaRDOCwNF1VU7JwsLJsuyWzsd2k0WLsa07WSgNeWOsqqExuNbSaFC3-Jp56AaEsi2v_isd-UEgV7IQJesqLnHo7Qm8zYfnyAJ_vFwoaY34DpH2_Q9dMGbV" alt="Fault-queue record">
</div>
<div class="title">Figure 32. Fault-queue record</div>
</div>
<div class="paragraph">
<p>The <code>CAUSE</code> is a code indicating the cause of the fault/event.</p>
</div>
<table id="FAULT_CAUSE" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 11. Fault record <code>CAUSE</code> field encodings</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">CAUSE</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-center valign-top">Reported if <code>DTF</code> is 1?</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Instruction access fault</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Read address misaligned</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Read access fault</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Write/AMO address misaligned</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Write/AMO access fault</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Instruction page fault</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">13</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Read page fault</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">15</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Write/AMO page fault</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">20</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Instruction guest page fault</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">21</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Read guest-page fault</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">23</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Write/AMO guest-page fault</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">256</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">All inbound transactions disallowed</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">257</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DDT entry load access fault</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">258</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DDT entry not valid</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">259</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DDT entry misconfigured</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">260</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Transaction type disallowed</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">261</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MSI PTE load access fault</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">262</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MSI PTE not valid</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">263</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MSI PTE misconfigured</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">264</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MRIF access fault</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">265</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PDT entry load access fault</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">266</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PDT entry not valid</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">267</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PDT entry misconfigured</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">268</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DDT data corruption</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">269</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PDT data corruption</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">270</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MSI PT data corruption</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">271</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MSI MRIF data corruption</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">272</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Internal data path error</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">273</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IOMMU MSI write access fault</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">274</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">First/second-stage PT data corruption</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">No</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The <code>CAUSE</code> encodings 275 through 2047 are reserved for future standard use and
the encodings 2048 through 4095 are designated for custom use. Encodings between
0 and 275 that are not specified in <a href="#FAULT_CAUSE">Table 11</a> are reserved for future
standard use.</p>
</div>
<div class="paragraph">
<p>If a fault condition prevents locating a valid device context then the <code>DTF</code>
value assumed for reporting such faults is 0.</p>
</div>
<div class="paragraph">
<p>The <code>TTYP</code> field reports inbound transaction type.</p>
</div>
<table class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 12. Fault record <code>TTYP</code> field encodings</caption>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">TTYP</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">None. Fault not caused by an inbound transaction.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Untranslated read for execute transaction</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Untranslated read transaction</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Untranslated write/AMO transaction</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Translated read for execute transaction</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Translated read transaction</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Translated write/AMO transaction</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PCIe ATS Translation Request</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PCIe Message Request</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">10 - 31</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">31 - 63</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Designated for custom use</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>If the <code>TTYP</code> is a transaction with an IOVA, the IOVA is reported in <code>iotval</code>. If
the <code>TTYP</code> is a PCIe message request, the message code of the PCIe message
is reported in <code>iotval</code>. If <code>TTYP</code> is 0, the values reported in <code>iotval</code> and
<code>iotval2</code> fields are as defined by the <code>CAUSE</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>IOVA</code> is partitioned into a virtual page number (VPN) and page offset.
Whereas the VPN is translated into a physical page number (PPN) by the address
translation process, the page offset is not required for this process. The IO
bridge in some implementations may not provide the page offset part of the
<code>IOVA</code> to the IOMMU and the IOMMU may report the page offset in <code>iotval</code> as 0.
Likewise, an IOMMU may report the page offset of a GPA in <code>iotval2</code> as 0.</p>
</div>
</td>
</tr>
</table>
</div>
<div style="page-break-after: always;"></div>
<div class="paragraph">
<p><code>DID</code> holds the <code>device_id</code> of the transaction. If <code>PV</code> is 0, then <code>PID</code> and
<code>PRIV</code> are 0. If <code>PV</code> is 1, the <code>PID</code> holds a <code>process_id</code> of the transaction
and if the privilege of the transaction was Supervisor then the <code>PRIV</code> bit is 1
else it&#8217;s 0. The <code>DID</code>, <code>PV</code>, <code>PID</code>, and <code>PRIV</code> fields are 0 if <code>TTYP</code> is 0.</p>
</div>
<div class="paragraph">
<p>If the <code>CAUSE</code> is a guest-page fault then bits 63:2 of the zero-extended
guest-physical-address are reported in <code>iotval2[63:2]</code>. If bit 0 of <code>iotval2</code> is
1, then the guest-page-fault was caused by an implicit memory access for
first-stage address translation. If bit 0 of <code>iotval2</code> is 1, and the implicit
access was a write then bit 1 of <code>iotval2</code> is set to 1 else it is set to 0.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The bit 1 of <code>iotval2</code> is set for the case where the implementation supports
hardware updating of A/D bits and the implicit memory access was attempted to
automatically update A and/or D in first-stage page tables. All other implicit
memory accesses for first-stage address translation will be reads. If the
hardware updating of A/D bits is not implemented, the <em>write</em> case will never
arise.</p>
</div>
<div class="paragraph">
<p>When the second-stage is not Bare, the memory accesses for reading PDT entries to
locate the Process-context are implicit memory accesses for first-stage address
translation. If a guest-page fault was caused by implicit memory access to read
PDT entries, then bit 0 of <code>iotval2</code> is reported as 1 and bit 1 as 0.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The IOMMU may be unable to report faults through the fault-queue due to error
conditions such as the fault-queue being full or the IOMMU encountering access
faults when attempting to access the queue memory. A memory-mapped fault
control and status register (<code>fqcsr</code>) holds information about such faults. If
the fault-queue full condition is detected, the IOMMU sets the fault-queue overflow
(<code>fqof</code>) bit in fqcsr. If the IOMMU encounters a fault in accessing the
fault-queue memory, the IOMMU sets the fault-queue memory access fault (<code>fqmf</code>)
bit in <code>fqcsr</code>. While either error bit is set in <code>fqcsr</code>, the IOMMU discards
the record that led to the fault and all further fault records. When an error
bit in <code>fqcsr</code> is 1 or when a new fault record is produced in the fault-queue,
the fault interrupt pending (<code>fip</code>) bit is set in <code>ipsr</code> if interrupts from
the fault-queue are enabled i.e. <code>fqcsr.fie</code> is 1.</p>
</div>
<div class="paragraph">
<p>The IOMMU may identify multiple requests as having detected an identical fault.
In such cases the IOMMU may report each of those faults individually, or report
the fault for a subset, including one, of requests.</p>
</div>
</div>
<div class="sect2">
<h3 id="PRQ"><a class="anchor" href="#PRQ"></a>4.3. Page-Request-Queue (<code>PQ</code>)</h3>
<div class="paragraph">
<p>Page-request queue is an in-memory queue data structure used to report PCIe
ATS “Page Request” and "Stop Marker" messages cite:[PCI] to software. The base PPN of
this in-memory queue and the size of the queue is configured into a
memory-mapped register called page-request queue base (<code>pqb</code>).
Each Page-Request record is 16 bytes.</p>
</div>
<div class="paragraph">
<p>The tail of the queue resides in an IOMMU controlled read-only memory-mapped
register called <code>pqt</code>.  The <code>pqt</code> holds an index into the queue where the next
page-request message will be written by the IOMMU. Subsequent to writing the
message, the IOMMU advances the <code>pqt</code> by 1.</p>
</div>
<div class="paragraph">
<p>The head of the queue resides in a software controlled read/write memory-mapped
register called <code>pqh</code>. The <code>pqh</code> holds an index into the queue where the next
page-request message will be received by software. Subsequent to processing the
message(s) software advances the <code>pqh</code> by the count of the number of messages
processed.</p>
</div>
<div class="paragraph">
<p>If <code>pqh</code> == <code>pqt</code>, the page-request queue is empty.</p>
</div>
<div class="paragraph">
<p>If <code>pqt</code> == (<code>pqh</code> - 1) the page-request queue is full.</p>
</div>
<div class="paragraph">
<p>The IOMMU may be unable to report "Page Request" messages through the queue due
to error conditions such as the queue being disabled, queue being full, or the
IOMMU encountering access faults when attempting to access queue memory. A
memory-mapped page-request queue control and status register (<code>pqcsr</code>) is used
to hold information about such faults.  On a page queue full condition the
page-request-queue overflow (<code>pqof</code>) bit is set in <code>pqcsr</code>. If the IOMMU
encountered a fault in accessing the queue memory, the page-request-queue memory
access fault (<code>pqmf</code>) bit is set in <code>pqcsr</code>. While either error bit is set in
<code>pqcsr</code>, the IOMMU discards all subsequent "Page Request" messages, including
the message that caused the error bits to be set. "Page request" messages that
do not require a response, i.e. those with the "Last Request in PRG" field is 0,
are silently discarded. "Page request" messages that require a response, i.e.
those with "Last Request in PRG" field set to 1 and are not "Stop Marker"
messages, may be auto-completed by an IOMMU generated “Page Request Group
Response” message as specified in <a href="#ATS_PRI">Section 3.7</a>.</p>
</div>
<div class="paragraph">
<p>When an error bit in <code>pqcsr</code> is 1 or when a new message is produced in the
queue, the page-request-queue interrupt pending (<code>pip</code>) bit is set in the <code>ipsr</code> if
interrupts from page-request-queue are enabled i.e. <code>pqcsr.pie</code> is 1.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjA00lHIS8xNtVJQL0otTi0qS01Rr9VByBsZwOUDPF1QpBQMEVJhOGWCPHHKuUa4OqPKmRJwjAlc3gXNMWYIqQDHSB9_R7B0rI5Ccn5eWma6VXVOYl4qUB1QWUZxQWJyqpWhAci4tPy8kuLMKiDXqLYWANHKUt0=" alt="Page-request-queue record">
</div>
<div class="title">Figure 33. Page-request-queue record</div>
</div>
<div class="paragraph">
<p>The <code>DID</code> field holds the requester ID from the message. The <code>PID</code> field is
valid if <code>PV</code> is 1 and reports the PASID from message. <code>PRIV</code> is set to 0 if the
message did not have a PASID, otherwise it holds the “Privilege Mode Requested”
bit from the TLP. The <code>EXEC</code> bit is set to 0 if the message did not have a PASID,
otherwise it reports the “Execute Requested” bit from the TLP. All other fields
are set to 0. The payload of the “Page Request” message (bytes 0x08 through 0x0F
of the message) is held in the <code>PAYLOAD</code> field. If <code>R</code> and <code>W</code> are both 0 and
<code>L</code> is 1, the message is "Stop Marker".</p>
</div>
<div class="paragraph">
<p>The page-request-queue records are interpreted as two 64-bit doublewords. The byte
order of each of the doublewords in memory, little-endian or big-endian, is the
endianness as determined by <code>fctl.BE</code> (<a href="#FCTRL">Section 6.4</a>).</p>
</div>
<div class="paragraph">
<p>The <code>PAYLOAD</code> holds the message body and its fields are as specified by the PCIe
specification cite:[PCI]. The <code>PAYLOAD</code> field is formatted as follows:</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNp1zLEKwjAUheHdp7hblwxNIoJ3cxLBQbo4lA6xuY0Bm9YkBbHk3VUEIVDH8_NxZk8GoV4BzBcbAwJn4FRPCEVVJLbUz3_6MevbXz8pQ1DRfaIQYe-HaYSD0_TIuChzv9PaUwi15MhFk1EplulGovzShkE7uM4anG_K0eeewTWMqiXkpVgz6AYXg32-p0jpBc1NTe4=" alt="`PAYLOAD` of a &quot;Page request&quot; message">
</div>
<div class="title">Figure 34. <code>PAYLOAD</code> of a "Page request" message</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="debug"><a class="anchor" href="#debug"></a>5. Debug support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To support software debug, the IOMMU may provide an optional register interface
that may be used by software to request IOMMU to perform an address translation.
The IOMMU supports this capability when <code>capabilities.DBG</code> is 1. The interface
consists of two set of registers; translation-request registers that are used by
software to program an IOVA and other inputs needed by the process to
translate an IOVA (<a href="#P2IOVA">Section 3.3</a>) as an Untranslated Request. The result of the
translation, if the process completes successfully, is reported through the
translation-response registers. If the process stops due to faults then the
faults are reported normally in the fault-queue and the translation-response
registers updated with a failure indicator. If the IOVA is determined to be
that of a virtual interrupt file (<a href="#MSI_ID">Section 3.1.3.6</a>) and the corresponding MSI PTE is
in MRIF mode, then the process stops and reports a "Transaction type disallowed"
(cause = 260) fault.</p>
</div>
<div class="paragraph">
<p>When the process to translate an IOVA is invoked for this purpose, the IOMMU
may or may not cache first-stage PTEs, second-stage PTEs, DDT entries, PDT entries, or
MSI PTEs accessed for the translation process in the IOATC. The IOMMU is allowed
to use any PTEs or directory structure entries that may already be cached in the
IOATC. The IOMMU may update the Accessed (A) and/or Dirty (D) bits in the PTEs
used for the translation process if supported by the IOMMU. When the IOMMU
implements a HPM, the HPM counters may be updated normally by the IOMMU. For the
purpose of counting in the HPM, these requests are treated as Untranslated
Requests.</p>
</div>
<div class="paragraph">
<p>The translation-request interface consists of the following 64-bit WARL registers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>tr_req_iova</code> (<a href="#TRR_IOVA">Section 6.24</a>)</p>
</li>
<li>
<p><code>tr_req_ctl</code> (<a href="#TRR_CTRL">Section 6.25</a>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The translation-response interface consists of a single 64-bit RO register
<code>tr_response</code> (<a href="#TRR_RSP">Section 6.26</a>)</p>
</div>
<div class="paragraph">
<p>To request a translation, the <code>tr_req_iova</code> register is written first with
the desired IOVA and the <code>tr_req_ctl</code> register is written next. The 'Go/Busy`
bit is set in <code>tr_req_ctl</code> to indicate a valid request in the registers.  The
<code>Go/Busy</code> bit is a read-write-sticky (RWS) bit that once set cannot be cleared
by writing the register. The <code>Go/Busy</code> bit will be cleared to 0 by the IOMMU
when the process completes (successfully or due to encountering a fault). When
the <code>Go/Busy</code> bit goes from 1 to 0, a response is valid in the <code>tr_response</code>
register.</p>
</div>
<div class="paragraph">
<p>When the <code>Go/Busy</code> bit is 1, the IOMMU behavior is <code>UNSPECIFIED</code> if:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>tr_req_iova</code> or <code>tr_req_ctl</code> are modified.</p>
</li>
<li>
<p>IOMMU configurations, such as <code>ddtp.iommu_mode</code>, are modified.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The time to complete a translation request through this debug interface is
<code>UNSPECIFIED</code> but is required to be finite. If the IOMMU is serving translation
requests from the IO bridge when a request is made through this register
interface then the time to complete the request may be longer than when the
IOMMU is otherwise idle.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The debug interface is optional but recommended to be implemented to aid
software debug and to implement architectural compliance tests.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="memory-mapped-register-interface"><a class="anchor" href="#memory-mapped-register-interface"></a>6. Memory-mapped register interface</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The IOMMU provides a memory-mapped programming interface. The memory-mapped
registers of each IOMMU are located within a naturally aligned 4-KiB region
(a page) of physical address space.</p>
</div>
<div class="paragraph">
<p>The IOMMU behavior for register accesses where the address is not aligned to
the size of the access, or if the access spans multiple registers, or if the
size of the access is not 4 bytes or 8 bytes, is <code>UNSPECIFIED</code>. A 4 byte access
to an IOMMU register must be single-copy atomic. Whether an 8 byte access to an
IOMMU register is single-copy atomic is <code>UNSPECIFIED</code>, and such an access may
appear, internally to the IOMMU, as if two separate 4 byte accesses&#8201;&#8212;&#8201;first to
the high half and second to the low half&#8201;&#8212;&#8201;were performed.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The 8-byte IOMMU registers are defined in such a way that software can perform
two individual 4-byte accesses, or hardware can perform two independent 4-byte
transactions resulting from an 8-byte access, to the high and low halves of the
register, in that order, as long as the register semantics, with regard to side-effects, are
respected between the two software accesses, or two hardware transactions,
respectively.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The IOMMU registers have little-endian byte order, even for systems where
all harts are big-endian-only.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Big-endian-configured harts that make use of an IOMMU are expected to implement
the <code>REV8</code> byte-reversal instruction defined by the Zbb extension. If <code>REV8</code> is
not implemented, then endianness conversion may be implemented using a sequence
of instructions.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If a register is optional, as determined by the corresponding <code>capabilities</code>
register bit being 0, then a read from the memory-mapped register offset of
the register returns 0 and writes to that offset are ignored.</p>
</div>
<div class="sect2">
<h3 id="register-layout"><a class="anchor" href="#register-layout"></a>6.1. Register layout</h3>
<table class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 13. IOMMU Memory-mapped register layout</caption>
<colgroup>
<col>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Offset</th>
<th class="tableblock halign-center valign-top">Name</th>
<th class="tableblock halign-center valign-top">Size</th>
<th class="tableblock halign-center valign-top">Description</th>
<th class="tableblock halign-center valign-top">Is Optional?</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>capabilities</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#CAP">Capabilities of the
                                     IOMMU</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fctl</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#FCTRL">Features control</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">custom</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Designated For custom use</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddtp</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#DDTP">Device directory
                              table pointer</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">24</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cqb</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#CQB">Command-queue base</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cqh</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#CQH">Command-queue head</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">36</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cqt</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#CQT">Command-queue tail</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">40</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fqb</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#FQB">Fault-queue base</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">48</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fqh</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#FQH">Fault-queue head</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">52</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fqt</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#FQT">Fault-queue tail</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">56</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pqb</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#PQB">Page-request-queue
                                     base</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">if <code>capabilities.ATS==0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pqh</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#PQH">Page-request-queue
                                     head</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">if <code>capabilities.ATS==0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">68</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pqt</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#PQT">Page-request-queue
                                     tail</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">if <code>capabilities.ATS==0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">72</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cqcsr</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#CSR">Command-queue CSR</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">76</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fqcsr</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#FQCSR">Fault-queue CSR</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">80</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pqcsr</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#PQCSR">Page-request-queue
                                       CSR </a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">if <code>capabilities.ATS==0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">84</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ipsr</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#IPSR">Interrupt pending
                                         status register</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">88</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>iocountovf</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#OVF">HPM counter
                                              overflows</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">if <code>capabilities.HPM==0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">92</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>iocountinh</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#INH">HPM counter
                                               inhibits</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">if <code>capabilities.HPM==0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">96</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>iohpmcycles</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#CYC">HPM cycles counter</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">if <code>capabilities.HPM==0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">104</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>iohpmctr1-31</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">248</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#CTR">HPM event counters</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">if <code>capabilities.HPM==0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">352</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>iohpmevt1-31</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">248</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#EVT">HPM event selector</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">if <code>capabilities.HPM==0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">600</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tr_req_iova</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#TRR_IOVA">Translation-request
                                     IOVA</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">if <code>capabilities.DBG==0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">608</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tr_req_ctl</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#TRR_CTRL">Translation-request
                                     control</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">if <code>capabilities.DBG==0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">616</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tr_response</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#TRR_RSP">Translation-request
                                     response</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">if <code>capabilities.DBG==0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">624</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>iommu_qosid</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#IOQOSID">IOMMU QoS ID </a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">if <code>capabilities.QOSID==0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">628</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">60</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for future use
                              (<code>WPRI</code>)</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">688</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">custom</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">72</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Designated for custom use
                              (<code>WARL</code>)</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">760</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>icvec</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#ICVEC">Interrupt cause
                              to vector register</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">768</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>msi_cfg_tbl</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">256</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#MSI">MSI Configuration
                                     Table</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">if <code>capabilities.IGS==WSI</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1024</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3072</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="reset-behavior"><a class="anchor" href="#reset-behavior"></a>6.2. Reset behavior</h3>
<div class="paragraph">
<p>The reset value is 0 for the following registers fields.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>cqcsr</code> - <code>cqen</code>, <code>cqie</code>, <code>cqon</code>, and <code>busy</code></p>
</li>
<li>
<p><code>fqcsr</code> - <code>fqen</code>, <code>fqie</code>, <code>fqon</code>, and <code>busy</code></p>
</li>
<li>
<p><code>pqcsr</code> - <code>pqen</code>, <code>pqie</code>, <code>pqon</code>, and <code>busy</code></p>
</li>
<li>
<p><code>tr_req_ctl.Go/Busy</code></p>
</li>
<li>
<p><code>ddtp.busy</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The reset value is 0 for the following registers.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ipsr</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Reset value for <code>ddtp.iommu_mode</code> field must be either <code>Off</code> or <code>Bare</code>.</p>
</div>
<div class="paragraph">
<p>After a reset the caches (<a href="#CACHING">Section 3.8</a>) must have no valid entries.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The reset value for the <code>iommu_mode</code> is recommended to be <code>Off</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The reset value is <code>UNSPECIFIED</code> for all other registers and/or fields.</p>
</div>
</div>
<div class="sect2">
<h3 id="CAP"><a class="anchor" href="#CAP"></a>6.3. IOMMU capabilities (<code>capabilities</code>)</h3>
<div class="paragraph">
<p>The <code>capabilities</code> register is a read-only register reporting features supported
by the IOMMU. Each field if not clear indicates the presence of that feature in
the IOMMU. At reset, the register shall contain the IOMMU supported features.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqF00ELgjAYBuB7v2K3Lh5yWdpuC8uELEuhQ0SYrRJSw5kE4n-PCAwP77ru2ffyso_Vhbgysu8RUp-SUjJiaSSLUsFIvxKFTPKs32g_1VsNqiHFNIFkWJBGZoeGLRVCiqISZzj5OKWloufLUDRVoGEpcGRC_NOXe-ujt3XngL3APc6XPFSwYvoTvthxG3EYAAmp43Ngs1U3j7biOihv4XtA7KnTkXErPkdpvm1B0U1IdABosw5c9EarJVp695yqF_77SfFTlnn6wYNG4jy7JFdW36NMfG_d5COKBdMH1GiaNyX2A7s=" alt="IOMMU capabilities register fields">
</div>
<div class="title">Figure 35. IOMMU capabilities register fields</div>
</div>
<table class="tableblock frame-all grid-all fit-content center">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Bits</th>
<th class="tableblock halign-center valign-top">Field</th>
<th class="tableblock halign-center valign-top">Attribute</th>
<th class="tableblock halign-center valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>version</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The <code>version</code> field holds the version of the
                                specification implemented by the IOMMU. The low
                                nibble is used to hold the minor version of the
                                specification and the upper nibble is used to
                                hold the major version of the specification.
                                For example, an implementation that supports
                                version 1.0 of the specification reports 0x10.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Sv32</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Page-based 32-bit virtual addressing is supported.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Sv39</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Page-based 39-bit virtual addressing is supported.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Sv48</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Page-based 48-bit virtual addressing is supported.<br>
                                When <code>Sv48</code> is set, <code>Sv39</code> must be set.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">11</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Sv57</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Page-based 57-bit virtual addressing is supported<br>
                                When <code>Sv57</code> is set, <code>Sv48</code> must be set.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">14:12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">15</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Svpbmt</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Page-based memory types.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Sv32x4</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Page-based 34-bit virtual addressing for
                                second-stage address translation is supported.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">17</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Sv39x4</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Page-based 41-bit virtual addressing for
                                second-stage address translation is supported.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">18</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Sv48x4</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Page-based 50-bit virtual addressing for
                                second-stage address translation is supported.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">19</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Sv57x4</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Page-based 59-bit virtual addressing for
                                second-stage address translation is supported.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">20</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">21</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AMO_MRIF</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Atomic updates to MRIF is supported.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">22</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MSI_FLAT</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MSI address translation using Pass-through
                                mode MSI PTE is supported.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">23</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MSI_MRIF</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MSI address translation using MRIF mode MSI PTE
                                is supported.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">24</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AMO_HWAD</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Atomic updates to PTE accessed (A)
                                and dirty (D) bit is supported.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">25</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ATS</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PCIe Address Translation Services (ATS) and
                                page-request interface (PRI) cite:[PCI] is supported.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">26</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>T2GPA</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returning guest-physical-address in ATS
                                translation completions is supported.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">27</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>END</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When 0, IOMMU supports one endianness (either little
                                or big). When 1, IOMMU supports both endianness.
                                The endianness is defined in the <code>fctl</code> register.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">29:28</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IGS</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>IOMMU interrupt generation support.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 60%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Value</th>
<th class="tableblock halign-center valign-top">Name</th>
<th class="tableblock halign-center valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MSI</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IOMMU supports only message-
                                                     signaled-interrupt generation.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WSI</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IOMMU supports only wire-
                                                     signaled-interrupt generation.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BOTH</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IOMMU supports both MSI
                                                     and WSI generation.
                                                     The interrupt generation method
                                                     must be defined in the <code>fctl</code>
                                                     register.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use</p></td>
</tr>
</tbody>
</table></div></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">30</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HPM</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IOMMU implements a hardware performance monitor.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">31</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DBG</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IOMMU supports the translation-request interface</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">37:32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PAS</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Physical Address Size supported by the IOMMU.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">38</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PD8</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">One level PDT with 8-bit process_id supported.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">39</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PD17</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Two level PDT with 17-bit process_id supported.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">40</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PD20</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Three level PDT with 20-bit process_id supported.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">41</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>QOSID</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Associating QoS IDs with requests is supported.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">42</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NL</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Non-leaf PTE invalidation extension is supported.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">43</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>S</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Address range invalidation extension is supported.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">55:44</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">63:56</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">custom</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Designated for custom use.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>When <code>HPM</code> is 1, the <code>iohpmcycles</code> and the <code>iohpmctr1</code> registers must be present
and be at least 32-bits wide.</p>
</div>
<div style="page-break-after: always;"></div>
<div class="paragraph">
<p>At least one method, <code>MSI</code> or <code>WSI</code>, of generating interrupts from the IOMMU
must be supported.</p>
</div>
<div class="paragraph">
<p>IOMMU implementations must support the Svnapot standard extension for NAPOT
Translation Contiguity.</p>
</div>
<div class="paragraph">
<p>The physical address space addressable by the IOMMU ranges from 0 to
\(2^{capabilities.PAS} - 1\).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Hypervisor may provide an SW emulated IOMMU to allow the guest to manage
the first-stage page tables for fine grained control on memory accessed by guest
controlled devices.</p>
</div>
<div class="paragraph">
<p>A hypervisor that provides such an emulated IOMMU to the guest may retain
control of the second-stage address translation and clear the <code>SvNx4</code> fields of
the emulated <code>capabilities</code> register.</p>
</div>
<div class="paragraph">
<p>A hypervisor that provides such an emulated IOMMU to the guest may retain
control of the MSI page tables used to direct MSIs to guest interrupt files in
an IMSIC or to a memory-resident-interrupt-file and clear the <code>MSI_FLAT</code> and
<code>MSI_MRIF</code> fields of the emulated <code>capabilities</code> register.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>AMO_HWAD</code>/<code>AMO_MRIF</code> bits do not indicate support for device-initiated atomic memory
operations. Support for device-initiated atomic memory operations must be
discovered through other means.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The IOMMU is designed to provide a highly modular and extensible set of
capabilities allowing implementations to include only the exact set of
capabilities required for an application. In addition, implementations may add
their own custom extensions to the IOMMU.</p>
</div>
<div class="paragraph">
<p>The IOMMU must support all the virtual memory extensions that are supported
by any of the harts in the system.</p>
</div>
<div class="paragraph">
<p>RISC-V platform specifications may mandate a set of IOMMU capabilities
that must be provided by an implementation to be compliant to those
specifications.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="FCTRL"><a class="anchor" href="#FCTRL"></a>6.4. Features-control register (<code>fctl</code>)</h3>
<div class="paragraph">
<p>This register must be readable in any implementation. An implementation may
allow one or more fields in the register to be writable to support enabling
or disabling the feature controlled by that field.</p>
</div>
<div class="paragraph">
<p>If software enables or disables a feature when the IOMMU is not OFF
(i.e. when <code>ddtp.iommu_mode != Off</code>) then the IOMMU behavior is <code>UNSPECIFIED</code>.</p>
</div>
<div class="paragraph">
<p>If software enables or disables a feature when the IOMMU in-memory queues
are enabled (i.e. <code>cqcsr.cqon/cqen == 1</code>, <code>fqcsr.fqon/cqen == 1</code>, or
<code>pqcsr.pqon/pqen == 1</code>) then the IOMMU behavior is <code>UNSPECIFIED</code>.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjDUUchLzE21UlB3clWv1cEmER7siUPGPcIHVcZYRwEmV5RanFpUlpqCqsAMoSC5tLgkPxckHaujkJyfl5aZblWdk5iXCrEio7ggMTnVytDAyKS2FgDYHzXv" alt="Feature-control register fields">
</div>
<div class="title">Figure 36. Feature-control register fields</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 22.2222%;">
<col style="width: 11.1111%;">
<col style="width: 55.5556%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Bits</th>
<th class="tableblock halign-center valign-top">Field</th>
<th class="tableblock halign-center valign-top">Attribute</th>
<th class="tableblock halign-center valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BE</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WARL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When 0, IOMMU accesses to memory resident data
                                structures, as specified in <a href="#ENDIAN_CONFIG">Table 7</a>,
                                and accesses to in-memory queues are performed
                                as little-endian accesses and when 1 as
                                big-endian accesses.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WSI</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WARL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When 1, IOMMU interrupts are signaled as
                                wire-signaled-interrupts else they are signaled
                                as message-signaled-interrupts.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GXL</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WARL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Controls the address-translation schemes that
                                may be used for guest physical addresses as
                                defined in <a href="#IOHGATP_MODE_ENC">Table 2</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">15:3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">31:16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">custom</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Designated for custom use.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="DDTP"><a class="anchor" href="#DDTP"></a>6.5. Device-directory-table pointer (<code>ddtp</code>)</h3>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjDRUVDIS8xNtVJQz8zPzS2Nz81PSVWv1UGoMESoSCotrkSRM9WBSRWlFqcWlaWmoEibmMDlAwL8UE01wKo1VkchOT8vLTPdqjonMS8V4sCM4oLE5FQrQwMjk9paAFsMOzM=" alt="Device-directory-table pointer register fields">
</div>
<div class="title">Figure 37. Device-directory-table pointer register fields</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 22.2222%;">
<col style="width: 11.1111%;">
<col style="width: 55.5556%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Bits</th>
<th class="tableblock halign-center valign-top">Field</th>
<th class="tableblock halign-center valign-top">Attribute</th>
<th class="tableblock halign-center valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">3:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>iommu_mode</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WARL</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The IOMMU may be configured to be in the following
                                modes:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 60%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Value</th>
<th class="tableblock halign-center valign-top">Name</th>
<th class="tableblock halign-center valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Off</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No inbound memory
                                                     transactions are allowed
                                                     by the IOMMU.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Bare</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No translation or
                                                     protection. All inbound
                                                     memory accesses are passed
                                                     through.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1LVL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">One-level
                                                     device-directory-table</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>2LVL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Two-level
                                                     device-directory-table</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>3LVL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Three-level
                                                     device-directory-table</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">5-13</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">14-15</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">custom</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Designated for custom use.</p></td>
</tr>
</tbody>
</table></div></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>busy</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A write to <code>ddtp.iommu_mode</code> may require the IOMMU to
                                perform many operations that may not occur
                                synchronously to the write. When a write is
                                observed by the <code>ddtp.iommu_mode</code>, the <code>busy</code> bit is set
                                to 1. When the <code>busy</code> bit is 1, behavior of
                                additional writes to the <code>ddtp</code> is
                                <code>UNSPECIFIED</code>. Some implementations
                                may ignore the second write and others may
                                perform the actions determined by the second
                                write. Software must verify that the <code>busy</code>
                                bit is 0 before writing to the <code>ddtp</code>.<br>
                                                                              <br>
                                If the <code>busy</code> bit reads 0 then the IOMMU has
                                completed the operations associated with the
                                previous write to <code>ddtp.iommu_mode</code>.<br>
                                                                              <br>
                                An IOMMU that can complete these operations
                                synchronously may hard-wire this bit to 0.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">9:5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">53:10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PPN</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WARL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Holds the <code>PPN</code> of the root page of the
                                device-directory-table.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">63:54</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The device-context is 64-bytes in size if <code>capabilities.MSI_FLAT</code> is 1 else it is
32-bytes.</p>
</div>
<div class="paragraph">
<p>When the <code>iommu_mode</code> is <code>Bare</code> or <code>Off</code>, the <code>PPN</code> field is don&#8217;t-care. When
in <code>Bare</code> mode only Untranslated requests are allowed. Translated requests,
Translation request, and PCIe message transactions are unsupported.</p>
</div>
<div class="paragraph">
<p>All IOMMUs must support <code>Off</code> and <code>Bare</code> mode. An IOMMU is allowed to support a
subset of directory-table levels and device-context widths. At a minimum one
of the modes must be supported.</p>
</div>
<div class="paragraph">
<p>When the <code>iommu_mode</code> field value is changed to <code>Off</code> the IOMMU guarantees that
in-flight transactions, observed at the time of the write to this field, from devices
connected to the IOMMU will either be processed with the configurations
applicable to the old value of the <code>iommu_mode</code> field or be aborted
(<a href="#IOBR_FAULT_RESP">Section 8.3</a>). It also ensures that all transactions and previous
requests from devices that have already been processed by the IOMMU are committed
to a global ordering point such that they can be observed by all RISC-V harts,
devices, and IOMMUs in the platform. Software must not change the <code>PPN</code> field
value when transitioning the <code>iommu_mode</code> to <code>Off</code>.</p>
</div>
<div class="paragraph">
<p>The IOMMU behavior of writing <code>iommu_mode</code> to <code>1LVL</code>, <code>2LVL</code>, or <code>3LVL</code>, when
the previous value of the <code>iommu_mode</code> is not <code>Off</code> or <code>Bare</code> is <code>UNSPECIFIED</code>.
To change DDT levels, the IOMMU must first be transitioned to <code>Bare</code> or <code>Off</code>
state. The behavior resulting from changing the <code>iommu_mode</code> to <code>Bare</code> when the
previous value of the <code>iommu_mode</code> was not <code>Off</code> is <code>UNSPECIFIED</code>.</p>
</div>
<div class="paragraph">
<p>When an IOMMU is transitioned to <code>Bare</code> or <code>Off</code> state, the IOMMU may retain
information cached from in-memory data structures such as page tables, DDT,
PDT, etc. Software must use suitable invalidation commands to invalidate cached
entries.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In RV32, only the low order 32-bits of the register (22-bit <code>PPN</code> and
4-bit <code>iommu_mode</code>) need to be written.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="CQB"><a class="anchor" href="#CQB"></a>6.6. Command-queue base (<code>cqb</code>)</h3>
<div class="paragraph">
<p>This 64-bit register (RW) holds the PPN of the root page of the command-queue
and number of entries in the queue. Each command is 16 bytes.</p>
</div>
<div class="paragraph">
<p>The IOMMU behavior on writing <code>cqb</code> when <code>cqcsr.busy</code> or <code>cqon</code> bits are 1 is
<code>UNSPECIFIED</code>. The software recommended sequence to change <code>cqb</code> is to first
disable the command-queue by clearing <code>cqen</code> and wait for both <code>cqcsr.busy</code> and
<code>cqon</code> to be 0 before changing the <code>cqb</code>. The status of bits <code>31:cqb.LOG2SZ</code> in
<code>cqt</code> following a write to <code>cqb</code> is 0 and the bits <code>cqb.LOG2SZ-1:0</code> in <code>cqt</code>
assume a valid but otherwise <code>UNSPECIFIED</code> value.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UlAw1VHIS8xNtVJQ9_F3NwqO0jVUr9VByCOki1KLU4vKUlNQpE1M4PIBAX4oUoYGWLXG6igk5-elZaZbVeck5qUCFRrpKGQUFyQmp1oZGhiZ1NYCAGQEMQM=" alt="Command-queue base register fields">
</div>
<div class="title">Figure 38. Command-queue base register fields</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Bits</th>
<th class="tableblock halign-center valign-top">Field</th>
<th class="tableblock halign-center valign-top">Attribute</th>
<th class="tableblock halign-center valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">4:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG2SZ-1</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WARL</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The <code>LOG2SZ-1</code> field holds the number of
                                entries in command-queue as a log to base 2
                                minus 1.
                                A value of 0 indicates a queue of 2 entries.
                                Each IOMMU command is 16-bytes.
                                If the command-queue has 256 or fewer entries
                                then the base address of the queue is always
                                aligned to 4-KiB. If the command-queue has more
                                than 256 entries then the command-queue
                                base address must be naturally aligned to
                                <code>2<sup>LOG2SZ</sup> x 16</code>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">9:5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">53:10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PPN</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WARL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Holds the <code>PPN</code> of the root page of the
                                in-memory command-queue used by software to
                                queue commands to the IOMMU. If the base
                                address as determined by <code>PPN</code> is not aligned
                                as required, all entries in the queue appear
                                to an IOMMU as <code>UNSPECIFIED</code> and any address
                                an IOMMU may compute and use for accessing an
                                entry in the queue is also <code>UNSPECIFIED</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">63:54</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In RV32, only the low order 32-bits of the register (22-bit <code>PPN</code> and
5-bit <code>LOG2SZ-1</code>) need to be written.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="CQH"><a class="anchor" href="#CQH"></a>6.7. Command-queue head (<code>cqh</code>)</h3>
<div class="paragraph">
<p>This 32-bit register (RO) holds the index into the command-queue where
the IOMMU will fetch the next command.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjA20lHIS8xNtVJQz8xLSa1Qr9XhitVRSM7PS8tMt6rOScxLBaoy1FHIKC5ITE61MjQwMqmtBQATKxYy" alt="Command-queue head register fields">
</div>
<div class="title">Figure 39. Command-queue head register fields</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Bits</th>
<th class="tableblock halign-center valign-top">Field</th>
<th class="tableblock halign-center valign-top">Attribute</th>
<th class="tableblock halign-center valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">31:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>index</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Holds the <code>index</code> into the command-queue from where
                            the next command will be fetched by the IOMMU.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="CQT"><a class="anchor" href="#CQT"></a>6.8. Command-queue tail (<code>cqt</code>)</h3>
<div class="paragraph">
<p>This 32-bit register (RW) holds the index into the command-queue where
the software queues the next command for the IOMMU.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjA20lHIS8xNtVJQz8xLSa1Qr9XhitVRSM7PS8tMt6rOScxLBaoy1FHIKC5ITE61MjQwMqmtBQATKxYy" alt="Command-queue tail register fields">
</div>
<div class="title">Figure 40. Command-queue tail register fields</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Bits</th>
<th class="tableblock halign-center valign-top">Field</th>
<th class="tableblock halign-center valign-top">Attribute</th>
<th class="tableblock halign-center valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">31:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>index</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WARL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Holds the <code>index</code> into the command-queue where
                            software queues the next command for IOMMU.  Only
                            <code>LOG2SZ-1:0</code> bits are writable.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="FQB"><a class="anchor" href="#FQB"></a>6.9. Fault queue base (<code>fqb</code>)</h3>
<div class="paragraph">
<p>This 64-bit register (RW) holds the PPN of the root page of the fault-queue
and number of entries in the queue. Each fault record is 32 bytes.</p>
</div>
<div class="paragraph">
<p>The IOMMU behavior on writing <code>fqb</code> when <code>fqcsr.busy</code> or <code>fqon</code> bits are 1 is
<code>UNSPECIFIED</code>. The software recommended sequence to change <code>fqb</code> is to first
disable the fault-queue by clearing <code>fqen</code> and wait for both <code>fqcsr.busy</code> and
<code>fqon</code> to be 0 before changing the <code>fqb</code>. The status of bits <code>31:fqb.LOG2SZ</code>
in <code>fqh</code> following a write to <code>fqb</code> is 0 and the bits <code>fqb.LOG2SZ-1:0</code> in <code>fqh</code>
assume a valid but otherwise <code>UNSPECIFIED</code> value.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjDVUchLzE21UlD38Xc3Co7SNVSv1cEmXZRanFpUlpqCIm1iApcPCPBDkTI0wKo1VkchOT8vLTPdqjonMS8VqNBIRyGjuCAxOdXK0MDIpLYWAExkMOM=" alt="Fault queue base register fields">
</div>
<div class="title">Figure 41. Fault queue base register fields</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Bits</th>
<th class="tableblock halign-center valign-top">Field</th>
<th class="tableblock halign-center valign-top">Attribute</th>
<th class="tableblock halign-center valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">4:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG2SZ-1</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WARL</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The <code>LOG2SZ-1</code> field holds the number of
                               entries in the fault-queue as a log-to-base-2
                               minus 1. A value of 0 indicates a queue of 2
                               entries. Each fault record is 32-bytes.
                               If the fault-queue has 128 or fewer entries then
                               the base address of the queue is always aligned
                               to 4-KiB. If the fault-queue has more than 128
                               entries then the fault-queue base address must
                               be naturally aligned to <code>2<sup>LOG2SZ</sup> x 32</code>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">9:5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">53:10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PPN</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WARL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Holds the <code>PPN</code> of the root page of the
                               in-memory fault-queue used by IOMMU to queue
                               fault record. If the base address as determined
                               by <code>PPN</code> is not aligned as required, all entries
                               in the queue appear to an IOMMU as <code>UNSPECIFIED</code>
                               and any address an IOMMU may compute and use for
                               accessing an entry in the queue is also
                               <code>UNSPECIFIED</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">63:54</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In RV32, only the low order 32-bits of the register (22-bit <code>PPN</code> and
5-bit <code>LOG2SZ-1</code>) need to be written.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="FQH"><a class="anchor" href="#FQH"></a>6.10. Fault queue head (<code>fqh</code>)</h3>
<div class="paragraph">
<p>This 32-bit register (RW) holds the index into the fault-queue where the
software will fetch the next fault record.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjA20lHIS8xNtVJQz8xLSa1Qr9XhitVRSM7PS8tMt6rOScxLBaoy1FHIKC5ITE61MjQwMqmtBQATKxYy" alt="Fault queue head register fields">
</div>
<div class="title">Figure 42. Fault queue head register fields</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Bits</th>
<th class="tableblock halign-center valign-top">Field</th>
<th class="tableblock halign-center valign-top">Attribute</th>
<th class="tableblock halign-center valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">31:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>index</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WARL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Holds the <code>index</code> into the fault-queue from which
                            software reads the next fault record.  Only
                            <code>LOG2SZ-1:0</code> bits are writable.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="FQT"><a class="anchor" href="#FQT"></a>6.11. Fault queue tail (<code>fqt</code>)</h3>
<div class="paragraph">
<p>This 32-bit register (RO) holds the index into the fault-queue where the
IOMMU queues the next fault record.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjA20lHIS8xNtVJQz8xLSa1Qr9XhitVRSM7PS8tMt6rOScxLBaoy1FHIKC5ITE61MjQwMqmtBQATKxYy" alt="Fault queue tail register fields">
</div>
<div class="title">Figure 43. Fault queue tail register fields</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Bits</th>
<th class="tableblock halign-center valign-top">Field</th>
<th class="tableblock halign-center valign-top">Attribute</th>
<th class="tableblock halign-center valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">31:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>index</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Holds the <code>index</code> into the fault-queue where IOMMU
                            writes the next fault record.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="PQB"><a class="anchor" href="#PQB"></a>6.12. Page-request-queue base (<code>pqb</code>)</h3>
<div class="paragraph">
<p>This 64-bit register (WARL) holds the PPN of the root page of the
page-request-queue and number of entries in the queue. Each "Page Request"
message is 16 bytes.</p>
</div>
<div class="paragraph">
<p>The IOMMU behavior on writing <code>pqb</code> when <code>pqcsr.busy</code> or <code>pqon</code> bits are 1 is
<code>UNSPECIFIED</code>. The software recommended sequence to change <code>pqb</code> is to first
disable the page-request-queue by clearing <code>pqen</code> and wait for both <code>pqcsr.busy</code>
and <code>pqon</code> to be 0 before changing the <code>pqb</code>. The status of bits <code>31:pqb.LOG2SZ</code>
in <code>pqh</code> following a write to <code>pqb</code> is 0 and the bits <code>pqb.LOG2SZ-1:0</code> in <code>pqh</code>
assume a valid but otherwise <code>UNSPECIFIED</code> value.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjDVUchLzE21UlD38Xc3Co7SNVSv1UFII8kXpRanFpWlpqDIm5jA5QMC_FCkDA2wao3VUUjOz0vLTLeqzknMSwUqNNJRyCguSExOtTI0MDKprQUAaIcxAw==" alt="Page-Request-queue base register fields">
</div>
<div class="title">Figure 44. Page-Request-queue base register fields</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Bits</th>
<th class="tableblock halign-center valign-top">Field</th>
<th class="tableblock halign-center valign-top">Attribute</th>
<th class="tableblock halign-center valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">4:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG2SZ-1</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WARL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The <code>LOG2SZ-1</code> field holds the number of entries
                               in the page-request-queue as a log-to-base-2 minus 1.
                               A value of 0 indicates a queue of 2 entries.
                               Each page-request is 16-bytes. If the
                               page-request-queue has 256 or fewer entries
                               then the base address of the queue is always
                               aligned to 4-KiB.
                               If the page-request-queue has more than 256
                               entries then the page-request-queue base address
                               must be naturally aligned to <code>2<sup>LOG2SZ</sup> x 16</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">9:5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">53:10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PPN</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WARL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Holds the <code>PPN</code> of the root page of the
                               in-memory page-request-queue used by IOMMU to
                               queue "Page Request" messages. If the base
                               address as determined by <code>PPN</code> is not aligned as
                               required, all entries in the queue appear to an
                               IOMMU as <code>UNSPECIFIED</code> and any address an IOMMU
                               may compute and use for accessing an entry in the
                               queue is also <code>UNSPECIFIED</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">63:54</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In RV32, only the low order 32-bits of the register (22-bit <code>PPN</code> and
5-bit <code>LOG2SZ-1</code>) need to be written.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="PQH"><a class="anchor" href="#PQH"></a>6.13. Page-request-queue head (<code>pqh</code>)</h3>
<div class="paragraph">
<p>This 32-bit register (RW) holds the index into the page-request-queue where
software will fetch the next page-request.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjA20lHIS8xNtVJQz8xLSa1Qr9XhitVRSM7PS8tMt6rOScxLBaoy1FHIKC5ITE61MjQwMqmtBQATKxYy" alt="Page-request-queue head register fields">
</div>
<div class="title">Figure 45. Page-request-queue head register fields</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Bits</th>
<th class="tableblock halign-center valign-top">Field</th>
<th class="tableblock halign-center valign-top">Attribute</th>
<th class="tableblock halign-center valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">31:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>index</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WARL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Holds the <code>index</code> into the page-request-queue from
                            which software reads the next "Page Request" message.
                            Only <code>LOG2SZ-1:0</code> bits are writable.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="PQT"><a class="anchor" href="#PQT"></a>6.14. Page-request-queue tail (<code>pqt</code>)</h3>
<div class="paragraph">
<p>This 32-bit register (RO) holds the index into the page-request-queue
where the IOMMU writes the next page-request.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjA20lHIS8xNtVJQz8xLSa1Qr9XhitVRSM7PS8tMt6rOScxLBaoy1FHIKC5ITE61MjQwMqmtBQATKxYy" alt="Page-request-queue tail register fields">
</div>
<div class="title">Figure 46. Page-request-queue tail register fields</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Bits</th>
<th class="tableblock halign-center valign-top">Field</th>
<th class="tableblock halign-center valign-top">Attribute</th>
<th class="tableblock halign-center valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">31:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>index</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Holds the <code>index</code> into the page-request-queue
                            where IOMMU writes the next "Page Request" message.</p></td>
</tr>
</tbody>
</table>
<div style="page-break-after: always;"></div>
</div>
<div class="sect2">
<h3 id="CSR"><a class="anchor" href="#CSR"></a>6.15. Command-queue CSR (<code>cqcsr</code>)</h3>
<div class="paragraph">
<p>This 32-bit register (RW) is used to control the operations and report the
status of the command-queue.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqNz00KwyAQBeB9TzG7bFwkJWThVUoRY8ZU8CdR01LEu5dQaBFq6Pp782YmeZwpXE4AaVQxUOgIWG6QQiNWtE0mP0lhIcNHPAb0d5xqg6uRNTITi-4AldYVlWgFsgdTSxHo_7_K1T4dt_AsqT1u_S4VW4jO7HglIJyVaqZJc4vv1C0sXCDt2nOf8wsKInbr" alt="Command-queue CSR register fields">
</div>
<div class="title">Figure 47. Command-queue CSR register fields</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Bits</th>
<th class="tableblock halign-center valign-top">Field</th>
<th class="tableblock halign-center valign-top">Attribute</th>
<th class="tableblock halign-center valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cqen</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RW</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The command-queue-enable bit enables the command-
                            queue when set to 1.<br>
                                                                             <br>
                            Changing <code>cqen</code> from 0 to 1 sets the <code>cqh</code>
                            register and the <code>cqcsr</code> bits <code>cmd_ill</code>,<code>cmd_to</code>,
                            <code>cqmf</code>, <code>fence_w_ip</code> to 0. The command-queue may
                            take some time to be active following setting the
                            <code>cqen</code> to 1. During this delay the <code>busy</code> bit is 1.
                            When the command queue is active, the <code>cqon</code> bit
                            reads 1. <br>
                                                                             <br>
                            When <code>cqen</code> is changed from 1 to 0, the command
                            queue may stay active (with <code>busy</code> asserted) until
                            the commands already fetched from the command-queue
                            are being processed and/or there are outstanding
                            implicit loads from the command-queue.  When the
                            command-queue turns off the <code>cqon</code> bit reads 0.
                                                                             <br>
                            When the <code>cqon</code> bit reads 0, the IOMMU guarantees
                            that no implicit memory accesses to the command
                            queue are in-flight and the command-queue will not
                            generate new implicit loads to the queue memory.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cie</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RW</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Command-queue-interrupt-enable bit enables
                            generation of interrupts from command-queue when
                            set to 1.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7:2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cqmf</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RW1C</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If command-queue access to fetch a command or a
                            memory access made by a command leads to a memory
                            fault, then the command-queue-memory-fault bit is set
                            to 1, and the command-queue stalls until this bit is
                            cleared. To re-enable command processing, software
                            should clear this bit by writing 1.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cmd_to</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RW1C</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If the execution of a command leads to a
                            timeout (e.g. a command to invalidate device ATC
                            may timeout waiting for a completion), then the
                            command-queue sets the <code>cmd_to</code> bit and stops
                            processing from the command-queue. To re-enable
                            command processing, software should clear this bit
                            by writing 1.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cmd_ill</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RW1C</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If an illegal or unsupported command is fetched and
                            decoded by the command-queue then the command-queue
                            sets the <code>cmd_ill</code> bit and stops processing from the
                            command-queue. To re-enable command processing
                            software should clear this bit by writing 1.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">11</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fence_w_ip</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RW1C</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An IOMMU that supports wire-signaled-interrupts
                            sets the <code>fence_w_ip</code> bit to indicate completion
                            of an <code>IOFENCE.C</code> command.
                            To re-enable interrupts on <code>IOFENCE.C</code> completion,
                            software should clear this bit by writing 1.
                            This bit is reserved if the IOMMU does not support
                            wire-signaled-interrupts or wire-signaled-interrupts
                            are not enabled (i.e., <code>fctl.WSI == 0</code>).</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">15:12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cqon</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The command-queue is active if <code>cqon</code> is 1.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">17</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>busy</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A write to <code>cqcsr</code> may require the IOMMU to perform
                            many operations that may not occur synchronously
                            to the write. When a write is observed by the
                            <code>cqcsr</code>, the <code>busy</code> bit is set to 1.<br>
                                                                              <br>
                            When the <code>busy</code> bit is 1, behavior of additional
                            writes to the <code>cqcsr</code> is <code>UNSPECIFIED</code>.
                            Some implementations may ignore the second write and
                            others may perform the actions determined by the
                            second write.<br>
                                                                              <br>
                            Software must verify that the busy bit is 0 before
                            writing to the <code>cqcsr</code>.<br>
                                                                              <br>
                            An IOMMU that can complete these operations
                            synchronously may hard-wire this bit to 0.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">27:18</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">31:28</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">custom</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Designated for custom use.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>When <code>cmd_ill</code> or <code>cqmf</code> is 1 in <code>cqcsr</code>, the <code>cqh</code> references the command in the
CQ that caused the error. Previous commands may have completed, timed out, or
their execution aborted by the IOMMU.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If software makes the CQ operational again after a <code>cmd_ill</code> or <code>cqmf</code> error,
then software should resubmit the commands submitted since the last <code>IOFENCE.C</code>
that successfully completed.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>cmd_to</code> bit is set when a <code>IOFENCE.C</code> command detects that one or more
previous commands that are specified to have timeouts have timed out but all
other commands previous to the <code>IOFENCE.C</code> have completed. When <code>cmd_to</code> is 1,
<code>cqh</code> references the <code>IOFENCE.C</code> command that detected the timeout.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Command-queue being empty does not imply that all commands fetched from the
command-queue have been completed. When the command-queue is requested to be
disabled, an implementation may either complete the already fetched commands
or abort execution of those commands. Software must use an <code>IOFENCE.C</code> command
to wait for all previous commands to be committed, if so desired, before
turning off the command-queue.</p>
</div>
</td>
</tr>
</table>
</div>
<div style="page-break-after: always;"></div>
</div>
<div class="sect2">
<h3 id="FQCSR"><a class="anchor" href="#FQCSR"></a>6.16. Fault queue CSR (<code>fqcsr</code>)</h3>
<div class="paragraph">
<p>This 32-bit register (RW) is used to control the operations and report the
status of the fault-queue.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjDUUchLzE21UlBPK0zNU6_VwSqVmYoiYwaXKUotTi0qS03BpbEwNw2nVH4auYbm43JoUmlxJaqUAX5TTeDSyaXFJfm5IMlYHYXk_Ly0zHSr6pzEvFSIqozigsTkVCtDAyOT2loATzNizA==" alt="Fault queue CSR register fields">
</div>
<div class="title">Figure 48. Fault queue CSR register fields</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Bits</th>
<th class="tableblock halign-center valign-top">Field</th>
<th class="tableblock halign-center valign-top">Attribute</th>
<th class="tableblock halign-center valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fqen</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RW</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The fault-queue enable bit enables the fault-queue
                           when set to 1.<br>
                                                                              <br>
                           Changing <code>fqen</code> from 0 to 1 sets the <code>fqt</code>
                           register and the <code>fqcsr</code> bits <code>fqof</code> and <code>fqmf</code>
                           to 0. The fault-queue may take some time to be active
                           following setting the <code>fqen</code> to 1. During this delay
                           the <code>busy</code> bit is 1. When the fault queue is active,
                           the <code>fqon</code> bit reads 1.<br>
                                                                              <br>
                           When <code>fqen</code> is changed from 1 to 0, the fault-queue
                           may stay active (with <code>busy</code> asserted) until in-flight
                           fault-recording is completed. When the fault-queue is
                           off the <code>fqon</code> bit reads 0.
                                                                              <br>
                           When <code>fqon</code> reads 0, the IOMMU guarantees that there
                           are no in-flight implicit writes to the fault-queue
                           in progress and that no new fault records will be
                           written to the fault-queue.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fie</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RW</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fault queue interrupt enable bit enables generation
                           of interrupts from fault-queue when set to 1.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7:2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fqmf</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RW1C</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The <code>fqmf</code> bit is set to 1 if the IOMMU encounters
                           an access fault when storing a fault record to the
                           fault queue. The fault-record that was attempted to
                           be written is discarded and no more fault records
                           are generated until software clears the <code>fqmf</code> bit by
                           writing 1 to the bit.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fqof</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RW1C</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The fault-queue-overflow bit is set to 1 if the
                           IOMMU needs to queue a fault record but the
                           fault-queue is full (i.e., <code>fqt == fqh - 1</code>).<br>
                                                                              <br>
                           The fault-record is discarded and no more fault
                           records are generated until software clears <code>fqof</code>
                           by writing 1 to the bit.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">15:10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>reserved</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fqon</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The fault-queue is active if <code>fqon</code> reads 1.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">17</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>busy</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Write to <code>fqcsr</code> may require the IOMMU to perform
                           many operations that may not occur synchronously to
                           the write.
                           When a write is observed by the fqcsr, the <code>busy</code>
                           bit is set to 1. When the <code>busy</code> bit is 1, behavior
                           of additional writes to the <code>fqcsr</code> are
                           <code>UNSPECIFIED</code>. Some implementations may
                           ignore the second write and others may perform the
                           actions determined by the second write.<br>
                                                                              <br>
                           Software should ensure that the <code>busy</code> bit is 0
                           before writing to the <code>fqcsr</code>.<br>
                                                                              <br>
                           An IOMMU that can complete controls synchronously
                           may hard-wire this bit to 0.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">27:18</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">31:28</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">custom</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Designated for custom use.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="PQCSR"><a class="anchor" href="#PQCSR"></a>6.17. Page-request-queue CSR (<code>pqcsr</code>)</h3>
<div class="paragraph">
<p>This 32-bit register (RW) is used to control the operations and report the
status of the page-request-queue.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjDUUchLzE21UlAvKEzNU6_VwSqVmYoiYwaXKUotTi0qS03BpbEwNw2nVH4auYbm43JoUmlxJaqUAX5TTeDSzqXFJfm5CqXFYK_G6igk5-elZaZbVeck5qVCVGYUFyQmp1oZGhiZ1NYCAAmZZEs=" alt="Page-request-queue CSR register fields">
</div>
<div class="title">Figure 49. Page-request-queue CSR register fields</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Bits</th>
<th class="tableblock halign-center valign-top">Field</th>
<th class="tableblock halign-center valign-top">Attribute</th>
<th class="tableblock halign-center valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pqen</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RW</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The page-request-enable bit enables the
                              page-request-queue when set to 1.<br>
                                                                              <br>
                              Changing <code>pqen</code> from 0 to 1, sets the <code>pqt</code>
                              register and the <code>pqcsr</code> bits <code>pqmf</code> and <code>pqof</code>
                              to 0. The page-request-queue may take some time
                              to be active following setting the <code>pqen</code> to 1.
                              During this delay the <code>busy</code> bit is 1. When the
                              page-request-queue is active, the <code>pqon</code> bit
                              reads 1.<br>
                                                                              <br>
                              When <code>pqen</code> is changed from 1 to 0, the
                              page-request-queue may stay active  (with <code>busy</code>
                              asserted) until in-flight page-request writes are
                              completed. When the page-request-queue turns off,
                              the <code>pqon</code> bit reads 0.<br>
                                                                              <br>
                              When <code>pqon</code> reads 0, the IOMMU guarantees that
                              there are no older in-flight implicit writes to
                              the queue memory and no further implicit writes
                              will be generated to the queue memory.<br>
                                                                              <br>
                              The IOMMU may respond to “Page Request” messages
                              received when page-request-queue is off or in
                              the process of being turned off, as specified in
                              <a href="#ATS_PRI">Section 3.7</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pie</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RW</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The page-request-queue-interrupt-enable
                              bit when set to 1, enables generation of
                              interrupts from page-request-queue.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7:2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pqmf</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RW1C</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The <code>pqmf</code> bit is set to 1 if the IOMMU
                              encounters an access fault when storing a
                              "Page Request" message to the page-request-queue.<br>
                                                                              <br>
                              The "Page Request" message that caused the <code>pqmf</code>
                              or <code>pqof</code> error and all subsequent "Page Request"
                              messages are discarded until software clears the
                              <code>pqof</code> and/or <code>pqmf</code> bits by writing 1 to it.<br>
                                                                              <br>
                              The IOMMU may respond to “Page Request” messages
                              that caused the <code>pqof</code> or <code>pqmf</code> bit to be set
                              and all subsequent “Page Request” messages
                              received while these bits are 1 as specified in
                              <a href="#ATS_PRI">Section 3.7</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pqof</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RW1C</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The page-request-queue-overflow bit is set to 1
                              if the page-request queue overflows i.e. IOMMU
                              needs to queue a "Page Request" message but the
                              page-request queue is full
                              (i.e., <code>pqt == pqh - 1</code>).<br>
                                                                              <br>
                              The "Page Request" message that caused the <code>pqmf</code>
                              or <code>pqof</code> error and all subsequent "Page Request"
                              messages are discarded until software clears the
                              <code>pqof</code> and/or <code>pqmf</code> bits by writing 1 to it.<br>
                                                                              <br>
                              The IOMMU may respond to “Page Request” messages
                              that caused the <code>pqof</code> or <code>pqmf</code> bit to be set
                              and all subsequent “Page Request” messages
                              received while these bits are 1 as specified in
                              <a href="#ATS_PRI">Section 3.7</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">15:10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pqon</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The page-request is active when <code>pqon</code> reads 1.<br></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">17</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>busy</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A write to <code>pqcsr</code> may require the IOMMU to
                              perform many operations that may not occur
                              synchronously to the write. When a write is
                              observed by the <code>pqcsr</code>, the <code>busy</code> bit is set
                              to 1.<br>
                                                                              <br>
                              When the <code>busy</code> bit is 1, behavior of additional
                              writes to the <code>pqcsr</code> are <code>UNSPECIFIED</code>.
                              Some implementations may ignore the second write
                              and others may perform the actions determined by
                              the second write. Software should ensure that the
                              <code>busy</code> bit is 0 before writing to the <code>pqcsr</code>.<br>
                                                                              <br>
                              An IOMMU that can complete controls synchronously
                              may hard-wire this bit to 0</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">27:18</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">31:28</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">custom</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Designated for custom use.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="IPSR"><a class="anchor" href="#IPSR"></a>6.18. Interrupt pending status register (<code>ipsr</code>)</h3>
<div class="paragraph">
<p>This 32-bit register (RW1C) reports the pending interrupts which require
software service. Each interrupt-pending bit in the register corresponds to
a interrupt source in the IOMMU. The interrupt-pending bit in the register once
set to 1 stays 1 till software clears that interrupt-pending bit by writing 1 to
clear it.</p>
</div>
<div class="paragraph">
<p>When <code>fctl.WSI</code> is 1, the interrupt-pending bit drives the wire selected by
the corresponding <code>icvec</code> field to signal an interrupt.</p>
</div>
<div class="paragraph">
<p>When <code>fctl.WSI</code> is 0, the IOMMU signals interrupts using messages. MSI have edge
semantics and an interrupt message is generated when an interrupt-pending bit
transitions from 0 to 1. The address and data for the message are obtained from
the <code>msi_cfg_tbl</code> entry selected by the <code>icvec</code> field corresponding to the
interrupt-pending bit.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjDUUchLzE21UlBPzixQr9XBJpOGU6YgF7cUmowJXKYotTi1qCw1BUXaAuGO0uKS_FxUU82wao7VUUjOz0vLTLeqzknMSwUqNNJRyCguSExOtTI0MDKprQUATOJIfA==" alt="Interrupt pending status register fields">
</div>
<div class="title">Figure 50. Interrupt pending status register fields</div>
</div>
<table id="IPSR_FIELD" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 14. Interrupt pending status register fields</caption>
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Bits</th>
<th class="tableblock halign-center valign-top">Field</th>
<th class="tableblock halign-center valign-top">Attribute</th>
<th class="tableblock halign-center valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cip</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RW1C</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The command-queue-interrupt-pending bit is set to
                              1 if <code>cqcsr.cie</code> is 1 and any of the following are
                              true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>cqcsr.fence_w_ip</code> is 1.</p>
</li>
<li>
<p><code>cqcsr.cmd_ill</code> is 1.</p>
</li>
<li>
<p><code>cqcsr.cmd_to</code> is 1.</p>
</li>
<li>
<p><code>cqcsr.cqmf</code> is 1.</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fip</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RW1C</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The fault-queue-interrupt-pending bit is set to 1
                              if <code>fqcsr.fie</code> is 1 and any of the following are
                              true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>fqcsr.fqof</code> is 1.</p>
</li>
<li>
<p><code>fqcsr.fqmf</code> is 1.</p>
</li>
<li>
<p>A new record is produced in the FQ.</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pmip</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RW1C</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The performance-monitoring-interrupt-pending is
                              set to 1 when <code>OF</code> bit in <code>iohpmcycles</code> or in any of the
                              <code>iohpmctr1-31</code> registers transitions from 0 to 1.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pip</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RW1C</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The page-request-queue-interrupt-pending is set to
                              1 if <code>pqcsr.pie</code> is 1 and any of the following are
                              true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>pqcsr.pqof</code> is 1.</p>
</li>
<li>
<p><code>pqcsr.pqmf</code> is 1.</p>
</li>
<li>
<p>A new message is produced in the PQ.</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7:4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">15:8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">custom</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Designated for custom use.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">31:16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>If a bit in <code>ipsr</code> is 1 then a write of 1 to the bit transitions the bit from 1&#8594;0.
If the conditions to set that bit are still present (See <a href="#IPSR_FIELD">Table 14</a>) or if
they occur after the bit is cleared then that bit transitions again from 0&#8594;1.</p>
</div>
<div style="page-break-after: always;"></div>
</div>
<div class="sect2">
<h3 id="OVF"><a class="anchor" href="#OVF"></a>6.19. Performance-monitoring counter overflow status (<code>iocountovf</code>)</h3>
<div class="paragraph">
<p>The performance-monitoring counter overflow status is a 32-bit read-only
register that contains shadow copies of the OF bits in the <code>iohpmevt1-31</code>
registers - where <code>iocountovf</code> bit X corresponds to <code>iohpmevtX</code> and bit 0
corresponds to the <code>OF</code> bit of <code>iohpmcycles</code>.</p>
</div>
<div class="paragraph">
<p>This register enables overflow interrupt handler software to quickly and easily
determine which counter(s) have overflowed.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UlAw1FHIS8xNtVJQd45Ur9VByBgjZDwCfEFSsToKyfl5aZnpVtU5iXmpQDVAJRnFBYnJqVaGBkYmtbUAHjYb-g==" alt="Performance-monitoring counter overflow status register fields">
</div>
<div class="title">Figure 51. Performance-monitoring counter overflow status register fields</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Bits</th>
<th class="tableblock halign-center valign-top">Field</th>
<th class="tableblock halign-center valign-top">Attribute</th>
<th class="tableblock halign-center valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CY</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Shadow of <code>iohpmcycles.OF</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">31:1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HPM</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Shadow of <code>iohpmevt[1-31].OF</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="INH"><a class="anchor" href="#INH"></a>6.20. Performance-monitoring counter inhibits (<code>iocountinh</code>)</h3>
<div class="paragraph">
<p>The performance-monitoring counter inhibits is a 32-bit WARL register
that contains bits to inhibit the corresponding counters from counting. Bit X
when set inhibits counting in <code>iohpmctrX</code> and bit 0 inhibits counting in
<code>iohpmcycles</code>.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UlAw1FHIS8xNtVJQd45Ur9VByBgjZDwCfEFSsToKyfl5aZnpVtU5iXmpQDVAJRnFBYnJqVaGBkYmtbUAHjYb-g==" alt="Performance-monitoring counter inhibits register fields">
</div>
<div class="title">Figure 52. Performance-monitoring counter inhibits register fields</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Bits</th>
<th class="tableblock halign-center valign-top">Field</th>
<th class="tableblock halign-center valign-top">Attribute</th>
<th class="tableblock halign-center valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CY</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RW</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When set, <code>iohpmcycles</code> counter is inhibited
                              from counting.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">31:1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HPM</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WARL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When bit X is set, then counting of events in
                              <code>iohpmctrX</code> is inhibited.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When the <code>iohpmcycles</code> counter is not needed, it is desirable to conditionally
inhibit it to reduce energy consumption. Providing a single register to
inhibit all counters allows a) one or more counters to be atomically programmed
with events to count b) one or more counters to be sampled atomically.</p>
</div>
<div class="paragraph">
<p>To initialize an event counter or the cycles counter to a desired value, it
should be first inhibited if it is enabled to count. This measure ensures that
it does not count during the update process. The inhibition should be removed
after the register has been programmed with the desired value.</p>
</div>
</td>
</tr>
</table>
</div>
<div style="page-break-after: always;"></div>
</div>
<div class="sect2">
<h3 id="CYC"><a class="anchor" href="#CYC"></a>6.21. Performance-monitoring cycles counter (<code>iohpmcycles</code>)</h3>
<div class="paragraph">
<p>This 64-bit register is a free running clock cycle counter.
There is no associated <code>iohpmevt0</code>.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjAz1lHIS8xNtVJQT84vzStJLVKv1UFIG8Jl_d1AErE6Csn5eWmZ6VbVOYl5qUAVRjoKGcUFicmpVoYGRia1tQC9SB30" alt="Performance-monitoring cycles counter register fields">
</div>
<div class="title">Figure 53. Performance-monitoring cycles counter register fields</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Bits</th>
<th class="tableblock halign-center valign-top">Field</th>
<th class="tableblock halign-center valign-top">Attribute</th>
<th class="tableblock halign-center valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">62:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>counter</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WARL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cycles counter value.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">63</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>OF</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RW</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Overflow</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The <code>OF</code> bit is set when the <code>iohpmcycles</code> counter overflows, and remains set
until cleared by software. Since <code>iohpmcycles</code> value is an unsigned value,
overflow is defined as unsigned overflow. Note that there is no loss of
information after an overflow since the counter wraps around and keeps counting
while the sticky <code>OF</code> bit remains set.</p>
</div>
<div class="paragraph">
<p>If the <code>iohpmcycles</code> counter overflows when the <code>OF</code> bit is zero, then a HPM
Counter Overflow interrupt is generated by setting <code>ipsr.pmip</code> bit to 1. If
the <code>OF</code> bit is already one, then no interrupt request is generated. Consequently
the <code>OF</code> bit also functions as a count overflow interrupt disable for the
<code>iohpmcycles</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="CTR"><a class="anchor" href="#CTR"></a>6.22. Performance-monitoring event counters (<code>iohpmctr1-31</code>)</h3>
<div class="paragraph">
<p>These registers are 64-bit WARL counter registers.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjAz0VHIS8xNtVJQT84vzStJLVKv1eGK1VFIzs9Ly0y3qs5JzEsFqjPUUcgoLkhMTrUyNDAyqa0FAEyMFx8=" alt="Performance-monitoring event counters register fields">
</div>
<div class="title">Figure 54. Performance-monitoring event counters register fields</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Bits</th>
<th class="tableblock halign-center valign-top">Field</th>
<th class="tableblock halign-center valign-top">Attribute</th>
<th class="tableblock halign-center valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">63:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>counter</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WARL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Event counter value.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="EVT"><a class="anchor" href="#EVT"></a>6.23. Performance-monitoring event selectors (<code>iohpmevt1-31</code>)</h3>
<div class="paragraph">
<p>These performance-monitoring event registers are 64-bit RW registers. When a
transaction processed by the IOMMU causes an event that is programmed to count
in a counter then the counter is incremented. In addition to matching events,
the event selector may be programmed with additional filters based on
<code>device_id</code>, <code>process_id</code>, <code>GSCID</code>, and <code>PSCID</code> such that the counter is
incremented conditionally based on the transaction matching these additional
filters. When such <code>device_id</code> based filtering is used, the match may be
configured to be a precise match or a partial match. A partial match allows
transactions with a range of IDs to be counted by the counter.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjA01VHIS8xNtVJQTy1LzSvxdFGv1UGShsu6-DoGe6PIGRnAJQM8XeIDgp3RNBuZIHQDFbhjKECYHhAG0h-Gy-4wkGZcsp4uIThk_N1AErE6Csn5eWmZ6VbVOYl5qUAVFjoKGcUFicmpVoYGRia1tQAQVU-T" alt="Performance-monitoring event selector register fields">
</div>
<div class="title">Figure 55. Performance-monitoring event selector register fields</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 22.2222%;">
<col style="width: 11.1111%;">
<col style="width: 55.5556%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Bits</th>
<th class="tableblock halign-center valign-top">Field</th>
<th class="tableblock halign-center valign-top">Attribute</th>
<th class="tableblock halign-center valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">14:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>eventID</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WARL</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Indicates the event to count. A value of 0
                                 indicates no events are counted.<br>
                                 Encodings 1 to 16383 are reserved for standard
                                 events defined in the <a href="#Event_list">Table 17</a>.<br>
                                 Encodings 16384 to 32767 are for designated for
                                 custom use.<br>
                                 When <code>eventID</code> is changed, including to 0,
                                 the counter retains its value.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">15</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DMASK</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RW</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When set to 1, partial matching of the
                                 <code>DID_GSCID</code> is performed for the transaction.
                                 The lower bits of the <code>DID_GSCID</code> all the way
                                 to the first low order 0 bit (including
                                 the 0 bit position itself) are masked.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">35:16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PID_PSCID</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RW</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>process_id</code> if <code>IDT</code> is 0,
                                 <code>PSCID</code> if <code>IDT</code> is 1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">59:36</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DID_GSCID</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RW</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>device_id</code> if <code>IDT</code> is 0,
                                 <code>GSCID</code> if <code>IDT</code> is 1.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">60</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PV_PSCV</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RW</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If set, only transactions with matching
                                 <code>process_id</code> or <code>PSCID</code> (based on the Filter
                                 ID Type) are counted.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">61</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DV_GSCV</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RW</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If set, only transactions with matching
                                 <code>device_id</code> or <code>GSCID</code> (based on the Filter ID
                                 Type) are counted.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">62</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IDT</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RW</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Filter ID Type: This field indicates the type
                                 of ID to filter on. When 0, the <code>DID_GSCID</code>
                                 field holds a <code>device_id</code> and the <code>PID_PSCID</code>
                                 field holds a <code>process_id</code>. When 1, the
                                 <code>DID_GSCID</code> field holds a <code>GSCID</code> and
                                 <code>PID_PSCID</code> field holds a <code>PSCID</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">63</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>OF</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RW</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Overflow status or Interrupt disable</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The table below summarizes the filtering option for events that support
filtering by IDs.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 15. filtering options</caption>
<colgroup>
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 62.5%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top"><strong><code>IDT</code></strong></th>
<th class="tableblock halign-left valign-top"><strong><code>DV_GSCV</code></strong></th>
<th class="tableblock halign-left valign-top"><strong><code>PV_PSCV</code></strong></th>
<th class="tableblock halign-left valign-top"><strong>Operation</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0/1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Counter increments. No ID based
                                        filtering.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If the transaction has a valid
                                        <code>process_id</code>, counter increments if
                                        process_id matches <code>PID_PSCID</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Counter increments if <code>device_id</code>
                                        matches <code>DID_GSCID</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If the transaction has a valid
                                        <code>process_id</code>, counter increments if
                                        <code>device_id</code> matches <code>DID_GSCID</code> and
                                        <code>process_id</code> matches <code>PID_PSCID</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If the transaction has a valid
                                        <code>PSCID</code>, counter increments if
                                        the <code>PSCID</code> of that process matches
                                        <code>PID_PSCID</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Counter increments if <code>GSCID</code> is valid
                                        and matches <code>DID_GSCID</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Counter increments if <code>GSCID</code> is valid
                                        and matches <code>DID_GSCID</code> and if <code>PSCID</code>
                                        is valid and matches <code>PID_PSCID</code>.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>When filtering by <code>device_id</code> or <code>GSCID</code> is selected and the event supports
ID based filtering, the DMASK field can be used to configure a partial match.
When DMASK is set to 1, partial matching of the <code>DID_GSCID</code> is performed for
the transaction. The lower bits of the <code>DID_GSCID</code> all the way to the first
low order 0 bit (including the 0 bit position itself) are masked.</p>
</div>
<div class="paragraph">
<p>The following example illustrates the use of DMASK and filtering by <code>device_id</code>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 16. <code>DMASK</code> with <code>IDT</code> set to <code>device_id</code> based filtering</caption>
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 42.8571%;">
<col style="width: 42.8572%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top"><code>DMASK</code></th>
<th class="tableblock halign-left valign-top"><code>DID_GSCID</code></th>
<th class="tableblock halign-left valign-top"><strong>Comment</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>yyyyyyyy  yyyyyyyy  yyyyyyyy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">One specific seg:bus:dev:func</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>yyyyyyyy  yyyyyyyy  yyyyy011</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">seg:bus:dev - any func</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>yyyyyyyy  yyyyyyyy  01111111</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">seg:bus - any dev:func</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>yyyyyyyy  01111111  11111111</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">seg - any bus:dev:func</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The following table lists the standard events that can be counted:</p>
</div>
<table id="Event_list" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 17. Standard Events list</caption>
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 42.8571%;">
<col style="width: 42.8572%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top"><strong>eventID</strong></th>
<th class="tableblock halign-left valign-top"><strong>Event counted</strong></th>
<th class="tableblock halign-center valign-top"><strong>IDT settings supported</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Do not count</p></td>
<td class="tableblock halign-center valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Untranslated requests</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Translated requests</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ATS Translation requests</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TLB miss</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0/1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Device Directory Walks</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Process Directory Walks</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">First-stage Page Table Walks</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0/1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Second-stage Page Table Walks</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">0/1</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">9 - 16383</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved for future standard</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>When the programmed <code>IDT</code> setting is not supported for an event then the
associated counter does not increment.</p>
</div>
<div class="paragraph">
<p>The <code>OF</code> bit is set when the corresponding <code>iohpmctr1-31</code> counter overflows,
and remains set until cleared by software. Since <code>iohpmctr1-31</code> values are
unsigned values, overflow is defined as unsigned overflow. Note that there is no
loss of information after an overflow since the counter wraps around and keeps
counting while the sticky <code>OF</code> bit remains set.</p>
</div>
<div class="paragraph">
<p>If a <code>iohpmctr1-31</code> counter overflows when the associated <code>OF</code> bit is zero, then
a HPM Counter Overflow interrupt is generated by setting <code>ipsr.pmip</code> bit to 1. If
the <code>OF</code> bit is already one, then no interrupt request is generated. Consequently
the <code>OF</code> bit also functions as a count overflow interrupt disable for the
associated <code>iohpmctr1-31</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>There are not separate overflow status and overflow interrupt enable bits. In
practice, enabling overflow interrupt generation (by clearing the <code>OF</code> bit) is
done in conjunction with initializing the counter to a starting value. Once a
counter has overflowed, it and the <code>OF</code> bit must be reinitialized before
another overflow interrupt can be generated.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In RV32, memory-mapped writes to <code>iohpmevt1-31</code> modify only one 32-bit part of
the register. The following sequence may be used to update the register without
counting events spuriously due to the intermediate value of the register:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Write the low order 32-bits to set <code>eventID</code> to 0.</p>
</li>
<li>
<p>Write the high order 32-bits with the new desired values.</p>
</li>
<li>
<p>Write the low order 32-bits the new desired values, including that of the
<code>eventID</code> field.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Alternatively, the counter may first be inhibited such that no events count
during the update and the inhibit removed after the register has been programmed
with the desired value.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If <code>capabilities.HPM</code> is 1 then a minimum of one programmable event counter
besides the cycles counter is required to comply with this specification. One
counter may be used in a time multiplexed manner to sample events but such
analysis may take longer to complete. The IOMMU, unlike the CPU MMU, services
multiple streams of IO and the HPM may be used by a performance analyst to
analyze one or more of those streams concurrently. Typically, a performance
analyst may require four programmable counters to count events for an IO
stream. To support concurrent analysis of at least two streams of IO it is
recommended to support seven programmable counters.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="TRR_IOVA"><a class="anchor" href="#TRR_IOVA"></a>6.24. Translation-request IOVA (<code>tr_req_iova</code>)</h3>
<div class="paragraph">
<p>The <code>tr_req_iova</code> is a 64-bit register used to implement a
translation-request interface for debug. This register is present when
<code>capabilities.DBG == 1</code>.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjA00lHIS8xNtVJQL0otTi0qS01Rr9VByJsi5MsK8kBSsToKyfl5aZnpVtU5iXmpQDVAJRnFBYnJqVaGBkYmtbUAKHEfQw==" alt="Translation-request IOVA register fields">
</div>
<div class="title">Figure 56. Translation-request IOVA register fields</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Bits</th>
<th class="tableblock halign-center valign-top">Field</th>
<th class="tableblock halign-center valign-top">Attribute</th>
<th class="tableblock halign-center valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">11:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">63:12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>vpn</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WARL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The IOVA virtual page number</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="TRR_CTRL"><a class="anchor" href="#TRR_CTRL"></a>6.25. Translation-request control (<code>tr_req_ctl</code>)</h3>
<div class="paragraph">
<p>The <code>tr_req_ctl</code> is a 64-bit WARL register used to implement a
translation-request interface for debug. This register is present when
<code>capabilities.DBG == 1</code>.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjDUUchLzE21UlB3z9d3Ki2uVK_VwSYbUJRZhkPKtSIVh4xfOIqEBVyiKLU4tagsNQVF2sgAYZunCy53hKFIGOM30gQunVxaXJKfi2ofQtYFYl-sjkJyfl5aZrpVdU5iXirEgIzigsTkVCtDAyOT2loAjD9eOg==" alt="Translation-request control register fields">
</div>
<div class="title">Figure 57. Translation-request control register fields</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Bits</th>
<th class="tableblock halign-center valign-top">Field</th>
<th class="tableblock halign-center valign-top">Attribute</th>
<th class="tableblock halign-center valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Go/Busy</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RW1S</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This bit is set to indicate a valid
                                 request has been setup in the
                                 <code>tr_req_iova/tr_req_ctl</code> registers
                                 for the IOMMU to translate.<br>
                                                                              <br>
                                 The IOMMU indicates completion of the
                                 requested translation by clearing this
                                 bit to 0. On completion, the results
                                 of the translation are in the <code>tr_response</code>
                                 register.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Priv</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WARL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If set to 1, Privileged Mode access
                                 is requested else no Privileged Mode access
                                 is not requested.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Exe</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WARL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If set to 1, execute permission is
                                 requested else execute permission is not
                                 requested.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NW</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WARL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If set to 1, read permission is requested.
                                 If set to 0, both read and write permissions
                                 are requested.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">11:4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">31:12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PID</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WARL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If <code>PV</code> is 1, this field provides the
                                 <code>process_id</code> input for this translation request.
                                 If <code>PV</code> is 0 then this field is not used.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PV</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WARL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If set to 1, the <code>PID</code> field of the
                                 register is valid and provides the <code>process_id</code>
                                 for this translation request. If set to 0 then
                                 the <code>PID</code> field is not used and a <code>process_id</code>
                                 is not valid for this translation request.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">35:33</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">39:36</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>custom</p>
</div></div></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Designated for custom use.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">63:40</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DID</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WARL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This field provides the <code>device_id</code> for
                                 this translation request.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In RV32, the high half of the register should be written first, followed by the
low half, which includes the <code>Go/Busy</code> bit, to initiate a translation.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="TRR_RSP"><a class="anchor" href="#TRR_RSP"></a>6.26. Translation-response (<code>tr_response</code>)</h3>
<div class="paragraph">
<p>The <code>tr_response</code> is a 64-bit RO register used to hold the results
of a translation requested using the translation-request interface.
This register is present when <code>capabilities.DBG == 1</code>.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjDUUchLzE21UlBPSyzNKVGv1UHImcHlilKLU4vKUlNQpI3g0gFOviEoUghTg1HETUwQegL8SLEMoTG5tLgkPxckGaujkJyfl5aZblWdk5iXClGVUVyQmJxqZWhgZFJbCwAkvEeZ" alt="Translation-response register fields">
</div>
<div class="title">Figure 58. Translation-response register fields</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Bits</th>
<th class="tableblock halign-center valign-top">Field</th>
<th class="tableblock halign-center valign-top">Attribute</th>
<th class="tableblock halign-center valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fault</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If the process to translate the IOVA detects
                                 a fault then the <code>fault</code> field is set to 1.
                                 The detected fault may be reported through the
                                 fault-queue.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">6:1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">8:7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PBMT</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Memory type determined for the translation
                                 using the PBMT fields in the first-stage and/or
                                 the second-stage page tables used for the
                                 translation. This value of this field is
                                 <code>UNSPECIFIED</code> if the <code>fault</code> field is 1.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>S</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Translation range size field, when set to 1
                                 indicates that the translation applies to a
                                 range that is larger than 4 KiB and the size
                                 of the translation range is encoded in the
                                 <code>PPN</code> field. The value of this field is
                                 <code>UNSPECIFIED</code> if the <code>fault</code> field is 1.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">53:10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PPN</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>If the <code>fault</code> bit is 0, then this field
                                 provides the PPN determined as a result of
                                 translating the <code>vpn</code> in <code>tr_req_iova</code>.<br>
<br>
                                 If the <code>fault</code> bit is 1, then the value of
                                 this field is <code>UNSPECIFIED</code>.<br>
<br>
                                 If the <code>S</code> bit is 0, then the size of the
                                 translation is 4 KiB - a page.<br>
<br>
                                 If the <code>S</code> bit is 1, then the translation
                                 resulted in a superpage, and the size of the
                                 superpage is encoded in the PPN itself. If
                                 scanning from bit position 0 to bit position
                                 43, the first bit with a value of 0 at
                                 position <code>X</code>, then the superpage size is
                                <code>2<sup>X+1</sup> * 4</code> KiB.<br>
<br>
                                 If <code>X</code> is not 0, then all bits at position 0
                                 through <code>X-1</code> are each encoded with a value
                                 of 1.
<br></p>
</div>
<table class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 18. Example of encoding of super page size in <code>PPN</code></caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top"><code>PPN</code></th>
<th class="tableblock halign-center valign-top"><code>S</code></th>
<th class="tableblock halign-center valign-top">Size</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>yyyy&#8230;&#8203;.yyyy yyyy yyyy</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 KiB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>yyyy&#8230;&#8203;.yyyy yyyy 0111</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">64 KiB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>yyyy&#8230;&#8203;.yyy0 1111 1111</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2 MiB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>yyyy&#8230;&#8203;.yy01 1111 1111</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 MiB</p></td>
</tr>
</tbody>
</table></div></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">59:54</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">63:60</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>custom</p>
</div></div></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Designated for custom use.</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>An IOMMU implementation is not required to report a superpage translation
or support reporting all possible superpage sizes. An implementation is
allowed to report a 4 KiB translation corresponding to the requested
<code>vpn</code> or report a translation size that is smaller than the superpage
size configured in the page tables.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="IOQOSID"><a class="anchor" href="#IOQOSID"></a>6.27. IOMMU QoS ID (<code>iommu_qosid</code>)</h3>
<div class="paragraph">
<p>The <code>iommu_qosid</code> register fields are defined as follows:</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjA00lHIS8xNtVJQD3L2dFGv1UHIKZjA5cIDgjxR5JD0-RKhL1ZHITk_Ly0z3ao6JzEvFWSAjkJGcUFicqqVoYGRSW0tABHXLBM=" alt="`iommu_qosid` register fields">
</div>
<div class="title">Figure 59. <code>iommu_qosid</code> register fields</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 22.2222%;">
<col style="width: 11.1111%;">
<col style="width: 55.5556%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Bits</th>
<th class="tableblock halign-left valign-top">Field</th>
<th class="tableblock halign-center valign-top">Attribute</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">11:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RCID</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WARL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RCID</code> for IOMMU-initiated requests.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">15:12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">27:16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MCID</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WARL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MCID</code> for IOMMU-initiated requests.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">31:28</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>IOMMU-initiated requests for accessing the following data structures use the
value programmed in the <code>RCID</code> and <code>MCID</code> fields of the <code>iommu_qosid</code> register.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Device directory table (<code>DDT</code>)</p>
</li>
<li>
<p>Fault queue (<code>FQ</code>)</p>
</li>
<li>
<p>Command queue (<code>CQ</code>)</p>
</li>
<li>
<p>Page-request queue (<code>PQ</code>)</p>
</li>
<li>
<p>IOMMU-initiated MSI (Message-signaled interrupts)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When <code>ddtp.iommu_mode == Bare</code>, all device-originated requests are
associated with the QoS IDs configured in the <code>iommu_qosid</code> register.</p>
</div>
</div>
<div class="sect2">
<h3 id="ICVEC"><a class="anchor" href="#ICVEC"></a>6.28. Interrupt-cause-to-vector register (<code>icvec</code>)</h3>
<div class="paragraph">
<p>Interrupt-cause-to-vector register maps a cause to a vector.  All causes can
be mapped to the same vector or a cause can be given a unique vector.</p>
</div>
<div class="paragraph">
<p>The vector is used:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>By an IOMMU that generates interrupts as MSIs, to index into MSI
configuration table (<code>msi_cfg_tbl</code>) to determine the MSI to generate. An
IOMMU is capable of generating interrupts as a MSI if <code>capabilities.IGS==MSI</code>
or if <code>capabilities.IGS==BOTH</code>. When <code>capabilities.IGS==BOTH</code> the IOMMU may be
configured to generate interrupts as MSI by setting <code>fctl.WSI</code> to 0.</p>
</li>
<li>
<p>By an IOMMU that generates WSI, to determine the wire
to signal the interrupt. An IOMMU is capable of generating wire-signaled-
interrupts if <code>capabilities.IGS==WSI</code> or if <code>capabilities.IGS==BOTH</code>. When
<code>capabilities.IGS==BOTH</code> the IOMMU may be configured to generate wire-signaled-
interrupts by setting <code>fctl.WSI</code> to 1.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If an implementation only supports a single vector then all bits of this
register may be hardwired to 0 (WARL). Likewise if only two vectors are
supported then only bit 0 for each cause could be writable.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjDRUchLzE21UlBPzixTr9XBJpOGU6YgF7cUmoyhGVyqKLU4tagsNQVF3tgI4ZLS4pL8XJBsrI5Ccn5eWma6VXVOYl4qxIKM4oLE5FQrQwMjk9paAG_-Pyw=" alt="Interrupt-cause-to-vector register fields">
</div>
<div class="title">Figure 60. Interrupt-cause-to-vector register fields</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Bits</th>
<th class="tableblock halign-center valign-top">Field</th>
<th class="tableblock halign-center valign-top">Attribute</th>
<th class="tableblock halign-center valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">3:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>civ</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WARL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The command-queue-interrupt-vector (<code>civ</code>)
                               is the vector number assigned to the
                               command-queue-interrupt.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7:4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fiv</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WARL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The fault-queue-interrupt-vector (<code>fiv</code>) is the
                               vector number assigned to the
                               fault-queue-interrupt.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">11:8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pmiv</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WARL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The performance-monitoring-interrupt-vector
                               (<code>pmiv</code>) is the vector number assigned to the
                               performance-monitoring-interrupt.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">15:12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>piv</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WARL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The page-request-queue-interrupt-vector (<code>piv</code>)
                               is the vector number assigned to the
                               page-request-queue-interrupt.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">31:16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">63:32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">custom</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Designated for custom use.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="MSI"><a class="anchor" href="#MSI"></a>6.29. MSI configuration table (<code>msi_cfg_tbl</code>)</h3>
<div class="paragraph">
<p>An IOMMU that supports generating IOMMU-originated interrupts
(i.e., <code>capabilities.IGS == MSI</code> or <code>capabilities.IGS == BOTH</code>) as MSIs
implements a MSI configuration table that is indexed by the vector from <code>icvec</code>
to determine a MSI table entry. Each MSI table entry for interrupt vector <code>x</code>
has three registers <code>msi_addr_x</code>, <code>msi_data_x</code>, and <code>msi_vec_ctl_x</code>. These
registers are hardwired to 0 if <code>capabilities.IGS == WSI</code>.</p>
</div>
<div class="paragraph">
<p>If an access fault is detected on a MSI write using <code>msi_addr_x</code>, then the IOMMU
reports a "IOMMU MSI write access fault" (cause 273) fault, with <code>TTYP</code> set to 0
and <code>iotval</code> set to the value of <code>msi_addr_x</code>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 19. MSI configuration table structure</caption>
<colgroup>
<col style="width: 43.4782%;">
<col style="width: 43.4782%;">
<col style="width: 13.0436%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">bit 63</th>
<th class="tableblock halign-right valign-top">bit 0</th>
<th class="tableblock halign-left valign-top">Byte Offset</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top" colspan="2"><p class="tableblock">Entry 0: Message address</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+000h</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Entry 0: Vector Control</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Entry 0: Message Data</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+008h</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="2"><p class="tableblock">Entry 1: Message address</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+010h</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Entry 1: Vector Control</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Entry 1: Message Data</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+018h</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="2"><p class="tableblock">&#8230;&#8203;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+020h</p></td>
</tr>
</tbody>
</table>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjDSUchLzE21UlA3UK_VQYibmsAlHF1cglDkLOBSRanFqUVlqSkg6VgdheT8vLTMdKvqnMS8VIjZGcUFicmpVoYGRia1tQDkFiVS" alt="Message address register fields">
</div>
<div class="title">Figure 61. Message address register fields</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Bits</th>
<th class="tableblock halign-center valign-top">Field</th>
<th class="tableblock halign-center valign-top">Attribute</th>
<th class="tableblock halign-center valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fixed to 0</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">55:2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ADDR</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WARL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Holds the 4-byte aligned MSI address.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">63:56</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use.</p></td>
</tr>
</tbody>
</table>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjA20lHIS8xNtVJQT0ksSVSv1eGK1VFIzs9Ly0y3qs5JzEsFKjLUUcgoLkhMTrUyNDAyqa0FAPYeFbQ=" alt="Message data register fields">
</div>
<div class="title">Figure 62. Message data register fields</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Bits</th>
<th class="tableblock halign-center valign-top">Field</th>
<th class="tableblock halign-center valign-top">Attribute</th>
<th class="tableblock halign-center valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">31:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>data</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WARL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Holds the MSI data</p></td>
</tr>
</tbody>
</table>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjDUUchLzE21UlD3Va_VQYgbIySKUotTi8pSU0DysToKyfl5aZnpVtU5iXmpEAMyigsSk1OtDA2MTGprAaekHgY=" alt="Vector control register fields">
</div>
<div class="title">Figure 63. Vector control register fields</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Bits</th>
<th class="tableblock halign-center valign-top">Field</th>
<th class="tableblock halign-center valign-top">Attribute</th>
<th class="tableblock halign-center valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>M</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">RW</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When the mask bit <code>M</code> is 1, the corresponding
                            interrupt vector is masked and the IOMMU is
                            prohibited from sending the associated message.
                            Pending messages for that vector are later
                            generated if the corresponding mask bit is
                            cleared to 0.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">31:1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">WPRI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved for standard use.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sw_guidelines"><a class="anchor" href="#sw_guidelines"></a>7. Software guidelines</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section provides guidelines to software developers on the correct and
expected sequence of using the IOMMU interfaces. The behavior of the IOMMU
if these guidelines are not followed is implementation defined.</p>
</div>
<div class="sect2">
<h3 id="reading-and-writing-iommu-registers"><a class="anchor" href="#reading-and-writing-iommu-registers"></a>7.1. Reading and writing IOMMU registers</h3>
<div class="paragraph">
<p>Read or write access to IOMMU registers must follow the following rules:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Address of the access must be aligned to the size of the access.</p>
</li>
<li>
<p>The access must not span multiple registers.</p>
</li>
<li>
<p>Registers that are 64-bit wide may be accessed using either a 32-bit or
a 64-bit access.</p>
</li>
<li>
<p>Registers that are 32-bit wide must only be accessed using a 32-bit access.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="guidelines-for-initialization"><a class="anchor" href="#guidelines-for-initialization"></a>7.2. Guidelines for initialization</h3>
<div class="paragraph">
<p>The guidelines for initializing the IOMMU are as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Read the <code>capabilities</code> register to discover the capabilities of the IOMMU.</p>
</li>
<li>
<p>Stop and report failure if <code>capabilities.version</code> is not supported.</p>
</li>
<li>
<p>Read the feature control register (<code>fctl</code>).</p>
</li>
<li>
<p>Stop and report failure if big-endian memory access is needed and the
<code>capabilities.END</code> field is 0 (i.e. only one endianness) and <code>fctl.BE</code> is
0 (i.e. little endian).</p>
</li>
<li>
<p>If big-endian memory access is needed and the <code>capabilities.END</code> field is 1
(i.e. both endiannesses supported), set <code>fctl.BE</code> to 1 (i.e. big endian)
if the field is not already 1.</p>
</li>
<li>
<p>Stop and report failure if wired-signaled-interrupts are needed for IOMMU
initiated interrupts and <code>capabilities.IGS</code> is not <code>WSI</code>.</p>
</li>
<li>
<p>If wired-signaled-interrupts are needed for IOMMU initiated interrupts and
<code>capabilities.IGS</code> is <code>BOTH</code>, set <code>fctl.WSI</code> to 1 if the field is not
already 1.</p>
</li>
<li>
<p>Stop and report failure if other required capabilities
(e.g. virtual-addressing modes, MSI translation, etc.) are not supported.</p>
</li>
<li>
<p>The <code>icvec</code> register is used to program an interrupt vector for each
interrupt cause. Determine the number of vectors supported by the IOMMU by
writing 0xF to each field and reading back the number of writable bits. If
the number of writable bits is <code>N</code> then the number of supported vectors is
<code>2<sup>N</sup></code>. For each cause <code>C</code> associate a vector <code>V</code> with the cause. <code>V</code> is a
number between 0 and <code>(2<sup>N</sup> - 1)</code>.</p>
</li>
<li>
<p>If the IOMMU is configured to use wired interrupts, then each vector <code>V</code>
corresponds to an interrupt wire connected to a platform level interrupt
controller (e.g. APLIC). Determine the interrupt controller configuration
register to be programmed for each such wire using configuration information
provided by configuration mechanisms such as device tree and program the
interrupt controller.</p>
</li>
<li>
<p>If the IOMMU is configured to use MSI, then each vector <code>V</code> is an index into
the <code>msi_cfg_tbl</code>. For each vector <code>V</code>, allocate a MSI address <code>A</code> and
an interrupt identity <code>D</code>. Configure the <code>msi_addr_V</code> register with value <code>A</code>,
<code>msi_data_V</code> register with value <code>D</code>. Configure the interrupt mask <code>M</code> in
<code>msi_vec_ctl_V</code> register appropriately.</p>
</li>
<li>
<p>To program the command queue, first determine the number of entries <code>N</code> needed
in the command queue. The number of entries in the command queue must be a
power of two. Allocate a <code>N</code> x 16-bytes sized memory buffer that is naturally
aligned to the greater of 4-KiB or <code>N</code> x 16-bytes. Let <code>k=log<sub>2</sub>(N)</code> and <code>B</code>
be the physical page number (PPN) of the allocated memory buffer. Program
the command queue registers as follows:</p>
<div class="ulist">
<ul>
<li>
<p><code>temp_cqb_var.PPN = B</code></p>
</li>
<li>
<p><code>temp_cqb_var.LOG2SZ-1 = (k - 1)</code></p>
</li>
<li>
<p><code>cqb = temp_cqb_var</code></p>
</li>
<li>
<p><code>cqt = 0</code></p>
</li>
<li>
<p><code>cqcsr.cqen = 1</code></p>
</li>
<li>
<p>Poll on <code>cqcsr.cqon</code> until it reads 1</p>
</li>
</ul>
</div>
</li>
<li>
<p>To program the fault queue, first determine the number of entries N needed in
the fault queue. The number of entries in the fault queue is always a power
of two.  Allocate a <code>N</code> x 32-bytes sized memory buffer that is naturally
aligned to the greater of 4-KiB or <code>N</code> x 32-bytes. Let <code>k=log<sub>2</sub>(N)</code> and <code>B</code>
be the PPN of the allocated memory buffer. Program the fault queue registers
as follows:</p>
<div class="ulist">
<ul>
<li>
<p><code>temp_fqb_var.PPN = B</code></p>
</li>
<li>
<p><code>temp_fqb_var.LOG2SZ-1 = (k - 1)</code></p>
</li>
<li>
<p><code>fqb = temp_fqb_var</code></p>
</li>
<li>
<p><code>fqh = 0</code></p>
</li>
<li>
<p><code>fqcsr.fqen = 1</code></p>
</li>
<li>
<p>Poll on <code>fqcsr.fqon</code> until it reads 1</p>
</li>
</ul>
</div>
</li>
<li>
<p>To program the page-request queue, first determine the number of entries <code>N</code>
needed in the page-request queue. The number of entries in the page-request
queue is always a power of two. Allocate a <code>N</code> x 16-bytes sized buffer that is
naturally aligned to the greater of 4-KiB or <code>N</code> x 16-bytes. Let <code>k=log<sub>2</sub>(N)</code>
and <code>B</code> be the PPN of the allocated memory buffer. Program the page-request
queue registers as follows:</p>
<div class="ulist">
<ul>
<li>
<p><code>temp_pqb_var.PPN = B</code></p>
</li>
<li>
<p><code>temp_pqb_var.LOG2SZ-1 = (k - 1)</code></p>
</li>
<li>
<p><code>pqb = temp_pqb_var</code></p>
</li>
<li>
<p><code>pqh = 0</code></p>
</li>
<li>
<p><code>pqcsr.pqen = 1</code></p>
</li>
<li>
<p>Poll on <code>pqcsr.pqon</code> until it reads 1</p>
</li>
</ul>
</div>
</li>
<li>
<p>To program the DDT pointer, first determine the supported <code>device_id</code> width <code>Dw</code>
and the format of the device-context data structure. If <code>capabilities.MSI</code> is
0, then the IOMMU uses base-format device-contexts else extended-format
device-contexts are used. Allocate a page (4 KiB) of memory to use as the root
table of the DDT. Initialize the allocated memory to all 0. Let <code>B</code> be the
PPN of the allocated memory. Determine the mode <code>M</code> of the DDT based on <code>Dw</code>
and the IOMMU device-contexts format as follows:</p>
<div class="ulist">
<ul>
<li>
<p>Determine the values supported by <code>ddtp.iommu_mode</code> by writing legal values
and reading it to see if the value was retained. Stop and report a failure if
the supported modes do not support the required <code>Dw</code>.</p>
</li>
<li>
<p>If extended-format device-contexts are used then</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>If <code>Dw</code> is less than or equal to  6-bits and <code>1LVL</code> is supported then <code>M = 1LVL</code></p>
</li>
<li>
<p>If <code>Dw</code> is less than or equal to 15-bits and <code>2LVL</code> is supported then <code>M = 2LVL</code></p>
</li>
<li>
<p>If <code>Dw</code> is less than or equal to 24-bits and <code>3LVL</code> is supported then <code>M = 3LVL</code></p>
</li>
</ol>
</div>
</li>
<li>
<p>If base-format device-contexts are used then</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>If <code>Dw</code> is less than or equal to  7-bits and <code>1LVL</code> is supported then <code>M = 1LVL</code></p>
</li>
<li>
<p>If <code>Dw</code> is less than or equal to 16-bits and <code>2LVL</code> is supported then <code>M = 2LVL</code></p>
</li>
<li>
<p>If <code>Dw</code> is less than or equal to 24-bits and <code>3LVL</code> is supported then <code>M = 3LVL</code></p>
</li>
</ol>
</div>
</li>
<li>
<p>Program the <code>ddtp</code> register as follows:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>temp_ddtp_var.iommu_mode = M</code></p>
</li>
<li>
<p><code>temp_ddtp_var.PPN = B</code></p>
</li>
<li>
<p><code>ddtp = temp_ddtp_var</code></p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>The IOMMU is initialized and may be now be configured with device-contexts
for devices in scope of the IOMMU.</p>
</div>
</div>
<div class="sect2">
<h3 id="guidelines-for-invalidations"><a class="anchor" href="#guidelines-for-invalidations"></a>7.3. Guidelines for invalidations</h3>
<div class="paragraph">
<p>This section provides guidelines to software on the invalidation commands to
send to the IOMMU through the <code>CQ</code> when modifying the IOMMU in-memory data
structures. Software must perform the invalidation after the update is globally
visible. The ordering on stores provided by FENCE instructions and the acquire/
release bits on atomic instructions also orders the data structure updates
associated with those stores as observed by IOMMU.</p>
</div>
<div class="paragraph">
<p>A <code>IOFENCE.C</code> command may be used by software to ensure that all previous
commands fetched from the <code>CQ</code> have been completed and committed. The <code>PR</code>
and/or <code>PW</code> bits may be set to 1 in the <code>IOFENCE.C</code> command to request that all
previous read and/or write requests, that have already been processed by the
IOMMU, be committed to a global ordering point as part of the <code>IOFENCE.C</code>
command.</p>
</div>
<div class="paragraph">
<p>In subsequent sections, when an algorithm step tests values in the in-memory
data structures to determine the type of invalidation operation to perform, the
data values tested are the old values i.e. values before a change is made.</p>
</div>
<div class="sect3">
<h4 id="DC_CHANGE"><a class="anchor" href="#DC_CHANGE"></a>7.3.1. Changing device directory table entry</h4>
<div class="paragraph">
<p>If software changes a leaf-level DDT entry (i.e, a device context (<code>DC</code>), of
device with <code>device_id = D</code>) then the following invalidations must be performed:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IODIR.INVAL_DDT</code> with <code>DV=1</code> and <code>DID=D</code></p>
</li>
<li>
<p>If <code>DC.iohgatp.MODE != Bare</code></p>
<div class="ulist">
<ul>
<li>
<p><code>IOTINVAL.VMA</code> with <code>GV=1</code>, <code>AV=PSCV=0</code>, and <code>GSCID=DC.iohgatp.GSCID</code></p>
</li>
<li>
<p><code>IOTINVAL.GVMA</code> with <code>GV=1</code>, <code>AV=0</code>, and <code>GSCID=DC.iohgatp.GSCID</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>else</p>
<div class="ulist">
<ul>
<li>
<p>If <code>DC.tc.PDTV==1</code></p>
<div class="ulist">
<ul>
<li>
<p><code>IOTINVAL.VMA</code> with <code>GV=AV=PSCV=0</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>else if <code>DC.fsc.MODE != Bare</code></p>
<div class="ulist">
<ul>
<li>
<p><code>IOTINVAL.VMA</code> with <code>GV=AV=0</code> and <code>PSCV=1</code>, and <code>PSCID=DC.ta.PSCID</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>If software changes a non-leaf-level DDT entry the following invalidations
must be performed:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IODIR.INVAL_DDT</code> with <code>DV=0</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Between a change to the DDT entry and when an invalidation command to invalidate
the cached entry is processed by the IOMMU, the IOMMU may use the old value or
the new value of the entry.</p>
</div>
</div>
<div class="sect3">
<h4 id="PC_CHANGE"><a class="anchor" href="#PC_CHANGE"></a>7.3.2. Changing process directory table entry</h4>
<div class="paragraph">
<p>If software changes a leaf-level PDT entry (i.e, a process context (<code>PC</code>), for
<code>device_id=D</code> and <code>process_id=P</code>) then the following invalidations must be
performed:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IODIR.INVAL_PDT</code> with <code>DV=1</code>, <code>DID=D</code> and <code>PID=P</code></p>
</li>
<li>
<p>If <code>DC.iohgatp.MODE != Bare</code></p>
<div class="ulist">
<ul>
<li>
<p><code>IOTINVAL.VMA</code> with <code>GV=1</code>, <code>AV=0</code>, <code>PSCV=1</code>, <code>GSCID=DC.iohgatp.GSCID</code>,
and <code>PSCID=PC.PSCID</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>else</p>
<div class="ulist">
<ul>
<li>
<p><code>IOTINVAL.VMA</code> with <code>GV=0</code>, <code>AV=0</code>, <code>PSCV=1</code>, and <code>PSCID=PC.PSCID</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>If software changes a non-leaf-level PDT entry the following invalidations
must be performed:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IODIR.INVAL_DDT</code> with <code>DV=1</code> and <code>DID=D</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Between a change to the PDT entry and when an invalidation command to invalidate
the cached entry is processed by the IOMMU, the IOMMU may use the old value or
the new value of the entry.</p>
</div>
</div>
<div class="sect3">
<h4 id="MSI_PT_CHANGE"><a class="anchor" href="#MSI_PT_CHANGE"></a>7.3.3. Changing MSI page table entry</h4>
<div class="paragraph">
<p>If software changes a MSI page-table entry identified by interrupt file
number <code>I</code> that corresponds to an untranslated MSI address <code>A</code> then the following
invalidations must be performed:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IOTINVAL.GVMA</code> with <code>GV=AV=1</code>, <code>ADDR[63:12]=A[63:12]</code> and
<code>GSCID=DC.iohgatp.GSCID</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To invalidate all cache entries from a MSI page table the following
invalidations must be performed:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IOTINVAL.GVMA</code> with <code>GV=1</code>, <code>AV=0</code>, and <code>GSCID=DC.iohgatp.GSCID</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Between a change to the MSI PTE and when an invalidation command to invalidate
the cached PTE is processed by the IOMMU, the IOMMU may use the old PTE value
or the new PTE value. An <code>IOFENCE.C</code> command with <code>PW=1</code> may be used to to
ensure that all previous writes, including MSI writes, that have been previously
processed by the IOMMU are committed to a global ordering point such that they
can be observed by all RISC-V harts and IOMMUs in the system.</p>
</div>
</div>
<div class="sect3">
<h4 id="changing-second-stage-page-table-entry"><a class="anchor" href="#changing-second-stage-page-table-entry"></a>7.3.4. Changing second-stage page table entry</h4>
<div class="paragraph">
<p>If software changes a leaf second-stage page-table entry of a VM where the change
affects translation for a guest-PPN <code>G</code> then the following invalidations must be
performed:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IOTINVAL.GVMA</code> with <code>GV=AV=1</code>, <code>GSCID=DC.iohgatp.GSCID</code>, and <code>ADDR[63:12]=G</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If software changes a non-leaf second-stage page-table entry of a VM
then the following invalidations must be performed:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IOTINVAL.GVMA</code> with <code>GV=1</code>, <code>AV=0</code>, <code>GSCID=DC.iohgatp.GSCID</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>DC</code> has fields that hold a guest-PPN. An implementation may translate such
fields to a supervisor-PPN as part of caching the <code>DC</code>. If the second-stage page
table update affects translation of guest-PPN held in the <code>DC</code> then software
must invalidate all such cached <code>DC</code> using <code>IODIR.INVAL_DDT</code> with <code>DV=1</code> and
<code>DID</code> set to the corresponding <code>device_id</code>.  Alternatively, an
<code>IODIR.INVAL_DDT</code> with <code>DV=0</code> may be used to invalidate all cached <code>DC</code>.</p>
</div>
<div class="paragraph">
<p>Between a change to the second-stage PTE and when an invalidation command to
invalidate the cached PTE is processed by the IOMMU, the IOMMU may use the
old PTE value or the new PTE value.</p>
</div>
</div>
<div class="sect3">
<h4 id="changing-first-stage-page-table-entry"><a class="anchor" href="#changing-first-stage-page-table-entry"></a>7.3.5. Changing first-stage page table entry</h4>
<div class="paragraph">
<p>A <code>DC</code> may be configured with a first-stage page table (when <code>DC.tc.PDTV=0</code>) or
a directory of first-stage page tables selected using <code>process_id</code> from a
process-directory-table (when <code>DC.tc.PDTV=1</code>).</p>
</div>
<div class="paragraph">
<p>When a change is made to a first-stage page table, and the second-stage is
Bare, then software must perform invalidations using <code>IOTINVAL.VMA</code> with
<code>GV=0</code> and <code>AV</code> and <code>PSCV</code> operands appropriate for the modification as
specified in <a href="#IVMA">Table 9</a>.</p>
</div>
<div class="paragraph">
<p>When a change is made to a first-stage page table, and the second-stage is
not Bare, then software must perform invalidations using <code>IOTINVAL.VMA</code> with
<code>GV=1</code>, <code>GSCID=DC.iohgatp.GSCID</code> and <code>AV</code> and <code>PSCV</code> operands appropriate for
the modification as specified in <a href="#IVMA">Table 9</a>.</p>
</div>
<div class="paragraph">
<p>Between a change to the first-stage PTE and when an invalidation command to
invalidate the cached PTE is processed by the IOMMU, the IOMMU may use the
old PTE value or the new PTE value.</p>
</div>
<div style="page-break-after: always;"></div>
</div>
<div class="sect3">
<h4 id="accessed-adirty-d-bit-updates-and-page-promotions"><a class="anchor" href="#accessed-adirty-d-bit-updates-and-page-promotions"></a>7.3.6. Accessed (A)/Dirty (D) bit updates and page promotions</h4>
<div class="paragraph">
<p>When IOMMU supports hardware-managed A and D bit updates, if software clears
the A and/or D bit in the first-stage and/or second-stage PTEs then software
must invalidate corresponding PTE entries that may be cached by the IOMMU. If
such invalidations are not performed, then the IOMMU may not set these bits
when processing subsequent transactions that use such entries.</p>
</div>
<div class="paragraph">
<p>When software upgrades a page in a first-stage PT and/or a second-stage PT to
a superpage without first clearing the original non-leaf PTE&#8217;s valid bit and
invalidating cached translations in the IOMMU then it is possible for the
IOMMU to cache multiple entries that match a single address. The IOMMU may
use either the old non-leaf PTE or the new non-leaf PTE but the behavior is
otherwise well defined.</p>
</div>
<div class="paragraph">
<p>When promoting and/or demoting page sizes, software must ensure that the
original and new PTEs have identical permission and memory type attributes and
the physical address that is determined as a result of translation using either
the original or the new PTE is otherwise identical for any given input. The
only PTE update supported by the IOMMU without first clearing the V bit in the
original PTE and executing a appropriate <code>IOTINVAL</code> command is to do a page size
promotion or demotion. The behavior of the IOMMU if other attributes are
changed in this fashion is implementation defined.</p>
</div>
</div>
<div class="sect3">
<h4 id="device-address-translation-cache-invalidations"><a class="anchor" href="#device-address-translation-cache-invalidations"></a>7.3.7. Device Address Translation Cache invalidations</h4>
<div class="paragraph">
<p>When first-stage and/or second-stage page tables are modified, invalidations may
be needed to the DevATC in the devices that may have cached translations from
the modified page tables. Invalidation of such page tables requires generating
ATS invalidations using <code>ATS.INVAL</code> command. Software must specify the <code>PAYLOAD</code>
following the rules defined in PCIe ATS specifications cite:[PCI].</p>
</div>
<div class="paragraph">
<p>If software generates ATS invalidate requests at a rate that exceeds the
average DevATC service rate then flow control mechanisms may be triggered by
the device to throttle the rate. A side effect of this is congestion
spreading to other channels and links which could lead to performance
degradation. An ATS capable device publishes the maximum number of
invalidations it can buffer before causing back-pressure through the Queue
Depth field of the ATS capability structure. When the device is virtualized
using PCIe SR-IOV, this queue depth is shared among all the VFs of the device.
Software must limit the number of outstanding ATS invalidations queued to
the device advertised limit.</p>
</div>
<div class="paragraph">
<p>The <code>RID</code> field is used to specify the routing ID of the ATS invalidation
request message destination. A PASID specific invalidation may be performed by
setting <code>PV=1</code> and specifying the PASID in <code>PID</code>. When the IOMMU supports
multiple segments then the <code>RID</code> must be qualified by the destination segment
number by setting <code>DSV=1</code> with the segment number provided in <code>DSEG</code>.</p>
</div>
<div class="paragraph">
<p>When ATS protocol is enabled for a device, the IOMMU may still cache
translations in its IOATC in addition to providing translations to the DevATC.
Software must not skip IOMMU translation cache invalidations even when ATS is
enabled in the device context of the device. Since a translation request from
the DevATC may be satisfied by the IOMMU from the IOATC, to ensure correct
operation software must first invalidate the IOATC before sending
invalidations to the DevATC.</p>
</div>
<div style="page-break-after: always;"></div>
</div>
<div class="sect3">
<h4 id="caching-invalid-entries"><a class="anchor" href="#caching-invalid-entries"></a>7.3.8. Caching invalid entries</h4>
<div class="paragraph">
<p>This specification does not allow the caching of first/second-stage PTEs whose
<code>V</code> (valid) bit is clear, non-leaf DDT entries whose <code>V</code> (valid) bit is clear,
Device-context whose <code>V</code> (valid) bit is clear, non-leaf PDT entries whose <code>V</code>
(valid) bit is clear, Process-context whose <code>V</code> (valid) bit is clear, or MSI
PTEs whose <code>V</code> bit is clear. Software need not perform invalidations when
changing the <code>V</code> bit in these entries from 0 to 1.</p>
</div>
</div>
<div class="sect3">
<h4 id="guidelines-for-emulating-an-iommu"><a class="anchor" href="#guidelines-for-emulating-an-iommu"></a>7.3.9. Guidelines for emulating an IOMMU</h4>
<div class="paragraph">
<p>Certain uses may involve emulating a RISC-V IOMMU. In such cases, the emulator
may require the IOMMU driver to notify the emulator for efficient operation when
updates are made to in-memory data structure entries, including when making such
entries valid. Queueing an appropriate invalidation command when making such
updates is a common way to provide notifications to the emulator. While usually
an invalidation is not required when marking an invalid entry as valid, the
emulator may indicate the need to invoke such invalidation commands for
emulation efficiency purposes through a suitable flag in the device tree or ACPI
table describing such emulated IOMMU instances.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="reconfiguring-pmas"><a class="anchor" href="#reconfiguring-pmas"></a>7.4. Reconfiguring PMAs</h3>
<div class="paragraph">
<p>Where platforms support dynamic reconfiguration of PMAs, a machine-mode driver
is usually provided that can correctly configure the platform. In some
platforms that might involve platform-specific operations and if the IOMMU
must participate in these operations then platform-specific operations in the
IOMMU are used by the machine-mode driver to perform such reconfiguration.</p>
</div>
</div>
<div class="sect2">
<h3 id="guidelines-for-handling-interrupts-from-iommu"><a class="anchor" href="#guidelines-for-handling-interrupts-from-iommu"></a>7.5. Guidelines for handling interrupts from IOMMU</h3>
<div class="paragraph">
<p>IOMMU may generate an interrupt from the <code>CQ</code>, the <code>FQ</code>, the <code>PQ</code>, or the HPM. Each
interrupt source may be configured with a unique vector or a vector may be
shared among one or more interrupt sources. The interrupt may be delivered
as a MSI or a wire-signaled-interrupt. The interrupt handler may perform the
following actions:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Read the <code>ipsr</code> register to determine the source of the pending interrupts</p>
</li>
<li>
<p>If the <code>ipsr.cip</code> bit is set then an interrupt is pending from the <code>CQ</code>.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Read the <code>cqcsr</code> register.</p>
</li>
<li>
<p>Determine if an error caused the interrupt and if so, the cause of the
error by examining the state of the <code>cmd_to</code>, <code>cmd_ill</code>, and <code>cqmf</code> bits.
If any of these bits are set then the <code>CQ</code> encountered an error and command
processing is temporarily disabled.</p>
</li>
<li>
<p>If errors have occurred, correct the cause of the error and clear the bits
corresponding to the corrected errors in <code>cqcsr</code> by writing 1 to the bits.</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>Clearing all error indication bits in <code>cqcsr</code> re-enables command processing.</p>
</li>
</ol>
</div>
</li>
<li>
<p>An IOMMU that supports wired-interrupts may be requested to generate an
interrupt from the command queue on completion of a <code>IOFENCE.C</code> command.
This cause is indicated by the <code>fence_w_ip</code> bit. Note that command
processing does not stop when <code>fence_w_ip</code> is set to 1. Software handler
may re-enable interrupts from <code>CQ</code> on <code>IOFENCE.C</code> completions by clearing
this bit by writing 1 to it.</p>
</li>
<li>
<p>Clear <code>ipsr.cip</code> by writing 1 to the bit.</p>
</li>
</ol>
</div>
</li>
<li>
<p>If the <code>ipsr.fip</code> bit is set then an interrupt is pending from the <code>FQ</code>.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Read the <code>fqcsr</code> register.</p>
</li>
<li>
<p>Determine if an error caused the interrupt and if so, the cause of the error
by examining the state of the <code>fqmf</code> and <code>fqof</code> bits. If either of these bits
are set then the <code>FQ</code> encountered an error and fault/event reporting is
temporarily disabled.</p>
</li>
<li>
<p>If errors have occurred, correct the cause of the error and clear the bits
corresponding to the corrected errors in <code>fqcsr</code> by writing 1 to the bits.</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>Clearing all error indication bits in <code>fqcsr</code> re-enables fault/event
reporting.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Clear <code>ipsr.fip</code> by writing 1 to the bit.</p>
</li>
<li>
<p>Read the <code>fqt</code> and <code>fqh</code> registers.</p>
</li>
<li>
<p>If value of <code>fqt</code> is not equal to value of <code>fqh</code> then the <code>FQ</code> is not empty
and contains fault/event reports that need processing.</p>
</li>
<li>
<p>Process pending fault/event reports that need processing and remove them from
the <code>FQ</code> by advancing the <code>fqh</code> by the number of records processed.</p>
</li>
</ol>
</div>
</li>
<li>
<p>If the <code>ipsr.pip</code> bit is set then an interrupt is pending from the <code>PQ</code>.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Read the <code>pqcsr</code> register.</p>
</li>
<li>
<p>Determine if an error caused the interrupt and if so, the cause of the error
by examining the state of the <code>pqmf</code> and <code>pqof</code> bits. If either of these bits
are set then the <code>PQ</code> encountered an error and "Page Request" reporting is
temporarily disabled.</p>
</li>
<li>
<p>If errors have occurred, correct the cause of the error and clear the bits
corresponding to the corrected errors in <code>pqcsr</code> by writing 1 to the bits.</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>Clearing all error indication bits in <code>pqcsr</code> re-enables "Page Request"
reporting.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Clear <code>ipsr.pip</code> by writing 1 to the bit.</p>
</li>
<li>
<p>Read the <code>pqt</code> and <code>pqh</code> registers.</p>
</li>
<li>
<p>If value of <code>pqt</code> is not equal to the value of <code>pqh</code> then the <code>PQ</code> is not empty
and contains "Page Request" messages that need processing.</p>
</li>
<li>
<p>Process pending "Page Request" messages that need processing and remove them
from the <code>PQ</code> by advancing the <code>pqh</code> by the number of records processed.</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>When a <code>PQ</code> overflow condition occurs, software may observe incomplete
page-request groups due to the "Page Request" messages being dropped. The
IOMMU might have automatically responded (see <a href="#ATS_PRI">Section 3.7</a>) to a dropped
"Page Request" in such groups if the "Last Request in PRG" flag was set to 1
in the message. Software should ignore and not service the such incomplete
groups.</p>
</li>
<li>
<p>The automatic response to the "Page Request" with "Last request in PRG" set
to 1 on a <code>PQ</code> overflow is expected to cause the device to retry the ATS
translation request. However, since the IOMMU generated response was without
actually resolving the condition that caused the "Page Request" to be
originally sent by the device, this will likely lead to the device sending
the "Page Request" messages again. These retried messages may now be stored
in the <code>PQ</code> if the overflow condition has been corrected by creating space
in the <code>PQ</code>.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>If <code>ipsr.pmip</code> bit is set then an interrupt is pending from the HPM.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Clear <code>ipsr.pmip</code> by writing 1 to the bit.</p>
</li>
<li>
<p>Process the performance monitoring counter overflows.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="guidelines-for-enabling-and-disabling-ats-andor-pri"><a class="anchor" href="#guidelines-for-enabling-and-disabling-ats-andor-pri"></a>7.6. Guidelines for enabling and disabling ATS and/or PRI</h3>
<div class="paragraph">
<p>To enable ATS and/or PRI:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Place the device in an idle state such that no transactions are generated
by the device.</p>
</li>
<li>
<p>If the device-context for the device is already valid then first mark the
device-context as invalid and queue commands to the IOMMU to invalidate all
cached first/second-stage page table entries, DDT entries, MSI PT entries
(if required), and PDT entries (if required).</p>
</li>
<li>
<p>Program the device-context with <code>EN_ATS</code> set to 1 and if required the <code>T2GPA</code>
field set to 1. Set <code>EN_PRI</code> to 1 if required. If <code>EN_PRI</code> is set to 1 then
set <code>PRPR</code> to 1 if required.</p>
</li>
<li>
<p>Mark the device-context as valid.</p>
</li>
<li>
<p>Enable device to use ATS and if required enable the PRI.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>To disable ATS and/or PRI:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Place the device in an idle state such that no transactions are generated
by the device.</p>
</li>
<li>
<p>Disable ATS and/or PRI at the device</p>
</li>
<li>
<p>Set <code>EN_ATS</code> and/or <code>EN_PRI</code> to 0 in the device-context. If <code>EN_ATS</code> is set to
0 then set <code>EN_PRI</code> and <code>T2GPA</code> to 0. If <code>EN_PRI</code> is set to 0 then set <code>PRPR</code>
to 0.</p>
</li>
<li>
<p>Queue commands to the IOMMU to invalidate all cached first/second-stage page
table entries, DDT entries, MSI PT entries (if required), and PDT entries
(if required).</p>
</li>
<li>
<p>Queue commands to the IOMMU to invalidate DevATC by generating Invalidation
Request messages.</p>
</li>
<li>
<p>Enable DMA operations in the device.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="hardware-guidelines"><a class="anchor" href="#hardware-guidelines"></a>8. Hardware guidelines</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section provides guidelines to the system/hardware integrator of the
IOMMU in the platform.</p>
</div>
<div class="sect2">
<h3 id="integrating-an-iommu-as-a-pcie-device"><a class="anchor" href="#integrating-an-iommu-as-a-pcie-device"></a>8.1. Integrating an IOMMU as a PCIe device</h3>
<div class="paragraph">
<p>The IOMMU may be constructed as a PCIe device itself and be discoverable
as a dedicated PCIe function with PCIe defined Base Class 08h, Sub-Class 06h,
and Programming Interface 00h cite:[PCI-CLS].</p>
</div>
<div class="paragraph">
<p>Such IOMMU must map the IOMMU registers defined in this specification as PCIe
BAR mapped registers.</p>
</div>
<div class="paragraph">
<p>The IOMMU may support MSI or MSI-X or both. When MSI-X is supported,  the MSI-X
capability block must point to the <code>msi_cfg_tbl</code> in BAR mapped registers such that
system software can configure MSI address and data pairs for each message
supported by the IOMMU. The MSI-X PBA may be located in the same BAR or
another BAR of the IOMMU. The IOMMU is recommended to support MSI-X capability.</p>
</div>
</div>
<div class="sect2">
<h3 id="faults-from-pma-and-pmp"><a class="anchor" href="#faults-from-pma-and-pmp"></a>8.2. Faults from PMA and PMP</h3>
<div class="paragraph">
<p>The IO bridge may invoke a PMA and/or a PMP checker on memory accesses from
IO devices or those generated by the IOMMU implicitly to access the in-memory
data structures. When a memory access violates a PMA check or violates a PMP
check, the IO bridge may abort the memory access as specified in
<a href="#IOBR_FAULT_RESP">Section 8.3</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="IOBR_FAULT_RESP"><a class="anchor" href="#IOBR_FAULT_RESP"></a>8.3. Aborting transactions</h3>
<div class="paragraph">
<p>If the aborted transaction is an IOMMU-initiated implicit memory access then the
IO bridge signals such access faults to the IOMMU itself. The details of such
signaling is implementation defined.</p>
</div>
<div class="paragraph">
<p>If the aborted transaction is a write then the IO bridge may discard the write;
the details of how the write is discarded are implementation defined. If the IO
protocol requires a response for write transactions (e.g., AXI) then a response
as defined by the IO protocol may be generated by the IO bridge (e.g., SLVERR on
BRESP - Write Response channel). For PCIe, for example, write transactions are
posted and no response is returned when a write transaction is discarded.</p>
</div>
<div class="paragraph">
<p>If the faulting transaction is a read then the device expects a completion. The
IO bridge may provide a completion to the device. The data, if returned, in such
completion is implementation defined; usually it is a fixed value such as all 0
or all 1. A status code may be returned to the device in the completion to
indicate this condition. For AXI, for example, the completion status is provided
by SLVERR on RRESP (Read Data channel). For PCIe, for example, the completion
status field may be set to "Unsupported Request" (UR) or "Completer Abort" (CA).</p>
</div>
</div>
<div class="sect2">
<h3 id="RAS"><a class="anchor" href="#RAS"></a>8.4. Reliability, Availability, and Serviceability (RAS)</h3>
<div class="paragraph">
<p>The IOMMU may support a RAS architecture that specifies the methods for
enabling error detection, logging the detected errors (including their severity,
nature, and location), and configuring means to report the error to an error
handler.</p>
</div>
<div style="page-break-after: always;"></div>
<div class="paragraph">
<p>Some errors, such as those in the IOATC, may be correctable by reloading the
cached in-memory data structures when the error is detected. Such errors are not
expected to affect the functioning of the IOMMU.</p>
</div>
<div class="paragraph">
<p>Some errors may corrupt critical internal state of the IOMMU and such errors may
lead the IOMMU to a failed state. Examples of such state may include registers
such as the <code>ddtp</code>, <code>cqb</code>, etc. On entering such a failed state, the IOMMU may
request the IO bridge to abort all incoming transactions.</p>
</div>
<div class="paragraph">
<p>Some errors, such as corruptions that occur within the internal data paths of
the IOMMU, may not be correctable but the effects of such errors may be contained
to the transaction being processed by the IOMMU.</p>
</div>
<div class="paragraph">
<p>As part of processing a transaction, the IOMMU may need to read data from
in-memory data structures such as the DDT, PDT, or first/second-stage page tables.
The provider (a memory controller or a cache) of the data may detect that the
data requested has an uncorrectable error and signal that the data is corrupted
and defer the error to the IOMMU. Such technique to defer the handling of the
corrupted data to the consumer of the data is also commonly known as data
poisoning. The effects of such errors may be contained to the transaction that
caused the corrupted data to be accessed.</p>
</div>
<div class="paragraph">
<p>In the cases where the error affects the transaction being processed but
otherwise allows the IOMMU to continue providing service, the IOMMU may abort
(see <a href="#IOBR_FAULT_RESP">Section 8.3</a>) the transaction and report the the fault by queuing
a fault record in the <code>FQ</code>. For PCIe, for example, a "Completer Abort (CA)"
response is appropriate to abort the transaction. The following cause codes are
used to report such faulting transactions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>DDT data corruption (cause = 268)</p>
</li>
<li>
<p>PDT data corruption (cause = 269)</p>
</li>
<li>
<p>MSI PT data corruption (cause = 270)</p>
</li>
<li>
<p>MSI MRIF data corruption (cause = 271)</p>
</li>
<li>
<p>Internal data-path error (cause = 272)</p>
</li>
<li>
<p>First/second-stage PT data corruption (cause = 274)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the IO bridge is not capable of signaling such deferred errors uniquely
from other errors that prevent the IOMMU from accessing in-memory data
structures then the IOMMU may report such errors as access faults instead
of using the differentiated data corruption cause codes.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="extensions"><a class="anchor" href="#extensions"></a>9. IOMMU Extensions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter specifies the following standard extensions to the IOMMU Base
Architecture:</p>
</div>
<table class="tableblock frame-all grid-all fit-content center">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Specification</th>
<th class="tableblock halign-center valign-top">Version</th>
<th class="tableblock halign-center valign-top">Status</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#QOSID"><strong>Quality-of-Service (QoS) Identifiers Extension</strong></a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>1.0</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Ratified</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#NLINV"><strong>Non-leaf PTE Invalidation Extension</strong></a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>1.0</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Ratified</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><a href="#ARINV"><strong>Address Range Invalidation Extension</strong></a></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>1.0</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Ratified</strong></p></td>
</tr>
</tbody>
</table>
<div class="sect2">
<h3 id="QOSID"><a class="anchor" href="#QOSID"></a>9.1. Quality-of-Service (QoS) Identifiers Extension, Version 1.0</h3>
<div class="paragraph">
<p>Quality of Service (QoS) is defined as the minimal end-to-end performance
guaranteed in advance by a service level agreement (SLA) to a workload.
Performance metrics might include measures such as instructions per cycle (IPC),
latency of service, etc.</p>
</div>
<div class="paragraph">
<p>When multiple workloads execute concurrently on modern processors&#8201;&#8212;&#8201;equipped
with large core counts, multiple cache hierarchies, and multiple memory
controllers&#8201;&#8212;&#8201;the performance of any given workload becomes less
deterministic, or even non-deterministic, due to shared resource contention
cite:[PTCAMP].</p>
</div>
<div class="paragraph">
<p>To manage performance variability, system software needs resource allocation
and monitoring capabilities. These capabilities allow for the reservation of
resources like cache and bandwidth, thus meeting individual performance targets
while minimizing interference cite:[HERACLES]. For resource management, hardware
should provide monitoring features that allow system software to profile
workload resource consumption and allocate resources accordingly.</p>
</div>
<div class="paragraph">
<p>To facilitate this, the QoS Identifiers ISA extension (Ssqosid) cite:[SSQOSID]
introduces the <code>srmcfg</code> register, which configures a hart with two identifiers:
a Resource Control ID (<code>RCID</code>) and a Monitoring Counter ID (<code>MCID</code>). These
identifiers accompany each request issued by the hart to shared resource
controllers.</p>
</div>
<div class="paragraph">
<p>These identifiers are crucial for the RISC-V Capacity and Bandwidth Controller
QoS Register Interface cite:[CBQRI], which provides methods for setting resource
usage limits and monitoring resource consumption. The <code>RCID</code> controls resource
allocations, while the <code>MCID</code> is used for tracking resource usage.</p>
</div>
<div class="paragraph">
<p>The IOMMU QoS ID extension provides a method to associate QoS IDs with requests
to access resources by the IOMMU, as well as with devices governed by it. This
complements the Ssqosid extension that provides a method to associate QoS IDs
with requests originated by the RISC-V harts. Assocating QoS IDs with device
and IOMMU originated requests is required for effective monitoring and
allocation of shared resources.</p>
</div>
<div class="paragraph">
<p>The IOMMU <code>capabilities</code> register (<a href="#CAP">Section 6.3</a>) is extended with a <code>QOSID</code> field
which enumerates support for associating QoS IDs with requests made through the
IOMMU. When <code>capabilities.QOSID</code> is 1, the memory-mapped register layout is
extended to add a register named <code>iommu_qosid</code> (<a href="#IOQOSID">Section 6.27</a>). This register is
used to configure the Quality of Service (QoS) IDs associated with
IOMMU-originated requests. The <code>ta</code> field of the device context (<a href="#DC_TA">Section 3.1.3.3</a>) is
extended with two fields, <code>RCID</code> and <code>MCID</code>, to configure the QoS IDs to
associate with requests originated by the devices.</p>
</div>
<div class="sect3">
<h4 id="reset-behavior-2"><a class="anchor" href="#reset-behavior-2"></a>9.1.1. Reset Behavior</h4>
<div class="paragraph">
<p>If the reset value for <code>ddtp.iommu_mode</code> field is <code>Bare</code>, then the
<code>iommu_qosid.RCID</code> field must have a reset value of 0.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>At reset, it is required that the <code>RCID</code> field of <code>iommu_qosid</code> is set to 0 if
the IOMMU is in <code>Bare</code> mode, as typically the resource controllers in the
SoC default to a reset behavior of associating all capacity or bandwidth to the
<code>RCID</code> value of 0. When the reset value of the <code>ddtp.iommu_mode</code> is not <code>Bare</code>,
the <code>iommu_qosid</code> register should be initialized by software before changing
the mode to allow DMA.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="sizing-qos-identifiers"><a class="anchor" href="#sizing-qos-identifiers"></a>9.1.2. Sizing QoS Identifiers</h4>
<div class="paragraph">
<p>The size (or width) of <code>RCID</code> and <code>MCID</code>, as fields in registers or in data
structures, supported by the IOMMU must be at least as large as that supported
by any RISC-V application processor hart in the system.</p>
</div>
</div>
<div class="sect3">
<h4 id="iommu-atc-capacity-allocation-and-monitoring"><a class="anchor" href="#iommu-atc-capacity-allocation-and-monitoring"></a>9.1.3. IOMMU ATC Capacity Allocation and Monitoring</h4>
<div class="paragraph">
<p>Some IOMMUs might support capacity allocation and usage monitoring in the IOMMU
address translation cache (IOATC) by implementing the capacity controller
register interface.</p>
</div>
<div class="paragraph">
<p>Additionally, some IOMMUs might support multiple IOATCs, each potentially having
different capacities. In scenarios where multiple IOATCs are implemented, such
as an IOATC for each supported page size, the IOMMU can implement a capacity
controller register interface for each IOATC to facilitate individual capacity
allocation.</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
<div class="sect2">
<h3 id="NLINV"><a class="anchor" href="#NLINV"></a>9.2. Non-leaf PTE Invalidation Extension, Version 1.0</h3>
<div class="paragraph">
<p>The RISC-V IOMMU Version 1.0 specification provides commands to invalidate
leaf page table entries from address translation caches when performing an
address-specific invalidation operation. The non-leaf PTE invalidation
extension provides commands to optionally also invalidate non-leaf PTE
entries from the address translation caches when performing an
address-specific invalidation operation.</p>
</div>
<div class="paragraph">
<p>The non-leaf PTE invalidation extension is implemented if the <code>capabilities.NL</code>
(bit 42) is 1. When the <code>capabilities.NL</code> bit is 1, a non-leaf (<code>NL</code>) field is
defined at bit 34 in the <code>IOTINVAL.VMA</code> and <code>IOTINVAL.GVMA</code> commands by this
extension. When the <code>capabilities.NL</code> bit is 0, bit 34 remains reserved.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The non-leaf PTE invalidation extension enables optimizations in shared
virtual addressing use cases by providing the ability to invalidate non-leaf
PTEs corresponding to the IOVA being invalidated from the IOMMU address
translation caches.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the address range invalidation extension is also implemented, the <code>NL</code>
operand applies to the address range determined by the <code>ADDR</code> and <code>S</code> operands.</p>
</div>
<div class="sect3">
<h4 id="non-leaf-pte-invalidation-by-iotinval-vma"><a class="anchor" href="#non-leaf-pte-invalidation-by-iotinval-vma"></a>9.2.1. Non-leaf PTE Invalidation by <code>IOTINVAL.VMA</code></h4>
<div class="ulist">
<ul>
<li>
<p>When the <code>AV</code> operand is 0, the <code>NL</code> operand is ignored and the <code>IOTINVAL.VMA</code>
command operations are as specified in RISC-V IOMMU Version 1.0 specification.</p>
</li>
<li>
<p>When the <code>AV</code> operand is 1 and the <code>NL</code> operand is 0, the <code>IOTINVAL.VMA</code>
command operations are as specified in RISC-V IOMMU Version 1.0 specification.</p>
</li>
<li>
<p>When both the <code>AV</code> and <code>NL</code> operands are 1, the <code>IOTINVAL.VMA</code> command
performs the following operations:</p>
<div class="ulist">
<ul>
<li>
<p>When <code>GV=0</code> and <code>PSCV=0</code>: Invalidates information cached from all levels of
first-stage page table entries corresponding to the IOVA in the <code>ADDR</code>
operand for all host address spaces, including entries containing global
mappings.</p>
</li>
<li>
<p>When <code>GV=0</code> and <code>PSCV=1</code>: Invalidates information cached from all levels of
first-stage page table entries corresponding to the IOVA in the <code>ADDR</code>
operand and the host address space identified by the <code>PSCID</code> operand, except
for entries containing global mappings.</p>
</li>
<li>
<p>When <code>GV=1</code> and <code>PSCV=0</code>: Invalidates information cached from all levels of
first-stage page table entries corresponding to the IOVA in the <code>ADDR</code>
operand for all VM address spaces associated with the <code>GSCID</code> operand,
including entries that contain global mappings.</p>
</li>
<li>
<p>When <code>GV=1</code> and <code>PSCV=1</code>: Invalidates information cached from all levels of
first-stage page table entries corresponding to the IOVA in the <code>ADDR</code>
operand and the VM address space identified by the <code>PSCID</code> and <code>GSCID</code>
operands, except for entries containing global mappings.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="non-leaf-pte-invalidation-by-iotinval-gvma"><a class="anchor" href="#non-leaf-pte-invalidation-by-iotinval-gvma"></a>9.2.2. Non-leaf PTE Invalidation by <code>IOTINVAL.GVMA</code></h4>
<div class="ulist">
<ul>
<li>
<p>When the <code>GV</code> operand is 0, both the <code>AV</code> and <code>NL</code> operands are ignored and
the <code>IOTINVAL.GVMA</code> command operations are as specified in RISC-V IOMMU
Version 1.0 specification.</p>
</li>
<li>
<p>When the <code>GV</code> operand is 1 and the <code>AV</code> operand is 0, the <code>NL</code> operand is
ignored and the <code>IOTINVAL.GVMA</code> command operations are as specified in
RISC-V IOMMU Version 1.0 specification.</p>
</li>
<li>
<p>When the <code>GV</code> and <code>AV</code> operands are 1 and the <code>NL</code> operand is 0, the
<code>IOTINVAL.GVMA</code> command operations are as specified in RISC-V IOMMU Version
1.0 specification.</p>
</li>
<li>
<p>When <code>GV</code>, <code>AV</code>, and <code>NL</code> are all 1, the <code>IOTINVAL.GVMA</code> command performs the
following operations:</p>
<div class="ulist">
<ul>
<li>
<p>Invalidates information cached from all levels of second-stage page table
entries corresponding to the guest-physical address in the <code>ADDR</code> operand and
the VM address spaces identified by the <code>GSCID</code> operand.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
<div class="sect2">
<h3 id="ARINV"><a class="anchor" href="#ARINV"></a>9.3. Address Range Invalidation Extension, Version 1.0</h3>
<div class="paragraph">
<p>The address range invalidation extension enables specifying a range of addresses
in an IOMMU ATC invalidation command, reducing the number of commands queued to
the IOMMU. This facility is especially useful when superpages are employed in
page tables.</p>
</div>
<div class="paragraph">
<p>The address range invalidation extension is implemented if <code>capabilities.S</code> (bit
43) is 1. When <code>capabilities.S</code> is 1, a range-size (<code>S</code>) operand is defined at
bit 73 in the <code>IOTINVAL.VMA</code> and <code>IOTINVAL.GVMA</code> commands by this extension.
When the <code>capabilities.S</code> bit is 0, bit 73 remains reserved.</p>
</div>
<div class="paragraph">
<p>When the <code>GV</code> operand is 0, both the <code>AV</code> and <code>S</code> operands are ignored by the
<code>IOTINVAL.GVMA</code> command. When the <code>AV</code> operand is 0, the <code>S</code> operand is ignored
in both the <code>IOTINVAL.VMA</code> and <code>IOTINVAL.GVMA</code> commands. When the <code>S</code> operand is
ignored or set to 0, the operations of the <code>IOTINVAL.VMA</code> and <code>IOTINVAL.GVMA</code>
commands are as specified in the RISC-V IOMMU Version 1.0 specification.</p>
</div>
<div class="paragraph">
<p>When the <code>S</code> operand is not ignored and is 1, the <code>ADDR</code> operand represents a
NAPOT range encoded in the operand itself. Starting from bit position 0
of the <code>ADDR</code> operand, if the first 0 bit is at position <code>X</code>, the range size is
<code>2<sup>(X+1)</sup> * 4</code> KiB. When <code>X</code> is 0, the size of the range is 8 KiB.</p>
</div>
<div class="paragraph">
<p>If the <code>S</code> operand is not ignored and is 1 and all bits of the <code>ADDR</code> operand
are 1, the behavior is UNSPECIFIED.</p>
</div>
<div class="paragraph">
<p>If the <code>S</code> operand is not ignored and is 1 and the most significant bit of the
<code>ADDR</code> operand is 0 while all other bits are 1, the specified address range
covers the entire address space.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The NAPOT range encoding used by this extension follows the convention used by
PCIe ATS Invalidation Requests to denote address ranges. This convention is also
used to encode the translation range size in <code>tr_response</code> (<a href="#TRR_RSP">Section 6.26</a>)
register.</p>
</div>
<div class="paragraph">
<p>Simpler implementations may invalidate all address-translation cache entries
when the <code>S</code> bit is set to 1.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Unresolved include directive in modules/ROOT/pages/riscv-iommu.adoc - include::bibliography.adoc[]</p>
</div>
</div>
</div>
</div>
</article>  </div>
</main>
<div class="modal micromodal-slide" id="modal-versions" aria-hidden="true">
    <div class="modal__overlay" tabindex="-1" data-micromodal-close>
        <div class="modal__container" role="dialog" aria-modal="true">
            <main class="modal__content" id="modal-versions-content">
              <button data-micromodal-close class="modal-versions-close">
                <svg width="28px" height="28px" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><defs><style>.cls-1h{fill:none;stroke:#000;stroke-linecap:round;stroke-linejoin:round;stroke-width:2px;}</style></defs><title/><g id="cross"><line class="cls-1h" x1="7" x2="25" y1="7" y2="25"/><line class="cls-1h" x1="7" x2="25" y1="25" y2="7"/></g></svg>
              </button>
              <div class="colset">
                <div class="col-left">

                  <ul class="nav-versions">
                      <li class="component">
                        <div>
                          <a class="title" href="../../ffh/v1.0/index.html">ACPI Functional Fixed Hardware</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../ffh/v1.0/index.html">
      v1.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="../../aia/v1.0/index.html">Advanced Interrupt Architecture</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../aia/v1.0/index.html">
      v1.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="../../etrace/v1.0/index.html">E-Trace Encapsulation Specification</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../etrace/v1.0/index.html">
      v1.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="../../psabi/v1.0/index.html">ELF psABI Specification</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../psabi/v1.0/index.html">
      v1.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="index.html">IOMMU Architecture</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="index.html">
      v1.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="../../isa/index.html">ISA Specifications</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../isa/index.html">
      default
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="../../reri/v1.0/index.html">RERI Architecture</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../reri/v1.0/index.html">
      v1.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="../../qos/v1.0/index.html">RISC-V Capacity and Bandwidth QoS Register Interface</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../qos/v1.0/index.html">
      v1.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="../../plic/v1.0.0/index.html">RISC-V Platform-Level Interrupt Controller</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../plic/v1.0.0/index.html">
      v1.0.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="../../semihost/v1.0/index.html">semihosting</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../semihost/v1.0/index.html">
      v1.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                  </ul>
                </div>
                <div class="col-right">
                  <ul class="projects">
  <li>
    Related Spring Documentation
    <ul class="projects-list">
        <li>
<a href="https://docs.spring.io/spring-boot/">
  Spring Boot
</a>
</li>
        <li>
<a href="https://docs.spring.io/spring-framework/reference/">
  Spring Framework
</a>
</li>
        <li>
<a class="anchor"><i class="fa fa-angle-right" aria-hidden="true"></i></a>
  Spring Cloud
<ul>
    <li>
<a href="https://docs.spring.io/spring-cloud-build/reference/">
  Spring Cloud Build
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-bus/reference/">
  Spring Cloud Bus
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-circuitbreaker/reference/">
  Spring Cloud Circuit Breaker
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-commons/reference/">
  Spring Cloud Commons
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-config/reference/">
  Spring Cloud Config
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-consul/reference/">
  Spring Cloud Consul
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-contract/reference/">
  Spring Cloud Contract
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-function/reference/">
  Spring Cloud Function
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-gateway/reference/">
  Spring Cloud Gateway
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-kubernetes/reference/">
  Spring Cloud Kubernetes
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-netflix/reference/">
  Spring Cloud Netflix
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-openfeign/reference/">
  Spring Cloud OpenFeign
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-stream/reference/">
  Spring Cloud Stream
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-task/reference/">
  Spring Cloud Task
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-vault/reference/">
  Spring Cloud Vault
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-zookeeper/reference/">
  Spring Cloud Zookeeper
</a>
</li>
</ul>
</li>
        <li>
<a class="anchor"><i class="fa fa-angle-right" aria-hidden="true"></i></a>
  Spring Data
<ul>
    <li>
<a href="https://docs.spring.io/spring-data/cassandra/reference/">
  Spring Data Cassandra
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-data/commons/reference/">
  Spring Data Commons
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-data/couchbase/reference/">
  Spring Data Couchbase
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-data/elasticsearch/reference/">
  Spring Data Elasticsearch
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-data/jpa/reference/">
  Spring Data JPA
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-data/keyvalue/reference/">
  Spring Data KeyValue
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-data/ldap/reference/">
  Spring Data LDAP
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-data/mongodb/reference/">
  Spring Data MongoDB
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-data/neo4j/reference/">
  Spring Data Neo4j
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-data/redis/reference/">
  Spring Data Redis
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-data/relational/reference/">
  Spring Data JDBC &amp; R2DBC
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-data/rest/reference/">
  Spring Data REST
</a>
</li>
</ul>
</li>
        <li>
<a href="https://docs.spring.io/spring-integration/reference/">
  Spring Integration
</a>
</li>
        <li>
<a href="https://docs.spring.io/spring-batch/reference/">
  Spring Batch
</a>
</li>
        <li>
<a class="anchor"><i class="fa fa-angle-right" aria-hidden="true"></i></a>
<a href="https://docs.spring.io/spring-security/reference/">
  Spring Security
</a>
<ul>
    <li>
<a href="https://docs.spring.io/spring-authorization-server/reference/">
  Spring Authorization Server
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-ldap/reference/">
  Spring LDAP
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-security-kerberos/reference/">
  Spring Security Kerberos
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-session/reference/">
  Spring Session
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-vault/reference/">
  Spring Vault
</a>
</li>
</ul>
</li>
        <li>
<a href="https://docs.spring.io/spring-ai/reference/">
  Spring AI
</a>
</li>
        <li>
<a href="https://docs.spring.io/spring-amqp/reference/">
  Spring AMQP
</a>
</li>
        <li>
<a href="https://docs.spring.io/spring-cli/reference/">
  Spring CLI
</a>
</li>
        <li>
<a href="https://docs.spring.io/spring-graphql/reference/">
  Spring GraphQL
</a>
</li>
        <li>
<a href="https://docs.spring.io/spring-kafka/reference/">
  Spring for Apache Kafka
</a>
</li>
        <li>
<a href="https://docs.spring.io/spring-modulith/reference/">
  Spring Modulith
</a>
</li>
        <li>
<a href="https://docs.spring.io/spring-pulsar/reference/">
  Spring for Apache Pulsar
</a>
</li>
        <li>
<a href="https://docs.spring.io/spring-shell/reference/">
  Spring Shell
</a>
</li>
    </ul>
  </li
  <li><a href="../../spring-projects.html">All Docs...</a></li>
</ul>
                </div>
              </div>
            </main>
        </div>
    </div>
</div>

</div>
<footer class="hidden">
</footer><script src="../../_/js/vendor/import.js"></script>
<script src="../../_/js/site.js"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
<script async src="../../_/js/vendor/spring-tabs.js" data-sync-storage-key="docs:preferred-tab"></script>
  </body>
</html>
