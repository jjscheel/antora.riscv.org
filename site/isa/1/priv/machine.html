<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Untitled :: RISC-V ISA Documentation Library Antora Demo Site</title>
    <link rel="canonical" href="https://docs.riscv.org/isa/1/priv/machine.html">
    <meta name="generator" content="Antora 3.1.10">
    <link rel="stylesheet" href="../../../_/css/site.css">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://docs.riscv.org">RISC-V ISA Documentation Library Antora Demo Site</a>
      <div class="navbar-item search hide-for-print">
        <div id="search-field" class="field">
          <input id="search-input" type="text" placeholder="Search the docs">
        </div>
      </div>
      <button class="navbar-burger" aria-controls="topbar-nav" aria-expanded="false" aria-label="Toggle main menu">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="isa" data-version="1">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="../index.html">ISA Specifications</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Volume I: RISC-V Unprivileged ISA Specification</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/colophon.html">Preface</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/intro.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/rv32.html">RV32I Base Integer Instruction Set, Version 2.1</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/rv32e.html">RV32E and RV64E Base Integer Instruction Sets, Version 2.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/rv64.html">RV64I Base Integer Instruction Set, Version 2.1</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/rv128.html">RV128I Base Integer Instruction Set, Version 1.7</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/zifencei.html">"Zifencei" Extension for Instruction-Fetch Fence, Version 2.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/zicsr.html">"Zicsr", Extension for Control and Status Register (CSR) Instructions, Version 2.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/counters.html">"Zicntr" and "Zihpm" Extensions for Counters, Version 2.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/zihintntl.html">"Zihintntl" Extension for Non-Temporal Locality Hints, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/zihintpause.html">"Zihintpause" Extension for Pause Hint, Version 2.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/zimop.html">"Zimop" Extension for May-Be-Operations, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/zicond.html">"Zicond" Extension for Integer Conditional Operations, Version 1.0.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/m-st-ext.html">"M" Extension for Integer Multiplication and Division, Version 2.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/a-st-ext.html">"A" Extension for Atomic Instructions, Version 2.1</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/zawrs.html">"Zawrs" Extension for Wait-on-Reservation-Set instructions, Version 1.01</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/zacas.html">"Zacas" Extension for Atomic Compare-and-Swap (CAS) Instructions, Version 1.0.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/zabha.html">"Zabha" Extension for Byte and Halfword Atomic Memory Operations, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/rvwmo.html">RVWMO Memory Consistency Model, Version 2.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/ztso-st-ext.html">"Ztso" Extension for Total Store Ordering, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/cmo.html">"CMO" Extensions for Base Cache Management Operation ISA, Version 1.0.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/f-st-ext.html">"F" Extension for Single-Precision Floating-Point, Version 2.2</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/d-st-ext.html">"D" Extension for Double-Precision Floating-Point, Version 2.2</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/q-st-ext.html">"Q" Extension for Quad-Precision Floating-Point, Version 2.2</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/zfh.html">"Zfh" and "Zfhmin" Extensions for Half-Precision Floating-Point, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/bfloat16.html">"BF16" Extensions for for BFloat16-precision Floating-Point, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/zfa.html">"Zfa" Extension for Additional Floating-Point Instructions, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/zfinx.html">"Zfinx", "Zdinx", "Zhinx", "Zhinxmin" Extensions for Floating-Point in Integer Registers, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/c-st-ext.html">"C" Extension for Compressed Instructions, Version 2.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/zc.html">"Zc*" Extension for Code Size Reduction, Version 1.0.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/b-st-ext.html">"B" Extension for Bit Manipulation, Version 1.0.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/p-st-ext.html">"P" Extension for Packed-SIMD Instructions, Version 0.2</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/v-st-ext.html">"V" Standard Extension for Vector Operations, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/scalar-crypto.html">Cryptography Extensions: Scalar &amp; Entropy Source Instructions, Version 1.0.1</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/vector-crypto.html">Cryptography Extensions: Vector Instructions, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/unpriv-cfi.html">Control-flow Integrity (CFI)</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/rv-32-64g.html">RV32/64G Instruction Set Listings</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/extending.html">Extending RISC-V</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/naming.html">ISA Extension Naming Conventions</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/history.html">History and Acknowledgments</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/mm-eplan.html">Appendix A: RVWMO Explanatory Material, Version 0.1</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/mm-formal.html">Appendix B: Formal Memory Model Specifications, Version 0.1</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/vector-examples.html">Appendix C: Vector Assembly Code Examples</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../unpriv/calling-convention.html">Appendix D: Calling Convention for Vector State (Not authoritative - Placeholder Only)</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Volume II: RISC-V Privileged ISA Specification</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="priv-intro.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="priv-csrs.html">Control and Status Registers (CSRs)</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="machine.html">Machine-Level ISA, Version 1.13</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="indirect-csr.html">"Smcsrind/Sscsrind" Indirect CSR Access, version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="smcntrpmf.html">"Smcntrpmf" Cycke and Instret Privilege Mode Filtering, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="rnmi.html">"Smrnmi" Extension for Resumable Non-Maskable Interrupts, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="smcdeleg.html">"Smcdeleg" Counter Delegation Extension, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="hypervisor.html">"H" Extension for Hypervisor Support, Version 1.0</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="priv-cfi.html">Control-flow Integrity(CFI)</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="priv-insns.html">RISC-V Privileged Instruction Set Listings</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="priv-history.html">History</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="bibliography.html">Bibliography</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">ISA Specifications</span>
    <span class="version">1</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <div class="title"><a href="../index.html">ISA Specifications</a></div>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../riscv-library/0.1/index.html">RISC-V Documentation Library</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../riscv-library/0.1/index.html">0.1</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../riscv-library/0.1/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">ISA Specifications</a></li>
    <li>Volume II: RISC-V Privileged ISA Specification</li>
    <li><a href="machine.html">Machine-Level ISA, Version 1.13</a></li>
  </ul>
</nav>
<div class="edit-this-page"><a href="https://github.com/riscv/riscv-isa-manual/edit/antora-refactor/modules/priv/pages/machine.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<div class="sect1">
<h2 id="machine"><a class="anchor" href="#machine"></a>Machine-Level ISA, Version 1.13</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter describes the machine-level operations available in
machine-mode (M-mode), which is the highest privilege mode in a RISC-V
hart. M-mode is used for low-level access to a hardware platform and
is the first mode entered at reset. M-mode can also be used to implement
features that are too difficult or expensive to implement in hardware
directly. The RISC-V machine-level ISA contains a common core that is
extended depending on which other privilege levels are supported and
other details of the hardware implementation.</p>
</div>
<div class="sect2">
<h3 id="_machine_level_csrs"><a class="anchor" href="#_machine_level_csrs"></a>Machine-Level CSRs</h3>
<div class="paragraph">
<p>In addition to the machine-level CSRs described in this section, M-mode
code can access all CSRs at lower privilege levels.</p>
</div>
<div class="sect3">
<h4 id="misa"><a class="anchor" href="#misa"></a>Machine ISA (<code>misa</code>) Register</h4>
<div class="paragraph">
<p>The <code>misa</code> CSR is a <strong>WARL</strong> read-write register reporting the ISA supported by the hart. This register must be readable in any implementation, but a value of zero can be returned to indicate the <code>misa</code> register has not been implemented, requiring that CPU capabilities be determined through a separate non-standard mechanism.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNrNVD1vwjAQ3fkVJ0-JKkv5KFB560An2qFLKyEGp3EgqrEj-ypoUf57nQYQIU0BUVWdIt_de_f8cj4vFRlHNBZYIXmuYLL5rlmmFdKML3L5DuT-CsIC7riUCX95JVBnbf4hIByUU7_nOSIweknnIp_NEeIAGkGeCkMzBSqXm7gUGdIFNzPXLQyCbXWFbocTvRKWFo7D0UEc-T0XN3xJXcKpex6PHmhInGpbcAUDYIk2rqOFdVn67dLo9NJ4V9oHhmKFlKuXuTZALHKDpBsfDSpoZ7a_Ix6eSRx0IoVKD3EHN5qELJju3_4nPKv-0fZM35QRkqNIHUgX34UTjagX7UxTv1e1BOI93T6OfbKdtGU9NyTRMiWl36Ww5c1lWva8jI94cWYf6DDvAi_i3_YC2NdzO2rSaIVC2VwrO4n6-_Mz_PeeDf_Us8YD37kURkf30c0pC6leKDXldbPsE8pW88A=" alt="Machine ISA register (misa)">
</div>
<div class="title">Figure 1. Machine ISA register (misa)</div>
</div>
<div class="paragraph">
<p>The MXL (Machine XLEN) field encodes the native base integer ISA width as
shown in <a href="#misabase">Encoding of MXL field in <code>misa</code></a>. The MXL field is read-only.  If <code>misa</code> is nonzero, the
MXL field indicates the effective XLEN in M-mode, a constant termed <em>MXLEN</em>.
XLEN is never greater than MXLEN, but XLEN might be smaller than MXLEN in
less-privileged modes.</p>
</div>
<table id="misabase" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 1. Encoding of MXL field in <code>misa</code></caption>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-right valign-top">MXL</th>
<th class="tableblock halign-right valign-top">XLEN</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">1<br>
2<br>
3</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">32<br>
64<br>
128</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The <code>misa</code> CSR is MXLEN bits wide.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The base width can be quickly ascertained using branches on the sign of
the returned <code>misa</code> value, and possibly a shift left by one and a second
branch on the sign. These checks can be written in assembly code without
knowing the register width (MXLEN) of the hart. The base width is
given by <em>MXLEN=2<sup>MXL+4</sup></em>.</p>
</div>
<div class="paragraph">
<p>The base width can also be found if <code>misa</code> is zero, by placing the
immediate 4 in a register, then shifting the register left by 31 bits at
a time. If zero after one shift, then the hart is RV32. If zero after
two shifts, then the hart is RV64, else RV128.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The Extensions field encodes the presence of the standard extensions,
with a single bit per letter of the alphabet (bit 0 encodes presence of
extension "A" , bit 1 encodes presence of extension "B", through to
bit 25 which encodes "Z"). The "I" bit will be set for RV32I, RV64I,
and RV128I base ISAs, and the "E" bit will be set for RV32E and RV64E. The
Extensions field is a <strong>WARL</strong> field that can contain writable bits where the
implementation allows the supported ISA to be modified. At reset, the
Extensions field shall contain the maximal set of supported extensions,
and "I" shall be selected over "E" if both are available.</p>
</div>
<div class="paragraph">
<p>When a standard extension is disabled by clearing its bit in <code>misa</code>, the
instructions and CSRs defined or modified by the extension revert to
their defined or reserved behaviors as if the extension is not
implemented.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>For a given RISC-V execution environment, an instruction, extension, or
other feature of the RISC-V ISA is ordinarily judged to be <em>implemented</em>
or not by the observable execution behavior in that environment. For
example, the F extension is said to be implemented for an execution
environment if and only if the instructions that the RISC-V Unprivileged
ISA defines for F execute as specified.</p>
</div>
<div class="paragraph">
<p>With this definition of <em>implemented</em>, disabling an extension by
clearing its bit in <code>misa</code> results in the extension being considered
<em>not implemented</em> in M-mode. For example, setting <code>misa</code>.F=0 results in
the F extension being not implemented for M-mode, because the F
extension&#8217;s instructions will not act as the Unprivileged ISA requires
but may instead raise an illegal-instruction exception.</p>
</div>
<div class="paragraph">
<p>Defining the term <em>implemented</em> based strictly on the observable
behavior might conflict with other common understandings of the same
word. In particular, although common usage may allow for the combination
"implemented but disabled," in this document it is considered a
contradiction of terms, because <em>disabled</em> implies execution will not
behave as required for the feature to be considered <em>implemented</em>. In
the same vein, "implemented and enabled" is redundant here;
"implemented" suffices.</p>
</div>
</td>
</tr>
</table>
</div>
<table class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 2. Encoding of Extensions field in <code>misa</code>.  All bits that are reserved for future use must return zero when read.</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-right valign-top">Bit</th>
<th class="tableblock halign-right valign-top">Character</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">0<br>
1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
10<br>
11<br>
12<br>
13<br>
14<br>
15<br>
16<br>
17<br>
18<br>
19<br>
20<br>
21<br>
22<br>
23<br>
24<br>
25<br></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">A<br>
B<br>
C<br>
D<br>
E<br>
F<br>
G<br>
H<br>
I<br>
J<br>
K<br>
L<br>
M<br>
N<br>
O<br>
P<br>
Q<br>
R<br>
S<br>
T<br>
U<br>
V<br>
W<br>
X<br>
Y<br>
Z</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Atomic extension<br>
B extension<br>
Compressed extension<br>
Double-precision floating-point extension<br>
RV32E/64E base ISA<br>
Single-precision floating-point extension<br>
<em>Reserved</em><br>
Hypervisor extension<br>
RV32I/64I/128I base ISA<br>
<em>Reserved</em><br>
<em>Reserved</em><br>
<em>Reserved</em><br>
Integer Multiply/Divide extension<br>
<em>Tentatively reserved for User-Level Interrupts extension</em><br>
<em>Reserved</em><br>
<em>Tentatively reserved for Packed-SIMD extension</em><br>
Quad-precision floating-point extension<br>
<em>Reserved</em><br>
Supervisor mode implemented<br>
<em>Reserved</em><br>
User mode implemented<br>
Vector extension<br>
<em>Reserved</em><br>
Non-standard extensions present<br>
<em>Reserved</em><br>
<em>Reserved</em></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The design of the RV128I base ISA is not yet complete, and while much of
the remainder of this specification is expected to apply to RV128, this
version of the document focuses only on RV32 and RV64.</p>
</div>
<div class="paragraph">
<p>The "U" and "S" bits will be set if there is support for user and
supervisor modes respectively.</p>
</div>
<div class="paragraph">
<p>The "X" bit will be set if there are any non-standard extensions.</p>
</div>
<div class="paragraph">
<p>When "B" bit is 1, the implementation supports the instructions provided by the
Zba, Zbb, and Zbs extensions. When "B" bit is 0, it indicates that the
implementation may not support one or more of the Zba, Zbb, or Zbs extensions.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>misa</code> CSR exposes a rudimentary catalog of CPU features to
machine-mode code. More extensive information can be obtained in machine
mode by probing other machine registers, and examining other ROM storage
in the system as part of the boot process.</p>
</div>
<div class="paragraph">
<p>We require that lower privilege levels execute environment calls instead
of reading CPU registers to determine features available at each
privilege level. This enables virtualization layers to alter the ISA
observed at any level, and supports a much richer command interface
without burdening hardware designs.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The "E" bit is read-only. Unless <code>misa</code> is all read-only zero, the
"E" bit always reads as the complement of the "I" bit. If an
execution environment supports both RV32E and RV32I, software can select
RV32E by clearing the "I" bit.</p>
</div>
<div class="paragraph">
<p>If an ISA feature <em>x</em> depends on an ISA feature <em>y</em>, then attempting to
enable feature <em>x</em> but disable feature <em>y</em> results in both features
being disabled. For example, setting "F"=0 and "D"=1 results in both
"F" and "D" being cleared.</p>
</div>
<div class="paragraph">
<p>An implementation may impose additional constraints on the collective
setting of two or more <code>misa</code> fields, in which case they function
collectively as a single <strong>WARL</strong> field. An attempt to write an unsupported combination causes those bits to be set to some supported combination.</p>
</div>
<div class="paragraph">
<p>Writing <code>misa</code> may increase IALIGN, e.g., by disabling the "C"
extension. If an instruction that would write <code>misa</code> increases IALIGN,
and the subsequent instruction&#8217;s address is not IALIGN-bit aligned, the
write to <code>misa</code> is suppressed, leaving <code>misa</code> unchanged.</p>
</div>
<div class="paragraph">
<p>When software enables an extension that was previously disabled, then
all state uniquely associated with that extension is UNSPECIFIED, unless otherwise specified by that extension.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Although one of the bits 25&#8212;&#8203;0 in <code>misa</code> being set to 1 implies that
the corresponding feature is implemented, the inverse is not necessarily
true: one of these bits being clear does not necessarily imply that the
corresponding feature is not implemented.  This follows from the fact that,
when a feature is not implemented, the corresponding opcodes and CSRs become
reserved, not necessarily illegal.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_machine_vendor_id_mvendorid_register"><a class="anchor" href="#_machine_vendor_id_mvendorid_register"></a>Machine Vendor ID (<code>mvendorid</code>) Register</h4>
<div class="paragraph">
<p>The <code>mvendorid</code> CSR is a 32-bit read-only register providing the JEDEC
manufacturer ID of the provider of the core. This register must be
readable in any implementation, but a value of 0 can be returned to
indicate the field is not implemented or that this is a non-commercial
implementation.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNqVUMlqwzAQvfcrhjk5FIEXXBcfc-it9ANCDmNbckTGkpHUpgv-98rESevmVBgh8TY9KemkohCch3pk0gZ2y_5VK2uCUDRo_gB8vodshCdibqg94rTf3CXRCs6exEHq_hCgKGEFUiedUAaM5gVnqYIYyPUxP0vTi3p238KNfZdejDEjxkGRz7Cjk2gtvw5myfex53J9nsK5stefErJHqJkayR4SJ9-iUsIOUwT8Mw9xVfMRb7n_TpHhfjNdisYHAG7JHDGW9CMZyEuoY5WgW2JBrHsDOOiuY4lr14tSXoarr4rsbzovV5GNdeevmNYp1U_AVTRrvgHZs49p" alt="Vendor ID register (`mvendorid`)">
</div>
<div class="title">Figure 2. Vendor ID register (<code>mvendorid</code>)</div>
</div>
<div class="paragraph">
<p>JEDEC manufacturer IDs are ordinarily encoded as a sequence of one-byte
continuation codes <code>0x7f</code>, terminated by a one-byte ID not equal to
<code>0x7f</code>, with an odd parity bit in the most-significant bit of each byte.
<code>mvendorid</code> encodes the number of one-byte continuation codes in the
Bank field, and encodes the final byte in the Offset field, discarding
the parity bit. For example, the JEDEC manufacturer ID
<code>0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x8a</code>
(twelve continuation codes followed by <code>0x8a</code>) would be encoded in the
<code>mvendorid</code> CSR as <code>0x60a</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In JEDEC&#8217;s parlance, the bank number is one greater than the number of
continuation codes; hence, the <code>mvendorid</code> Bank field encodes a value
that is one less than the JEDEC bank number.</p>
</div>
<hr>
<div class="paragraph">
<p>Previously the vendor ID was to be a number allocated by RISC-V
International, but this duplicates the work of JEDEC in maintaining a
manufacturer ID standard. At time of writing, registering a manufacturer
ID with JEDEC has a one-time cost of $500.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_machine_architecture_id_marchid_register"><a class="anchor" href="#_machine_architecture_id_marchid_register"></a>Machine Architecture ID (<code>marchid</code>) Register</h4>
<div class="paragraph">
<p>The <code>marchid</code> CSR is an MXLEN-bit read-only register encoding the base
microarchitecture of the hart. This register must be readable in any
implementation, but a value of 0 can be returned to indicate the field
is not implemented. The combination of <code>mvendorid</code> and <code>marchid</code> should
uniquely identify the type of hart microarchitecture that is
implemented.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNqNj0trwzAQhO_5FYtONkVgJxSKb4W2EEh6LoQc1vbKFl1LRlKaPvB_r9yoh_QBgQWh0c6nmawlhSE4D9XIqA3s0vlRKWuCVDhofgOxvYJyhAdkrrF5FtM-X2TRCs4eZU-66wOsruFMxJacVAaM5qQzqSAHdF3kl0XxvT27f8u1fSUvx8iIOFgtZ9nhUTaWD4NJfB9zpu-XBZwie_1OUN5AxVgTe8gcvcRNgp0oBIi_R_z7ctlsnzb3j7KcL_t8yhcpbCwB4tY1vQ7UhIMjWN-JmNmPaGInqGKyoBtkiaw7A2LQbcskfhC-6Ge-2rpT_WnKPwGBoIBU" alt="Machine Architecture ID (`marchid`) register">
</div>
<div class="title">Figure 3. Machine Architecture ID (<code>marchid</code>) register</div>
</div>
<div class="paragraph">
<p>Open-source project architecture IDs are allocated globally by RISC-V
International, and have non-zero architecture IDs with a zero
most-significant-bit (MSB). Commercial architecture IDs are allocated by
each commercial vendor independently, but must have the MSB set and
cannot contain zero in the remaining MXLEN-1 bits.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The intent is for the architecture ID to represent the microarchitecture
associated with the repo around which development occurs rather than a
particular organization. Commercial fabrications of open-source designs
should (and might be required by the license to) retain the original
architecture ID. This will aid in reducing fragmentation and tool
support costs, as well as provide attribution. Open-source architecture
IDs are administered by RISC-V International and should only be
allocated to released, functioning open-source projects. Commercial
architecture IDs can be managed independently by any registered vendor
but are required to have IDs disjoint from the open-source architecture
IDs (MSB set) to prevent collisions if a vendor wishes to use both
closed-source and open-source microarchitectures.</p>
</div>
<div class="paragraph">
<p>The convention adopted within the following Implementation field can be
used to segregate branches of the same architecture design, including by
organization. The <code>misa</code> register also helps distinguish different
variants of a design.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_machine_implementation_id_mimpid_register"><a class="anchor" href="#_machine_implementation_id_mimpid_register"></a>Machine Implementation ID (<code>mimpid</code>) Register</h4>
<div class="paragraph">
<p>The <code>mimpid</code> CSR provides a unique encoding of the version of the
processor implementation. This register must be readable in any
implementation, but a value of 0 can be returned to indicate that the
field is not implemented. The Implementation value should reflect the
design of the RISC-V processor itself and not any surrounding system.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNqNT8tqAzEMvOcrhE-7FMNuQqHsvYVC03Mh5KBN5MRUfmC7zYv993obF5I-oCAQGo1GM9WaFKYUInSeUVtYlH7qlLNJKjSaDyDmN9B6eEDmHlevYljWkyqfQnA7uSW92SaY3cIViGsKUlmwmgvOpJI0GDZZv22aL_Z4_RPu3Z6i9Fkjy8FsOsIBd3Ll-M3Yoh-zz_J-2sDZctRHgvYOOsaeOEIV6D0zCRaiESB-L_Hn5n81f3m6f5btOCzroZ4UszkEiEfjmQzZhEk7K7Ll6NHmSN94nxoXa-h6F84hh6H-ANwpd8s=" alt="Machine Implementation ID (`mimpid`) register">
</div>
<div class="title">Figure 4. Machine Implementation ID (<code>mimpid</code>) register</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The format of this field is left to the provider of the architecture
source code, but will often be printed by standard tools as a
hexadecimal string without any leading or trailing zeros, so the
Implementation value can be left-justified (i.e., filled in from
most-significant nibble down) with subfields aligned on nibble
boundaries to ease human readability.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_hart_id_mhartid_register"><a class="anchor" href="#_hart_id_mhartid_register"></a>Hart ID (<code>mhartid</code>) Register</h4>
<div class="paragraph">
<p>The <code>mhartid</code> CSR is an MXLEN-bit read-only register containing the
integer ID of the hardware thread running the code. This register must
be readable in any implementation. Hart IDs might not necessarily be
numbered contiguously in a multiprocessor system, but at least one hart
must have a hart ID of zero. Hart IDs must be unique within the
execution environment.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNqNj0trwzAQhO_5FcuebIrATigUn9uSQNNzIeSwtteO6Foyktr0gf975UY9pA8oLAiNdj7NZC13FILzUI1C2sAune9VZ01QHQ1aXgG3F1COcEsiNTWPOO3zRRat4OxRHVj3hwCrSzgTqWWnOgNGS9KFu6AGcn3kl0XxtT27f8q1fWGvxsiIOFgtZ9nRUTVWngaT-D7mTN8vCzhF9vqNobyCSqhm8ZA5fo6bDDssEPD3wT9f_jfbh7ube1XOl30-5YsUNpYAXJMLsLnGmNWPZGIXqGKioBsSRaJ7AzjothXGb85P6pmvtu5Ue5ryD0gefQA=" alt="Hart ID (`mhartid`) register">
</div>
<div class="title">Figure 5. Hart ID (<code>mhartid</code>) register</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In certain cases, we must ensure exactly one hart runs some code (e.g.,
at reset), and so require one hart to have a known hart ID of zero.</p>
</div>
<div class="paragraph">
<p>For efficiency, system implementers should aim to reduce the magnitude
of the largest hart ID used in a system.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_machine_status_mstatus_and_mstatush_registers"><a class="anchor" href="#_machine_status_mstatus_and_mstatush_registers"></a>Machine Status (<code>mstatus</code> and <code>mstatush</code>) Registers</h4>
<div class="paragraph">
<p>The <code>mstatus</code> register is an MXLEN-bit read/write register formatted as
shown in <a href="#mstatusreg-rv32">Machine-mode status (<code>mstatus</code>) register for RV32</a> for RV32 and
<a href="#mstatusreg">Machine-mode status (<code>mstatus</code>) register for RV64</a> for RV64. The <code>mstatus</code> register
keeps track of and controls the hart’s current operating state. A
restricted view of <code>mstatus</code> appears as the <code>sstatus</code> register in the
S-level ISA.</p>
</div>
<div id="mstatusreg-rv32" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqd0U0LgkAQgOF7v2JuXvbgSnTYY2ggtDDs-gXiwWQ1obbIbuJ_zy6R4CzR-ZkXhpnxYToB5QZgPPXPQQBwBra-GgFejir2JrZqOo4ocmXyv0wj3aV7kqQj04hLCj6U6ZILv6JYIjr94M6LNf7eWWXkzqkks0JRlGRkleSkaEVfLjoiiWGypN1vDw7fUjFobrbtOzFeamvmkfls5-FeN0ZwP9hO0wspUrw3?id=mstatusreg-rv32" alt="Machine-mode status (`mstatus`) register for RV32">
</div>
<div class="title">Figure 6. Machine-mode status (<code>mstatus</code>) register for RV32</div>
</div>
<div id="mstatusreg" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqd0kELgjAUB_B7n-LdvOygIgS7FVoIDsamUxAPJsuEsshu4nevLqXhG-H5tz97_N_r77qmkK8A-kPz6CiAQ6AtL5qClXIRWgOZNRkGGJlibFlMcjyXbFFihpjkfEruh5TMHWoXGDPOjb4zx7M5Hs8sFDpzwtBYJjCKFZqKU1SkwJsLIo6iH09pbVjwt5Qki4ylyVkffWs4Apz2aoOvQS26b1M37Kcb1_7v-P23FASqa3tsatqfy1a_nngETt2trDR1bNcbhifBhQkY?id=mstatusreg" alt="Machine-mode status (`mstatus`) register for RV64">
</div>
<div class="title">Figure 7. Machine-mode status (<code>mstatus</code>) register for RV64</div>
</div>
<div class="paragraph">
<p>For RV32 only, <code>mstatush</code> is a 32-bit read/write register formatted as
shown in <a href="#mstatushreg">Additional machine-mode status (<code>mstatush</code>) register  for RV32.</a>. Bits 30:4 of <code>mstatush</code> generally contain the same fields found in bits 62:36 of <code>mstatus</code> for RV64. Fields SD, SXL, and UXL do not exist in <code>mstatush</code>.</p>
</div>
<div id="mstatushreg" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UlAw0VHIS8xNtVJQDw8I8lSv1UGSM4TLBTu54pLyxS3lHuaIU1dAGC4pfO7wDXD1CcAp6RKCImWEaWasjkJyfl5aZrpVdU5iXipIkY5CRnFBYnKqlaGBkUltLQAz31DE?id=mstatushreg" alt="Additional machine-mode status (`mstatush`) register  for RV32.">
</div>
<div class="title">Figure 8. Additional machine-mode status (<code>mstatush</code>) register  for RV32.</div>
</div>
<div class="sect4">
<h5 id="privstack"><a class="anchor" href="#privstack"></a>Privilege and Global Interrupt-Enable Stack in <code>mstatus</code> register</h5>
<div class="paragraph">
<p>Global interrupt-enable bits, MIE and SIE, are provided for M-mode and
S-mode respectively. These bits are primarily used to guarantee
atomicity with respect to interrupt handlers in the current privilege
mode.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The global <em>x</em>IE bits are located in the low-order bits of <code>mstatus</code>,
allowing them to be atomically set or cleared with a single CSR
instruction.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When a hart is executing in privilege mode <em>x</em>, interrupts are globally
enabled when <em>x</em>IE=1 and globally disabled when <em>x</em>IE=0. Interrupts for
lower-privilege modes, <em>w</em>&lt;<em>x</em>, are always globally
disabled regardless of the setting of any global <em>w</em>IE bit for the
lower-privilege mode. Interrupts for higher-privilege modes,
<em>y</em>&gt;<em>x</em>, are always globally enabled regardless of the
setting of the global <em>y</em>IE bit for the higher-privilege mode.
Higher-privilege-level code can use separate per-interrupt enable bits
to disable selected higher-privilege-mode interrupts before ceding
control to a lower-privilege mode.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A higher-privilege mode <em>y</em> could disable all of its interrupts before
ceding control to a lower-privilege mode but this would be unusual as it
would leave only a synchronous trap, non-maskable interrupt, or reset as
means to regain control of the hart.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To support nested traps, each privilege mode <em>x</em> that can respond to
interrupts has a two-level stack of interrupt-enable bits and privilege
modes. <em>x</em>PIE holds the value of the interrupt-enable bit active prior
to the trap, and <em>x</em>PP holds the previous privilege mode. The <em>x</em>PP
fields can only hold privilege modes up to <em>x</em>, so MPP is two bits wide
and SPP is one bit wide. When a trap is taken from privilege mode <em>y</em>
into privilege mode <em>x</em>, <em>x</em>PIE is set to the value of <em>x</em>IE; <em>x</em>IE is
set to 0; and <em>x</em>PP is set to <em>y</em>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>For lower privilege modes, any trap (synchronous or asynchronous) is
usually taken at a higher privilege mode with interrupts disabled upon
entry. The higher-level trap handler will either service the trap and
return using the stacked information, or, if not returning immediately
to the interrupted context, will save the privilege stack before
re-enabling interrupts, so only one entry per stack is required.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>An MRET or SRET instruction is used to return from a trap in M-mode or
S-mode respectively. When executing an <em>x</em>RET instruction, supposing
<em>x</em>PP holds the value <em>y</em>, <em>x</em>IE is set to <em>x</em>PIE; the privilege mode is
changed to <em>y</em>; <em>x</em>PIE is set to 1; and <em>x</em>PP is set to the
least-privileged supported mode (U if U-mode is implemented, else M). If
<em>y</em>&#8800;M, <em>x</em>RET also sets MPRV=0.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Setting <em>x</em>PP to the least-privileged supported mode on an <em>x</em>RET helps identify software bugs in the management of the two-level privilege-mode stack.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Trap handlers must be designed to neither enable interrupts nor cause exceptions
during the phase of handling where the trap handler preserves the critical state
information required to handle and resume from the trap. An exception or
interrupt in this critical phase of trap handling may lead to a trap that can
overwrite such critical state. This could result in the loss of data needed to
recover from the initial trap. Further, if an exception occurs in the code path
needed to handle traps, then such a situation may lead to an infinite loop of
traps. To prevent this, trap handlers must be meticulously designed to identify
and safely manage exceptions within their operational flow.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><em>x</em>PP fields are <strong>WARL</strong> fields that can hold only privilege mode <em>x</em> and any implemented privilege mode lower than <em>x</em>. If privilege mode <em>x</em> is not implemented, then <em>x</em>PP must be read-only 0.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>M-mode software can determine whether a privilege mode is implemented by
writing that mode to MPP then reading it back.</p>
</div>
<div class="paragraph">
<p>If the machine provides only U and M modes, then only a single hardware
storage bit is required to represent either 00 or 11 in MPP.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="machine-double-trap"><a class="anchor" href="#machine-double-trap"></a>Double Trap Control in <code>mstatus</code> Register</h5>
<div class="paragraph">
<p>A double trap typically arises during a sensitive phase in trap handling
operations&#8201;&#8212;&#8201;when an exception or interrupt occurs while the trap handler (the
component responsible for managing these events) is in a non-reentrant state.
This non-reentrancy usually occurs in the early phase of trap handling, wherein
the trap handler has not yet preserved the necessary state to handle and resume
from the trap. The occurrence of a trap during this phase can lead to an
overwrite of critical state information, resulting in the loss of data needed to
recover from the initial trap. The trap that caused this critical error
condition is henceforth called the <em>unexpected trap</em>. Trap handlers are designed
to neither enable interrupts nor cause exceptions during this phase of handling.
However, managing Hardware-Error exceptions,  which may occur unpredictably,
presents significant challenges in trap handler implementation due to the
potential risk of a double trap.</p>
</div>
<div class="paragraph">
<p>The M-mode-disable-trap (<code>MDT</code>) bit is a WARL field introduced by the Smdbltrp
extension. Upon reset, the <code>MDT</code> field is set to 1. When the <code>MDT</code> bit is set to
1 by an explicit CSR write, the <code>MIE</code> (Machine Interrupt Enable) bit is cleared
to 0. For RV64, this clearing occurs regardless of the value written, if any, to
the <code>MIE</code> bit by the same write. The <code>MIE</code> bit can only be set to 1 by an
explicit CSR write if the <code>MDT</code> bit is already 0 or, for RV64, is being set to 0
by the same write (For RV32, the <code>MDT</code> bit is in <code>mstatush</code> and the <code>MIE</code> bit in
<code>mstatus</code> register).</p>
</div>
<div class="paragraph">
<p>When a trap is to be taken into M-mode, if the <code>MDT</code> bit is currently 0, it is
then set to 1, and the trap is delivered as expected. However, if <code>MDT</code> is
already set to 1, then this is an <em>unexpected trap</em>. When the Smrnmi extension
is implemented, a trap caused by an RNMI is not considered an <em>unexpected trap</em>
irrespective of the state of the <code>MDT</code> bit. A trap caused by an RNMI does not
set the <code>MDT</code> bit. However, a trap that occurs when executing in M-mode with
<code>mnstatus.NMIE</code> set to 0 is an <em>unexpected trap</em>.</p>
</div>
<div class="paragraph">
<p>In the event of a <em>unexpected trap</em>, the handling is as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When the Smrnmi extension is implemented and <code>mnstatus.NMIE</code> is 1, the hart
traps to the RNMI handler. To deliver this trap, the <code>mnepc</code> and <code>mncause</code>
registers are written with the values that the <em>unexpected trap</em> would have
written to the <code>mepc</code> and <code>mcause</code> registers respectively. The privilege
mode information fields in the <code>mnstatus</code> register are written to indicate
M-mode and its <code>NMIE</code> field is set to 0.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The consequence of this specification is that on occurrence of double trap the
RNMI handler is not provided with information that a trap reports in the
<code>mtval</code> and the <code>mtval2</code> registers. This information, if needed, can be obtained
by the RNMI handler by decoding the instruction at the address in <code>mnepc</code> and
examining its source register contents.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>When the Smrnmi extension is not implemented, or if the Smrnmi extension is
implemented and <code>mnstatus.NMIE</code> is 0, the hart enters a critical-error state
without updating any architectural state, including the <code>pc</code>. This state
involves ceasing execution, disabling all interrupts (including NMIs), and
asserting a <code>critical-error</code> signal to the platform.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The actions performed by the platform when a hart asserts a <code>critical-error</code> signal
are platform-specific. The range of possible actions include restarting
the affected hart or restarting the entire platform, among others.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>MRET</code> and <code>SRET</code> instructions, when executed in M-mode, set the <code>MDT</code> bit
to 0. If the new privilege mode is U, VS, or VU, then <code>sstatus.SDT</code> is also set
to 0. Additionally, if it is VU, then <code>vsstatus.SDT</code> is also set to 0.</p>
</div>
<div class="paragraph">
<p>The <code>MNRET</code> instruction, provided by the Smrnmi extension, sets the <code>MDT</code> bit to
0 if the new privilege mode is not M. If it is U, VS, or VU, then <code>sstatus.SDT</code> is
also set to 0. Additionally, if it is VU, then <code>vsstatus.SDT</code> is also set to 0.</p>
</div>
</div>
<div class="sect4">
<h5 id="xlen-control"><a class="anchor" href="#xlen-control"></a>Base ISA Control in <code>mstatus</code> Register</h5>
<div class="paragraph">
<p>For RV64 harts, the SXL and UXL fields are <strong>WARL</strong> fields that control the
value of XLEN for S-mode and U-mode, respectively. The encoding of these
fields is the same as the MXL field of <code>misa</code>, shown in
<a href="#misabase">Encoding of MXL field in <code>misa</code></a>. The effective XLEN in S-mode and
U-mode are termed <em>SXLEN</em> and <em>UXLEN</em>, respectively.</p>
</div>
<div class="paragraph">
<p>When MXLEN=32, the SXL and UXL fields do not exist, and SXLEN=32 and
UXLEN=32.</p>
</div>
<div class="paragraph">
<p>When MXLEN=64, if S-mode is not supported, then SXL is read-only
zero. Otherwise, it is a <strong>WARL</strong> field that encodes the current value of SXLEN.
In particular, an implementation may make SXL be a read-only field whose
value always ensures that SXLEN=MXLEN.</p>
</div>
<div class="paragraph">
<p>When MXLEN=64, if U-mode is not supported, then UXL is read-only
zero. Otherwise, it is a <strong>WARL</strong> field that encodes the current value of UXLEN.
In particular, an implementation may make UXL be a read-only field whose
value always ensures that UXLEN=MXLEN or UXLEN=SXLEN.</p>
</div>
<div class="paragraph">
<p>If S-mode is implemented, the set of legal values that the UXL field may
assume excludes those that would cause UXLEN to be greater than SXLEN.</p>
</div>
<div class="paragraph">
<p>Whenever XLEN in any mode is set to a value less than the widest
supported XLEN, all operations must ignore source operand register bits
above the configured XLEN, and must sign-extend results to fill the
entire widest supported XLEN in the destination register. Similarly,
<code>pc</code> bits above XLEN are ignored, and when the <code>pc</code> is written, it is
sign-extended to fill the widest supported XLEN.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>We require that operations always fill the entire underlying hardware
registers with defined values to avoid implementation-defined behavior.</p>
</div>
<div class="paragraph">
<p>To reduce hardware complexity, the architecture imposes no checks that
lower-privilege modes have XLEN settings less than or equal to the
next-higher privilege mode. In practice, such settings would almost
always be a software bug, but machine operation is well-defined even in
this case.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Some HINT instructions are encoded as integer computational instructions that
overwrite their destination register with its current value, e.g.,
<code>c.addi x8, 0</code>.
When such a HINT is executed with XLEN &lt; MXLEN and bits MXLEN..XLEN of the
destination register not all equal to bit XLEN-1, it is implementation-defined
whether bits MXLEN..XLEN of the destination register are unchanged or are
overwritten with copies of bit XLEN-1.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This definition allows implementations to elide register writeback for
some HINTs, while allowing them to execute other HINTs in the same manner as
other integer computational instructions.
The implementation choice is observable only by privilege modes with an XLEN
setting greater than the current XLEN; it is invisible to the current
privilege mode.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_memory_privilege_in_mstatus_register"><a class="anchor" href="#_memory_privilege_in_mstatus_register"></a>Memory Privilege in <code>mstatus</code> Register</h5>
<div class="paragraph">
<p>The MPRV (Modify PRiVilege) bit modifies the <em>effective privilege mode</em>,
i.e., the privilege level at which loads and stores execute. When
MPRV=0, loads and stores behave as normal, using the translation and
protection mechanisms of the current privilege mode. When MPRV=1, load
and store memory addresses are translated and protected, and endianness
is applied, as though the current privilege mode were set to MPP.
Instruction address-translation and protection are unaffected by the
setting of MPRV. MPRV is read-only 0 if U-mode is not supported.</p>
</div>
<div class="paragraph">
<p>An MRET or SRET instruction that changes the privilege mode to a mode
less privileged than M also sets MPRV=0.</p>
</div>
<div class="paragraph">
<p>The MXR (Make eXecutable Readable) bit modifies the privilege with which
loads access virtual memory. When MXR=0, only loads from pages marked
readable (R=1 in <a href="#sv32pte">[sv32pte]</a>) will succeed. When
MXR=1, loads from pages marked either readable or executable (R=1 or
X=1) will succeed. MXR has no effect when page-based virtual memory is
not in effect. MXR is read-only 0 if S-mode is not supported.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The MPRV and MXR mechanisms were conceived to improve the efficiency of
M-mode routines that emulate missing hardware features, e.g., misaligned
loads and stores. MPRV obviates the need to perform address translation
in software. MXR allows instruction words to be loaded from pages marked
execute-only.</p>
</div>
<div class="paragraph">
<p>The current privilege mode and the privilege mode specified by MPP might
have different XLEN settings. When MPRV=1, load and store memory
addresses are treated as though the current XLEN were set to MPP’s XLEN,
following the rules in <a href="#xlen-control">Base ISA Control in <code>mstatus</code> Register</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The SUM (permit Supervisor User Memory access) bit modifies the
privilege with which S-mode loads and stores access virtual memory. When
SUM=0, S-mode memory accesses to pages that are accessible by U-mode
(U=1 in <a href="#sv32pte">[sv32pte]</a>) will fault. When SUM=1, these
accesses are permitted. SUM has no effect when page-based virtual memory
is not in effect. Note that, while SUM is ordinarily ignored when not
executing in S-mode, it <em>is</em> in effect when MPRV=1 and MPP=S. SUM is
read-only 0 if S-mode is not supported or if <code>satp</code>.MODE is read-only 0.</p>
</div>
<div class="paragraph">
<p>The MXR and SUM mechanisms only affect the interpretation of permissions
encoded in page-table entries. In particular, they have no impact on
whether access-fault exceptions are raised due to PMAs or PMP.</p>
</div>
</div>
<div class="sect4">
<h5 id="_endianness_control_in_mstatus_and_mstatush_registers"><a class="anchor" href="#_endianness_control_in_mstatus_and_mstatush_registers"></a>Endianness Control in <code>mstatus</code> and <code>mstatush</code> Registers</h5>
<div class="paragraph">
<p>The MBE, SBE, and UBE bits in <code>mstatus</code> and <code>mstatush</code> are <strong>WARL</strong> fields that
control the endianness of memory accesses other than instruction
fetches. Instruction fetches are always little-endian.</p>
</div>
<div class="paragraph">
<p>MBE controls whether non-instruction-fetch memory accesses made from
M-mode (assuming <code>mstatus</code>.MPRV=0) are little-endian (MBE=0) or
big-endian (MBE=1).</p>
</div>
<div class="paragraph">
<p>If S-mode is not supported, SBE is read-only 0. Otherwise, SBE controls
whether explicit load and store memory accesses made from S-mode are
little-endian (SBE=0) or big-endian (SBE=1).</p>
</div>
<div class="paragraph">
<p>If U-mode is not supported, UBE is read-only 0. Otherwise, UBE controls
whether explicit load and store memory accesses made from U-mode are
little-endian (UBE=0) or big-endian (UBE=1).</p>
</div>
<div class="paragraph">
<p>For <em>implicit</em> accesses to supervisor-level memory management data
structures, such as page tables, endianness is always controlled by SBE.
Since changing SBE alters the implementation’s interpretation of these
data structures, if any such data structures remain in use across a
change to SBE, M-mode software must follow such a change to SBE by
executing an SFENCE.VMA instruction with <em>rs1</em>=<code>x0</code> and <em>rs2</em>=<code>x0</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Only in contrived scenarios will a given memory-management data
structure be interpreted as both little-endian and big-endian. In
practice, SBE will only be changed at runtime on world switches, in
which case neither the old nor new memory-management data structure will
be reinterpreted in a different endianness. In this case, no additional
SFENCE.VMA is necessary, beyond what would ordinarily be required for a
world switch.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If S-mode is supported, an implementation may make SBE be a read-only
copy of MBE. If U-mode is supported, an implementation may make UBE be a
read-only copy of either MBE or SBE.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>An implementation supports only little-endian memory accesses if fields
MBE, SBE, and UBE are all read-only 0. An implementation supports only
big-endian memory accesses (aside from instruction fetches) if MBE is
read-only 1 and SBE and UBE are each read-only 1 when S-mode and U-mode
are supported.</p>
</div>
<hr>
<div class="paragraph">
<p>Volume I defines a hart’s address space as a circular sequence of
2<sup>XLEN</sup> bytes at consecutive addresses. The
correspondence between addresses and byte locations is fixed and not
affected by any endianness mode. Rather, the applicable endianness mode
determines the order of mapping between memory bytes and a multibyte
quantity (halfword, word, etc.).</p>
</div>
<hr>
<div class="paragraph">
<p>Standard RISC-V ABIs are expected to be purely little-endian-only or
big-endian-only, with no accommodation for mixing endianness.
Nevertheless, endianness control has been defined so as to permit, for
instance, an OS of one endianness to execute user-mode programs of the
opposite endianness. Consideration has been given also to the
possibility of non-standard usages whereby software flips the endianness
of memory accesses as needed.</p>
</div>
<hr>
<div class="paragraph">
<p>RISC-V instructions are uniformly little-endian to decouple instruction
encoding from the current endianness settings, for the benefit of both
hardware and software. Otherwise, for instance, a RISC-V assembler or
disassembler would always need to know the intended active endianness,
despite that the endianness mode might change dynamically during
execution. In contrast, by giving instructions a fixed endianness, it is
sometimes possible for carefully written software to be
endianness-agnostic even in binary form, much like position-independent
code.</p>
</div>
<div class="paragraph">
<p>The choice to have instructions be only little-endian does have
consequences, however, for RISC-V software that encodes or decodes
machine instructions. In big-endian mode, such software must account for
the fact that explicit loads and stores have endianness opposite that of
instructions, for example by swapping byte order after loads and before
stores.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="virt-control"><a class="anchor" href="#virt-control"></a>Virtualization Support in <code>mstatus</code> Register</h5>
<div class="paragraph">
<p>The TVM (Trap Virtual Memory) bit is a <strong>WARL</strong> field that supports intercepting
supervisor virtual-memory management operations. When TVM=1, attempts to
read or write the <code>satp</code> CSR or execute an SFENCE.VMA or SINVAL.VMA
instruction while executing in S-mode will raise an illegal-instruction
exception. When TVM=0, these operations are permitted in S-mode. TVM is
read-only 0 when S-mode is not supported.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The TVM mechanism improves virtualization efficiency by permitting guest
operating systems to execute in S-mode, rather than classically
virtualizing them in U-mode. This approach obviates the need to trap
accesses to most S-mode CSRs.</p>
</div>
<div class="paragraph">
<p>Trapping <code>satp</code> accesses and the SFENCE.VMA and SINVAL.VMA instructions
provides the hooks necessary to lazily populate shadow page tables.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The TW (Timeout Wait) bit is a <strong>WARL</strong> field that supports intercepting the WFI
instruction (see <a href="#wfi">Wait for Interrupt</a>). When TW=0, the WFI
instruction may execute in lower privilege modes when not prevented for
some other reason. When TW=1, then if WFI is executed in any
less-privileged mode, and it does not complete within an
implementation-specific, bounded time limit, the WFI instruction causes
an illegal-instruction exception. An implementation may have WFI always
raise an illegal-instruction exception in less-privileged modes when
TW=1, even if there are pending globally-disabled interrupts when the
instruction is executed. TW is read-only 0 when there are no modes less
privileged than M.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Trapping the WFI instruction can trigger a world switch to another guest
OS, rather than wastefully idling in the current guest.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When S-mode is implemented, then executing WFI in U-mode causes an
illegal-instruction exception, unless it completes within an
implementation-specific, bounded time limit. A future revision of this
specification might add a feature that allows S-mode to selectively
permit WFI in U-mode. Such a feature would only be active when TW=0.</p>
</div>
<div class="paragraph">
<p>The TSR (Trap SRET) bit is a <strong>WARL</strong> field that supports intercepting the
supervisor exception return instruction, SRET. When TSR=1, attempts to
execute SRET while executing in S-mode will raise an illegal-instruction
exception. When TSR=0, this operation is permitted in S-mode. TSR is
read-only 0 when S-mode is not supported.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Trapping SRET is necessary to emulate the hypervisor extension (see
<a href="#hypervisor">[hypervisor]</a>) on implementations that do not
provide it.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_extension_context_status_in_mstatus_register"><a class="anchor" href="#_extension_context_status_in_mstatus_register"></a>Extension Context Status in <code>mstatus</code> Register</h5>
<div class="paragraph">
<p>Supporting substantial extensions is one of the primary goals of RISC-V,
and hence we define a standard interface to allow unchanged
privileged-mode code, particularly a supervisor-level OS, to support
arbitrary user-mode state extensions.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>To date, the V extension is the only standard extension that defines
additional state beyond the floating-point CSR and data registers.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The FS[1:0] and VS[1:0] <strong>WARL</strong> fields and the XS[1:0] read-only field are used
to reduce the cost of context save and restore by setting and tracking
the current state of the floating-point unit and any other user-mode
extensions respectively. The FS field encodes the status of the
floating-point unit state, including the floating-point registers
<code>f0</code>–<code>f31</code> and the CSRs <code>fcsr</code>, <code>frm</code>, and <code>fflags</code>. The VS field
encodes the status of the vector extension state, including the vector
registers <code>v0</code>–<code>v31</code> and the CSRs <code>vcsr</code>, <code>vxrm</code>, <code>vxsat</code>, <code>vstart</code>,
<code>vl</code>, <code>vtype</code>, and <code>vlenb</code>. The XS field encodes the status of
additional user-mode extensions and associated state. These fields can
be checked by a context switch routine to quickly determine whether a
state save or restore is required. If a save or restore is required,
additional instructions and CSRs are typically required to effect and
optimize the process.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The design anticipates that most context switches will not need to
save/restore state in either or both of the floating-point unit or other
extensions, so provides a fast check via the SD bit.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The FS, VS, and XS fields use the same status encoding as shown in
<a href="#fsxsencoding">Encoding of FS[1:0], VS[1:0], and XS[1:0] status fields</a>, with the four possible status
values being Off, Initial, Clean, and Dirty.</p>
</div>
<table id="fsxsencoding" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 3. Encoding of FS[1:0], VS[1:0], and XS[1:0] status fields</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-right valign-top">Status</th>
<th class="tableblock halign-left valign-top">FS and VS Meaning</th>
<th class="tableblock halign-left valign-top">XS Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">0<br>
1<br>
2<br>
3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Off<br>
Initial<br>
Clean<br>
Dirty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">All off<br>
None dirty or clean, some on<br>
None dirty, some clean<br>
Some dirty</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>If the F extension is implemented, the FS field shall not be read-only
zero.</p>
</div>
<div class="paragraph">
<p>If neither the F extension nor S-mode is implemented, then FS is
read-only zero. If S-mode is implemented but the F extension is not, FS
may optionally be read-only zero.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Implementations with S-mode but without the F extension are permitted,
but not required, to make the FS field be read-only zero. Some such
implementations will choose <em>not</em> to have the FS field be read-only
zero, so as to enable emulation of the F extension for both S-mode and
U-mode via invisible traps into M-mode.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the <code>v</code> registers are implemented, the VS field shall not be
read-only zero.</p>
</div>
<div class="paragraph">
<p>If neither the <code>v</code> registers nor S-mode is implemented, then VS is
read-only zero. If S-mode is implemented but the <code>v</code> registers are not,
VS may optionally be read-only zero.</p>
</div>
<div class="paragraph">
<p>In harts without additional user extensions requiring new state, the
XS field is read-only zero. Every additional extension with state
provides a CSR field that encodes the equivalent of the XS states. The
XS field represents a summary of all extensions' status as shown in
<a href="#fsxsencoding">Encoding of FS[1:0], VS[1:0], and XS[1:0] status fields</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The XS field effectively reports the maximum status value across all
user-extension status fields, though individual extensions can use a
different encoding than XS.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The SD bit is a read-only bit that summarizes whether either the FS, VS,
or XS fields signal the presence of some dirty state that will require
saving extended user context to memory. If FS, XS, and VS are all
read-only zero, then SD is also always zero.</p>
</div>
<div class="paragraph">
<p>When an extension&#8217;s status is set to Off, any instruction that attempts
to read or write the corresponding state will cause an
illegal-instruction exception. When the status is Initial, the corresponding
state should have an initial constant value. When the status is Clean,
the corresponding state is potentially different from the initial value,
but matches the last value stored on a context swap. When the status is
Dirty, the corresponding state has potentially been modified since the
last context save.</p>
</div>
<div class="paragraph">
<p>During a context save, the responsible privileged code need only write
out the corresponding state if its status is Dirty, and can then reset
the extension&#8217;s status to Clean. During a context restore, the context
need only be loaded from memory if the status is Clean (it should never
be Dirty at restore). If the status is Initial, the context must be set
to an initial constant value on context restore to avoid a security
hole, but this can be done without accessing memory. For example, the
floating-point registers can all be initialized to the immediate value
0.</p>
</div>
<div class="paragraph">
<p>The FS and XS fields are read by the privileged code before saving the
context. The FS field is set directly by privileged code when resuming a
user context, while the XS field is set indirectly by writing to the
status register of the individual extensions. The status fields will
also be updated during execution of instructions, regardless of
privilege mode.</p>
</div>
<div class="paragraph">
<p>Extensions to the user-mode ISA often include additional user-mode
state, and this state can be considerably larger than the base integer
registers. The extensions might only be used for some applications, or
might only be needed for short phases within a single application. To
improve performance, the user-mode extension can define additional
instructions to allow user-mode software to return the unit to an
initial state or even to turn off the unit.</p>
</div>
<div class="paragraph">
<p>For example, a coprocessor might require to be configured before use and
can be "unconfigured" after use. The unconfigured state would be
represented as the Initial state for context save. If the same
application remains running between the unconfigure and the next
configure (which would set status to Dirty), there is no need to
actually reinitialize the state at the unconfigure instruction, as all
state is local to the user process, i.e., the Initial state may only
cause the coprocessor state to be initialized to a constant value at
context restore, not at every unconfigure.</p>
</div>
<div class="paragraph">
<p>Executing a user-mode instruction to disable a unit and place it into
the Off state will cause an illegal-instruction exception to be raised
if any subsequent instruction tries to use the unit before it is turned
back on. A user-mode instruction to turn a unit on must also ensure the
unit&#8217;s state is properly initialized, as the unit might have been used
by another context meantime.</p>
</div>
<div class="paragraph">
<p>Changing the setting of FS has no effect on the contents of the
floating-point register state. In particular, setting FS=Off does not
destroy the state, nor does setting FS=Initial clear the contents.
Similarly, the setting of VS has no effect on the contents of the vector
register state. Other extensions, however, might not preserve state when
set to Off.</p>
</div>
<div class="paragraph">
<p>Implementations may choose to track the dirtiness of the floating-point
register state imprecisely by reporting the state to be dirty even when
it has not been modified. On some implementations, some instructions
that do not mutate the floating-point state may cause the state to
transition from Initial or Clean to Dirty. On other implementations,
dirtiness might not be tracked at all, in which case the valid FS states
are Off and Dirty, and an attempt to set FS to Initial or Clean causes
it to be set to Dirty.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>This definition of FS does not disallow setting FS to Dirty as a result
of errant speculation. Some platforms may choose to disallow
speculatively writing FS to close a potential side channel.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If an instruction explicitly or implicitly writes a floating-point
register or the <code>fcsr</code> but does not alter its contents, and FS=Initial
or FS=Clean, it is implementation-defined whether FS transitions to
Dirty.</p>
</div>
<div class="paragraph">
<p>Implementations may choose to track the dirtiness of the vector register
state in an analogous imprecise fashion, including possibly setting VS
to Dirty when software attempts to set VS=Initial or VS=Clean. When
VS=Initial or VS=Clean, it is implementation-defined whether an
instruction that writes a vector register or vector CSR but does not
alter its contents causes VS to transition to Dirty.</p>
</div>
<div class="paragraph">
<p><a href="#fsxsstates">FS, VS, and XS state transitions.</a> shows all the possible state
transitions for the FS, VS, or XS status bits. Note that the standard
floating-point and vector extensions do not support user-mode
unconfigure or disable/enable instructions.</p>
</div>
<div style="page-break-after: always;"></div>
<table id="fsxsstates" class="tableblock frame-all grid-all center" style="width: 75%;">
<caption class="title">Table 4. FS, VS, and XS state transitions.</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Current State<br>
Action</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Off</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Initial</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Clean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Dirty</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all center" style="width: 75%;">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="5">At context save in privileged code</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Save state?<br>
Next state</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No<br>
Off</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No<br>
Initial</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No<br>
Clean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes<br>
Clean</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all center" style="width: 75%;">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="5">At context restore in privileged code</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Restore state?<br>
Next state</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No<br>
Off</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes, to initial<br>
Initial</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes, from memory<br>
Clean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A<br>
N/A</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all center" style="width: 75%;">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="5">Execute instruction to read state</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Action?<br>
Next state</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Exception<br>
Off</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Execute<br>
Initial</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Execute<br>
Clean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Execute<br>
Dirty</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all center" style="width: 75%;">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top" colspan="5"><p class="tableblock">Execute instruction that possibly modifies state, including
configuration</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Action?<br>
Next state</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Exception<br>
Off</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Execute<br>
Dirty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Execute<br>
Dirty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Execute<br>
Dirty</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all center" style="width: 75%;">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="5">Execute instruction to unconfigure unit</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Action?<br>
Next state</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Exception<br>
Off</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Execute<br>
Initial</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Execute<br>
Initial</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Execute<br>
Initial</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all center" style="width: 75%;">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="5">Execute instruction to disable unit</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Action?<br>
Next state</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Execute<br>
Off</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Execute<br>
Off</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Execute<br>
Off</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Execute<br>
Off</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all center" style="width: 75%;">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="5">Execute instruction to enable unit</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Action?<br>
Next state</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Execute<br>
Initial</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Execute<br>
Initial</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Execute<br>
Initial</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Execute<br>
Initial</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Standard privileged instructions to initialize, save, and restore
extension state are provided to insulate privileged code from details of
the added extension state by treating the state as an opaque object.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Many coprocessor extensions are only used in limited contexts that
allows software to safely unconfigure or even disable units when done.
This reduces the context-switch overhead of large stateful coprocessors.</p>
</div>
<div class="paragraph">
<p>We separate out floating-point state from other extension state, as when
a floating-point unit is present the floating-point registers are part
of the standard calling convention, and so user-mode software cannot
know when it is safe to disable the floating-point unit.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The XS field provides a summary of all added extension state, but
additional microarchitectural bits might be maintained in the extension
to further reduce context save and restore overhead.</p>
</div>
<div class="paragraph">
<p>The SD bit is read-only and is set when either the FS, VS, or XS bits
encode a Dirty state (i.e., SD=FS==11) OR (XS==11) OR (VS==11). This
allows privileged code to quickly determine when no additional context
save is required beyond the integer register set and <code>pc</code>.</p>
</div>
<div class="paragraph">
<p>The floating-point unit state is always initialized, saved, and restored
using standard instructions (F, D, and/or Q), and privileged code must
be aware of FLEN to determine the appropriate space to reserve for each
<code>f</code> register.</p>
</div>
<div class="paragraph">
<p>Machine and Supervisor modes share a single copy of the FS, VS, and XS
bits. Supervisor-level software normally uses the FS, VS, and XS bits
directly to record the status with respect to the supervisor-level saved
context. Machine-level software must be more conservative in saving and
restoring the extension state in their corresponding version of the
context.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In any reasonable use case, the number of context switches between user
and supervisor level should far outweigh the number of context switches
to other privilege levels. Note that coprocessors should not require
their context to be saved and restored to service asynchronous
interrupts, unless the interrupt results in a user-level context swap.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_previous_expected_landing_pad_elp_state_in_mstatus_register"><a class="anchor" href="#_previous_expected_landing_pad_elp_state_in_mstatus_register"></a>Previous Expected Landing Pad (ELP) State in <code>mstatus</code> Register</h5>
<div class="paragraph">
<p>The Zicfilp extension adds the <code>SPELP</code> and <code>MPELP</code> fields that hold the previous
<code>ELP</code>, and are updated as specified in <a href="#ZICFILP_FORWARD_TRAPS">[ZICFILP_FORWARD_TRAPS]</a>. The
<strong><em>x</em></strong><code>PELP</code> fields are encoded as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>0 - <code>NO_LP_EXPECTED</code> - no landing pad instruction expected.</p>
</li>
<li>
<p>1 - <code>LP_EXPECTED</code> - a landing pad instruction is expected.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_machine_trap_vector_base_address_mtvec_register"><a class="anchor" href="#_machine_trap_vector_base_address_mtvec_register"></a>Machine Trap-Vector Base-Address (<code>mtvec</code>) Register</h4>
<div class="paragraph">
<p>The <code>mtvec</code> register is an MXLEN-bit <strong>WARL</strong> read/write register that holds
trap vector configuration, consisting of a vector base address (BASE)
and a vector mode (MODE).</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNrNUl1LwzAUfd-vuNynFgm02YTRt4nzaVPQB4Wxh7RNt2KalCRzU-l_N92yLzcREURICDk5OffckwQ5L5i12kBSC1ZKmPj1PSmUtKRgVSleAccXENdww4RIWfaMzTTsBO4qaLUkc17O5ha6l3AEspxrUkiQpfC44IUlFdMzpx9H0Zbd3j6FU7XihtROw8lBl7awZkuSKbGopNc3zqcvTyPYWDblG4e4D4lgKRcGAs1fHJPDBCMEPB2xm_TsyY_G-Gk0vCWtGE7DJux4v64PwKvBw3DiCQmdorNtaubapZBYvrKEyWyuNCCXOUKSKu2bs6rebslCai6Y5XmLWKuqcydtxqd404QHdoK2JGDwOLgfhbh96uUmR0yVyLEJv7RoLNP2dybXT_6dSxzfXQ93SfX-fVC9P83pKKj1x6K7rGjvoOqnUPes_jHpA8gSSkc=" alt="Encoding of mtvec MODE field.">
</div>
<div class="title">Figure 9. Encoding of mtvec MODE field.</div>
</div>
<div class="paragraph">
<p>The <code>mtvec</code> register must always be implemented, but can contain a
read-only value. If <code>mtvec</code> is writable, the set of values the register
may hold can vary by implementation. The value in the BASE field must
always be aligned on a 4-byte boundary, and the MODE setting may impose
additional alignment constraints on the value in the BASE field.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>We allow for considerable flexibility in implementation of the trap
vector base address. On the one hand, we do not wish to burden low-end
implementations with a large number of state bits, but on the other
hand, we wish to allow flexibility for larger systems.</p>
</div>
</td>
</tr>
</table>
</div>
<table id="mtvec-mode" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 5. Encoding of mtvec MODE field.</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-right valign-top">Value</th>
<th class="tableblock halign-center valign-top">Name</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">0<br>
1<br>
&#8805;2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Direct<br>
Vectored<br>
---</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">All traps set <code>pc</code> to BASE.<br>
Asynchronous interrupts set <code>pc</code> to BASE+4&#215;cause.<br>
<em>Reserved</em></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The encoding of the MODE field is shown in
<a href="#mtvec-mode">Encoding of mtvec MODE field.</a>. When MODE=Direct, all traps into
machine mode cause the <code>pc</code> to be set to the address in the BASE field.
When MODE=Vectored, all synchronous exceptions into machine mode cause
the <code>pc</code> to be set to the address in the BASE field, whereas interrupts
cause the <code>pc</code> to be set to the address in the BASE field plus four
times the interrupt cause number. For example, a machine-mode timer
interrupt (see <a href="#mcauses">Machine cause (<code>mcause</code>) register values after trap.</a>) causes the <code>pc</code>
to be set to BASE+<code>0x1c</code>.</p>
</div>
<div class="paragraph">
<p>An implementation may have different alignment constraints for different
modes. In particular, MODE=Vectored may have stricter alignment
constraints than MODE=Direct.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Allowing coarser alignments in Vectored mode enables vectoring to be
implemented without a hardware adder circuit.</p>
</div>
<hr>
<div class="paragraph">
<p>Reset and NMI vector locations are given in a platform specification.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_machine_trap_delegation_medeleg_and_mideleg_registers"><a class="anchor" href="#_machine_trap_delegation_medeleg_and_mideleg_registers"></a>Machine Trap Delegation (<code>medeleg</code> and <code>mideleg</code>) Registers</h4>
<div class="paragraph">
<p>By default, all traps at any privilege level are handled in machine
mode, though a machine-mode handler can redirect traps back to the
appropriate level with the MRET instruction
(<a href="#otherpriv">Trap-Return Instructions</a>). To increase performance,
implementations can provide individual read/write bits within <code>medeleg</code>
and <code>mideleg</code> to indicate that certain exceptions and interrupts should
be processed directly by a lower privilege level. The machine exception
delegation register (<code>medeleg</code>) is a 64-bit read/write register.
The machine interrupt delegation (<code>mideleg</code>) register is an MXLEN-bit
read/write register.</p>
</div>
<div class="paragraph">
<p>In harts with S-mode, the <code>medeleg</code> and <code>mideleg</code> registers must
exist, and setting a bit in <code>medeleg</code> or <code>mideleg</code> will delegate the
corresponding trap, when occurring in S-mode or U-mode, to the S-mode
trap handler. In harts without S-mode, the <code>medeleg</code> and <code>mideleg</code>
registers should not exist.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In versions 1.9.1 and earlier , these registers existed but were
hardwired to zero in M-mode only, or M/U without N harts. There is no
reason to require they return zero in those cases, as the <code>misa</code>
register indicates whether they exist.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When a trap is delegated to S-mode, the <code>scause</code> register is written
with the trap cause; the <code>sepc</code> register is written with the virtual
address of the instruction that took the trap; the <code>stval</code> register is
written with an exception-specific datum; the SPP field of <code>mstatus</code> is
written with the active privilege mode at the time of the trap; the SPIE
field of <code>mstatus</code> is written with the value of the SIE field at the
time of the trap; and the SIE field of <code>mstatus</code> is cleared. The
<code>mcause</code>, <code>mepc</code>, and <code>mtval</code> registers and the MPP and MPIE fields of
<code>mstatus</code> are not written.</p>
</div>
<div class="paragraph">
<p>An implementation can choose to subset the delegatable traps, with the
supported delegatable bits found by writing one to every bit location,
then reading back the value in <code>medeleg</code> or <code>mideleg</code> to see which bit
positions hold a one.</p>
</div>
<div class="paragraph">
<p>An implementation shall not have any bits of <code>medeleg</code> be read-only one,
i.e., any synchronous trap that can be delegated must support not being
delegated. Similarly, an implementation shall not fix as read-only one
any bits of <code>mideleg</code> corresponding to machine-level interrupts (but may
do so for lower-level interrupts).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Version 1.11 and earlier prohibited having any bits of <code>mideleg</code> be
read-only one. Platform standards may always add such restrictions.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Traps never transition from a more-privileged mode to a less-privileged
mode. For example, if M-mode has delegated illegal-instruction
exceptions to S-mode, and M-mode software later executes an illegal
instruction, the trap is taken in M-mode, rather than being delegated to
S-mode. By contrast, traps may be taken horizontally. Using the same
example, if M-mode has delegated illegal-instruction exceptions to
S-mode, and S-mode software later executes an illegal instruction, the
trap is taken in S-mode.</p>
</div>
<div class="paragraph">
<p>Delegated interrupts result in the interrupt being masked at the
delegator privilege level. For example, if the supervisor timer
interrupt (STI) is delegated to S-mode by setting <code>mideleg</code>[5], STIs
will not be taken when executing in M-mode. By contrast, if <code>mideleg</code>[5]
is clear, STIs can be taken in any mode and regardless of current mode
will transfer control to M-mode.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNqVUT1PwzAU3PsrnjwlQpbyRVVlY4AJFhgYEIOTOI2FY1v2q5JS5b_jtClqaAtisnzPd-98F1S8ZojWQW4kEwrepnOX11ohrVkr5BbI0w3EBh6YlAUrPwgcpk58ckiy4T1cBF4IrO5ow8W6QUhvZxiruKW1AiXkhEteI22ZXftlcRQdX4_kc7jQPXfUeA0vB2kSLjxuWUf9AMgyJd6vM8xTlpAj75EyVTbaAnHILHq_hbbegoPdMISn3Og6lavqJ_GU-bL176xWeuPgvi-5QaGVI8fk9tnEK5jEV7-L56jN8Uo3ynLJkFcjgqjbS5Mxv3N8_rtgXAkkeL17fgy_nXWHhkihZUWG8Irh7K8g_295X-5lz7M6s3mISTZ5SpN5HV8oEutW" alt="Machine Exception Delegation (`medeleg`) register.">
</div>
<div class="title">Figure 10. Machine Exception Delegation (<code>medeleg</code>) register.</div>
</div>
<div class="paragraph">
<p><code>medeleg</code> has a bit position allocated for every synchronous exception
shown in <a href="#mcauses">Machine cause (<code>mcause</code>) register values after trap.</a>, with the index of the
bit position equal to the value returned in the <code>mcause</code> register (i.e.,
setting bit 8 allows user-mode environment calls to be delegated to a
lower-privilege trap handler).</p>
</div>
<div class="paragraph">
<p>When XLEN=32, <code>medelegh</code> is a 32-bit read/write register
that aliases bits 63:32 of <code>medeleg</code>.
The <code>medelegh</code> register does not exist when XLEN=64.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNqVkU9Pg0AQxe_9FJM9QcwmQPFPuHnQxKR68KKJ8TCUpRCXXbI7DdWG7-7Sgiml1Xja7Bve2x9vvEzkSGQsJLXEUsFbf26TXCviOVal_AT2eAFhDfcoZYrLDwb7qS2_BERx--7PPBcERje8EOWqIIgDGImYCcNzBaqUvS5FTrxCs3KvhUEwfN25p3KqN8Ly2mW4OJhH_szpBhvuBo7udXH3xEPmqG2NzncFCYkNcVTLQhtgltCQo061cRwWtm3rHwYE561CZcfGQ-eDImHMuibLhs52rYQ30Ade_x6YkK6HK18rIySSyDqFSFenJl1xU338R173JDDv5fZ54f-QNfvdsFTLjLX-GeDLv8r7P_Juq6eZJ3sc9xjFPdY8Gm_hG6kU6Vg=" alt="Machine Interrupt Delegation (`mideleg`) Register.">
</div>
<div class="title">Figure 11. Machine Interrupt Delegation (<code>mideleg</code>) Register.</div>
</div>
<div class="paragraph">
<p><code>mideleg</code> holds trap delegation bits for individual interrupts, with the
layout of bits matching those in the <code>mip</code> register (i.e., STIP
interrupt delegation control is located in bit 5).</p>
</div>
<div class="paragraph">
<p>For exceptions that cannot occur in less privileged modes, the
corresponding <code>medeleg</code> bits should be read-only zero. In particular,
<code>medeleg</code>[11] is read-only zero.</p>
</div>
<div class="paragraph">
<p>The <code>medeleg</code>[16] is read-only zero as double trap is not delegatable.</p>
</div>
</div>
<div class="sect3">
<h4 id="_machine_interrupt_mip_and_mie_registers"><a class="anchor" href="#_machine_interrupt_mip_and_mie_registers"></a>Machine Interrupt (<code>mip</code> and <code>mie</code>) Registers</h4>
<div class="paragraph">
<p>The <code>mip</code> register is an MXLEN-bit read/write register containing
information on pending interrupts, while <code>mie</code> is the corresponding
MXLEN-bit read/write register containing interrupt enable bits.
Interrupt cause number <em>i</em> (as reported in CSR <code>mcause</code>,
<a href="#mcause">Machine Cause (<code>mcause</code>) Register</a>) corresponds with bit <em>i</em> in both <code>mip</code> and
<code>mie</code>. Bits 15:0 are allocated to standard interrupt causes only, while
bits 16 and above are designated for platform use.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Interrupts designated for platform use may be designated for custom use
at the platform&#8217;s discretion.
</td>
</tr>
</table>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNqVkU9Pg0AQxe_9FJM9QcwmQPFPuHnQxKR68KKJ8TCUpRCXXbI7DdWG7-7Sgiml1Xja7Bve2x9vvEzkSGQsJLXEUsFbf26TXCviOVal_AT2eAFhDfcoZYrLDwb7qS2_BERx--7PPBcERje8EOWqIIgDGImYCcNzBaqUvS5FTrxCs3KvhUEwfN25p3KqN8Ly2mW4OJhH_szpBhvuBo7udXH3xEPmqG2NzncFCYkNcVTLQhtgltCQo061cRwWtm3rHwYE561CZcfGQ-eDImHMuibLhs52rYQ30Ade_x6YkK6HK18rIySSyDqFSFenJl1xU338R173JDDv5fZ54f-QNfvdsFTLjLX-GeDLv8r7P_Juq6eZJ3sc9xjFPdY8Gm_hG6kU6Vg=" alt="Machine Interrupt-Pending (`mip`) register.">
</div>
<div class="title">Figure 12. Machine Interrupt-Pending (<code>mip</code>) register.</div>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNqVkU9Pg0AQxe_9FJM9QcwmQPFPuHnQxKR68KKJ8TCUpRCXXbI7DdWG7-7Sgiml1Xja7Bve2x9vvEzkSGQsJLXEUsFbf26TXCviOVal_AT2eAFhDfcoZYrLDwb7qS2_BERx--7PPBcERje8EOWqIIgDGImYCcNzBaqUvS5FTrxCs3KvhUEwfN25p3KqN8Ly2mW4OJhH_szpBhvuBo7udXH3xEPmqG2NzncFCYkNcVTLQhtgltCQo061cRwWtm3rHwYE561CZcfGQ-eDImHMuibLhs52rYQ30Ade_x6YkK6HK18rIySSyDqFSFenJl1xU338R173JDDv5fZ54f-QNfvdsFTLjLX-GeDLv8r7P_Juq6eZJ3sc9xjFPdY8Gm_hG6kU6Vg=" alt="Machine Interrupt-Enable (`mie`) register">
</div>
<div class="title">Figure 13. Machine Interrupt-Enable (<code>mie</code>) register</div>
</div>
<div class="paragraph">
<p>An interrupt <em>i</em> will trap to M-mode (causing the privilege mode to
change to M-mode) if all of the following are true: (a) either the
current privilege mode is M and the MIE bit in the <code>mstatus</code> register is
set, or the current privilege mode has less privilege than M-mode;
(b) bit <em>i</em> is set in both <code>mip</code> and <code>mie</code>; and (c) if register
<code>mideleg</code> exists, bit <em>i</em> is not set in <code>mideleg</code>.</p>
</div>
<div class="paragraph">
<p>These conditions for an interrupt trap to occur must be evaluated in a
bounded amount of time from when an interrupt becomes, or ceases to be,
pending in <code>mip</code>, and must also be evaluated immediately following the
execution of an <em>x</em>RET instruction or an explicit write to a CSR on
which these interrupt trap conditions expressly depend (including <code>mip</code>,
<code>mie</code>, <code>mstatus</code>, and <code>mideleg</code>).</p>
</div>
<div class="paragraph">
<p>Interrupts to M-mode take priority over any interrupts to lower
privilege modes.</p>
</div>
<div class="paragraph">
<p>Each individual bit in register <code>mip</code> may be writable or may be
read-only. When bit <em>i</em> in <code>mip</code> is writable, a pending interrupt <em>i</em>
can be cleared by writing 0 to this bit. If interrupt <em>i</em> can become
pending but bit <em>i</em> in <code>mip</code> is read-only, the implementation must
provide some other mechanism for clearing the pending interrupt.</p>
</div>
<div class="paragraph">
<p>A bit in <code>mie</code> must be writable if the corresponding interrupt can ever
become pending. Bits of <code>mie</code> that are not writable must be read-only
zero.</p>
</div>
<div class="paragraph">
<p>The standard portions (bits 15:0) of the <code>mip</code> and <code>mie</code> registers are
formatted as shown in <a href="#mipreg-standard">Standard portion (bits 15:0) of <code>mip</code>.</a> and <a href="#miereg-standard">Standard portion (bits 15:0) of <code>mie</code>.</a> respectively.</p>
</div>
<div id="mipreg-standard" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNrtksFLwzAUxu_7Kx45tUig6dzUXsWBYFGYt7FDuqVbMU1LEt109H_3xbasnRftdTt8FL73-74XknprkXJrtYGolDxTsGi-hygtlKUpzzP5CSS-AlbCjEuZ8NUbgXpqsi8BLKyW_sjDItDFjm5FttlaGAfQM_laaJoqUJlsfClSS3OuN7iNBUFLu_RvOyn2wtASO7AO2NTZmu_oqpDvuWr6DZ5a8kRIA54WH2gIWJCAAGGoEDVGXaMmqCnqBnWLunPMD-hI5lDmWOZgNiFLv_JHzUo8CrjSQ2RKriCs_M7As2JvgTzdP88eX0h7i_U9BZXfhlgv1Gk7GcQPdcu_QvMhofh1yKYhoXg-ZNOfQ91JeHwliJJC1_9I1Y-zY_wCnRX0DW9RhZk=?id=mipreg-standard" alt="Standard portion (bits 15:0) of `mip`.">
</div>
<div class="title">Figure 14. Standard portion (bits 15:0) of <code>mip</code>.</div>
</div>
<div id="miereg-standard" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNrtkjFvgzAQhff8ipMnUGUJkyZtWatEqlTUId2iDCYxCYoxyHabtBH_vecCCjRLy9oMT0jvvvfOsvE2IuXWagNRKXmmYNl8T1FaKEtTnmfyA0h8A6yEOZcy4es9gXpqsk8BLKxW_sjDItDFge5Ett1ZGAfQM_lGaJoqUJlsfClSS3Out7iNBUFLu_SlnRRHYWiJHVgHbOpszQ90Xci3XDX9Bk8teSKkAU-LdzQELElAgDBUiBqjblET1BR1h7pHPTjmG3QkcyhzLHMwm5CVX_mjZiUeBVzpKTIlVxBWfmfgWXG0QJ4fX-ZPM9LeYn1PQeW3IdYLddp-DOJZ3fKn0GJIKH4dsmlIKF4M2fTrUHcSnl8JoqTQ9T9S9ePsHL9C_wr6AowKhUw=?id=miereg-standard" alt="Standard portion (bits 15:0) of `mie`.">
</div>
<div class="title">Figure 15. Standard portion (bits 15:0) of <code>mie</code>.</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The machine-level interrupt registers handle a few root interrupt
sources which are assigned a fixed service priority for simplicity,
while separate external interrupt controllers can implement a more
complex prioritization scheme over a much larger set of interrupts that
are then muxed into the machine-level interrupt sources.</p>
</div>
<hr>
<div class="paragraph">
<p>The non-maskable interrupt is not made visible via the <code>mip</code> register as
its presence is implicitly known when executing the NMI trap handler.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Bits <code>mip</code>.MEIP and <code>mie</code>.MEIE are the interrupt-pending and
interrupt-enable bits for machine-level external interrupts. MEIP is
read-only in <code>mip</code>, and is set and cleared by a platform-specific
interrupt controller.</p>
</div>
<div class="paragraph">
<p>Bits <code>mip</code>.MTIP and <code>mie</code>.MTIE are the interrupt-pending and
interrupt-enable bits for machine timer interrupts. MTIP is read-only in
the <code>mip</code> register, and is cleared by writing to the memory-mapped machine-mode timer
compare register.</p>
</div>
<div class="paragraph">
<p>Bits <code>mip</code>.MSIP and <code>mie</code>.MSIE are the interrupt-pending and
interrupt-enable bits for machine-level software interrupts. MSIP is
read-only in <code>mip</code>, and is written by accesses to memory-mapped control
registers, which are used by remote harts to provide machine-level
interprocessor interrupts. A hart can write its own MSIP bit using the
same memory-mapped control register. If a system has only one hart, or
if a platform standard supports the delivery of machine-level
interprocessor interrupts through external interrupts (MEI) instead,
then <code>mip</code>.MSIP and <code>mie</code>.MSIE may both be read-only zeros.</p>
</div>
<div class="paragraph">
<p>If supervisor mode is not implemented, bits SEIP, STIP, and SSIP of
<code>mip</code> and SEIE, STIE, and SSIE of <code>mie</code> are read-only zeros.</p>
</div>
<div class="paragraph">
<p>If supervisor mode is implemented, bits <code>mip</code>.SEIP and <code>mie</code>.SEIE are
the interrupt-pending and interrupt-enable bits for supervisor-level
external interrupts. SEIP is writable in <code>mip</code>, and may be written by
M-mode software to indicate to S-mode that an external interrupt is
pending. Additionally, the platform-level interrupt controller may
generate supervisor-level external interrupts. Supervisor-level external
interrupts are made pending based on the logical-OR of the
software-writable SEIP bit and the signal from the external interrupt
controller. When <code>mip</code> is read with a CSR instruction, the value of the
SEIP bit returned in the <code>rd</code> destination register is the logical-OR of
the software-writable bit and the interrupt signal from the interrupt
controller, but the signal from the interrupt controller is not used to
calculate the value written to SEIP. Only the software-writable SEIP bit
participates in the read-modify-write sequence of a CSRRS or CSRRC
instruction.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>For example, if we name the software-writable SEIP bit <code>B</code> and the
signal from the external interrupt controller <code>E</code>, then if
<code>csrrs t0, mip, t1</code> is executed, <code>t0[9]</code> is written with <code>B || E</code>, then
<code>B</code> is written with <code>B || t1[9]</code>. If <code>csrrw t0, mip, t1</code> is executed,
then <code>t0[9]</code> is written with <code>B || E</code>, and <code>B</code> is simply written with
<code>t1[9]</code>. In neither case does <code>B</code> depend upon <code>E</code>.</p>
</div>
<div class="paragraph">
<p>The SEIP field behavior is designed to allow a higher privilege layer to
mimic external interrupts cleanly, without losing any real external
interrupts. The behavior of the CSR instructions is slightly modified
from regular CSR accesses as a result.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If supervisor mode is implemented, bits <code>mip</code>.STIP and <code>mie</code>.STIE are
the interrupt-pending and interrupt-enable bits for supervisor-level
timer interrupts. STIP is writable in <code>mip</code>, and may be written by
M-mode software to deliver timer interrupts to S-mode.</p>
</div>
<div class="paragraph">
<p>If supervisor mode is implemented, bits <code>mip</code>.SSIP and <code>mie</code>.SSIE are
the interrupt-pending and interrupt-enable bits for supervisor-level
software interrupts. SSIP is writable in <code>mip</code> and may also be set to 1
by a platform-specific interrupt controller.</p>
</div>
<div class="paragraph">
<p>If the Sscofpmf extension is implemented, bits <code>mip</code>.LCOFIP and <code>mie</code>.LCOFIE
are the interrupt-pending and interrupt-enable bits for local counter-overflow
interrupts.
LCOFIP is read-write in <code>mip</code> and reflects the occurrence of a local
counter-overflow overflow interrupt request resulting from any of the
<code>mhpmevent<em>n</em></code>.OF bits being set.
If the Sscofpmf extension is not implemented, <code>mip</code>.LCOFIP and <code>mie</code>.LCOFIE are
read-only zeros.</p>
</div>
<div class="paragraph">
<p>Multiple simultaneous interrupts destined for M-mode are handled in the
following decreasing priority order: MEI, MSI, MTI, SEI, SSI, STI, LCOFI.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The machine-level interrupt fixed-priority ordering rules were developed
with the following rationale.</p>
</div>
<div class="paragraph">
<p>Interrupts for higher privilege modes must be serviced before interrupts
for lower privilege modes to support preemption.</p>
</div>
<div class="paragraph">
<p>The platform-specific machine-level interrupt sources in bits 16 and
above have platform-specific priority, but are typically chosen to have
the highest service priority to support very fast local vectored
interrupts.</p>
</div>
<div class="paragraph">
<p>External interrupts are handled before internal (timer/software)
interrupts as external interrupts are usually generated by devices that
might require low interrupt service times.</p>
</div>
<div class="paragraph">
<p>Software interrupts are handled before internal timer interrupts,
because internal timer interrupts are usually intended for time slicing,
where time precision is less important, whereas software interrupts are
used for inter-processor messaging. Software interrupts can be avoided
when high-precision timing is required, or high-precision timer
interrupts can be routed via a different interrupt path. Software
interrupts are located in the lowest four bits of <code>mip</code> as these are
often written by software, and this position allows the use of a single
CSR instruction with a five-bit immediate.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Restricted views of the <code>mip</code> and <code>mie</code> registers appear as the <code>sip</code>
and <code>sie</code> registers for supervisor level. If an interrupt is delegated
to S-mode by setting a bit in the <code>mideleg</code> register, it becomes visible
in the <code>sip</code> register and is maskable using the <code>sie</code> register.
Otherwise, the corresponding bits in <code>sip</code> and <code>sie</code> are read-only zero.</p>
</div>
</div>
<div class="sect3">
<h4 id="_hardware_performance_monitor"><a class="anchor" href="#_hardware_performance_monitor"></a>Hardware Performance Monitor</h4>
<div class="paragraph">
<p>M-mode includes a basic hardware performance-monitoring facility. The
<code>mcycle</code> CSR counts the number of clock cycles executed by the processor
core on which the hart is running. The <code>minstret</code> CSR counts the number
of instructions the hart has retired. The <code>mcycle</code> and <code>minstret</code>
registers have 64-bit precision on all RV32 and RV64 harts.</p>
</div>
<div class="paragraph">
<p>The counter registers have an arbitrary value after the hart is reset,
and can be written with a given value. Any CSR write takes effect after
the writing instruction has otherwise completed. The <code>mcycle</code> CSR may be
shared between harts on the same core, in which case writes to <code>mcycle</code>
will be visible to those harts. The platform should provide a mechanism
to indicate which harts share an <code>mcycle</code> CSR.</p>
</div>
<div class="paragraph">
<p>The hardware performance monitor includes 29 additional 64-bit event
counters, <code>mhpmcounter3</code>-<code>mhpmcounter31</code>. The event selector CSRs,
<code>mhpmevent3</code>-<code>mhpmevent31</code>, are 64-bit <strong>WARL</strong> registers that control which
event causes the corresponding counter to increment. The meaning of
these events is defined by the platform, but event 0 is defined to mean
"no event." All counters should be implemented, but a legal
implementation is to make both the counter and its corresponding event
selector be read-only 0.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNq9Ul1qhDAQft9TDHlSSsA_LHiAvvUEyz5EHVdpTCTJdndbPEHv0kP1JI1dpdWibFspCMLM9zefOjkWzBilIWk4qwRs-_dzUkhhaMHqip-B3N-A38Ad4zxl2QOBy1ZXTwhB1O7cjWOFQMkjLbHalwYibzRjOSpaCBAV7-ccC0NrpvbW7BPccb9NU3lCTRurYMUgDLqxYkeaSX6oRa-ubeTeO4jH-SDhLEWuwVH4aJEIW0LgN493JS4Oyc5t3U0f1B4ApM7OGUdiY-qGCfCj1v2ytsUMG5s3lepyUjsH8qeokVUltFFo_sNsCfZDx662AXULicGToUxkpVRAtGHK3jNQp0xvlogin9BGTZVNncmDMKjCP7X1oWT_LmEmOjNu0Upu0bzb28srWe3TLIrNNeqtVal3Vaehv5afP-8XR-uVuqD1DphvxnA=" alt="Hardware performance monitor counters.">
</div>
<div class="title">Figure 16. Hardware performance monitor counters.</div>
</div>
<div class="paragraph">
<p>The <code>mhpmcounters</code> are <strong>WARL</strong> registers that support up to 64 bits of
precision on RV32 and RV64.</p>
</div>
<div class="paragraph">
<p>When XLEN=32, reads of the <code>mcycle</code>, <code>minstret</code>, <code>mhpmcounter<em>n</em></code>, and <code>mhpmevent<em>n</em></code>
CSRs return bits 31-0 of the corresponding register, and writes change
only bits 31-0; reads of the <code>mcycleh</code>, <code>minstreth</code>, <code>mhpmcounter<em>n</em>h</code>, and <code>mhpmevent<em>n</em>h</code>
CSRs return bits 63-32 of the corresponding register, and writes change
only bits 63-32.
The <code>mhpmevent<em>n</em>h</code> CSRs are provided only if the Sscofpmf extension is implemented.</p>
</div>
</div>
<div class="sect3">
<h4 id="mcounteren"><a class="anchor" href="#mcounteren"></a>Machine Counter-Enable (<code>mcounteren</code>) Register</h4>
<div class="paragraph">
<p>The counter-enable <code>mcounteren</code> register is a 32-bit register that
controls the availability of the hardware performance-monitoring
counters to the next-lower privileged mode.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNq9UV1LwzAUfd-vuOSpRVqatNXZV0H0oSDii4w9pFvqillSkur8oP_dOxq0da4ouEEuJ5xz7kduvKUoedMYC1kteaVg5vA9K7VqgpKvK_kKJD8BWsMll7Lgi0fSzv2Jh6lg9CZYieph1UCSDji-FCYoFahKOr7QL8IGNdLogJhtacM3wULLp7VyKRY7u4Isgm4IW70JoFPIJC-EtOAZ8YxOATMSESAUg2HgiTtIOkgxTrvr7w-bOjx3JSOHlMz91p-4ofExQK5ucqRxYltzBaz1v4vRiLht8LMYhuGnRM92EtORosnYNPu069uvdkPlLt-nXNwPlL7U2whkhTbdr7bD_P8zsbi3rGM0_KOJHsr0AbdqGNQ=" alt="Counter-enable (`mcounteren`) register.">
</div>
<div class="title">Figure 17. Counter-enable (<code>mcounteren</code>) register.</div>
</div>
<div class="paragraph">
<p>The settings in this register only control accessibility. The act of
reading or writing this register does not affect the underlying
counters, which continue to increment even when not accessible.</p>
</div>
<div class="paragraph">
<p>When the CY, TM, IR, or HPM<em>n</em> bit in the <code>mcounteren</code> register is
clear, attempts to read the <code>cycle</code>, <code>time</code>, <code>instret</code>, or
<code>hpmcountern</code> register while executing in S-mode or U-mode will cause an
illegal-instruction exception. When one of these bits is set, access to
the corresponding register is permitted in the next implemented
privilege mode (S-mode if implemented, otherwise U-mode).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The counter-enable bits support two common use cases with minimal
hardware. For harts that do not need high-performance timers and
counters, machine-mode software can trap accesses and implement all
features in software. For harts that need high-performance timers and
counters but are not concerned with obfuscating the underlying hardware
counters, the counters can be directly exposed to lower privilege modes.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>cycle</code>, <code>instret</code>, and <code>hpmcountern</code> CSRs are read-only shadows of
<code>mcycle</code>, <code>minstret</code>, and <code>mhpmcounter n</code>, respectively. The <code>time</code> CSR
is a read-only shadow of the memory-mapped <code>mtime</code> register.
Analogously, when XLEN=32, the <code>cycleh</code>, <code>instreth</code> and <code>hpmcounternh</code> CSRs
are read-only shadows of <code>mcycleh</code>, <code>minstreth</code> and <code>mhpmcounternh</code>,
respectively. When XLEN=32, the <code>timeh</code> CSR is a read-only shadow of the
upper 32 bits of the memory-mapped <code>mtime</code> register, while <code>time</code>
shadows only the lower 32 bits of <code>mtime</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Implementations can convert reads of the <code>time</code> and <code>timeh</code> CSRs into
loads to the memory-mapped <code>mtime</code> register, or emulate this
functionality on behalf of less-privileged modes in M-mode software.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In harts with U-mode, the <code>mcounteren</code> must be implemented, but all
fields are <strong>WARL</strong> and may be read-only zero, indicating reads to the
corresponding counter will cause an illegal-instruction exception when
executing in a less-privileged mode. In harts without U-mode, the
<code>mcounteren</code> register should not exist.</p>
</div>
</div>
<div class="sect3">
<h4 id="_machine_counter_inhibit_mcountinhibit_register"><a class="anchor" href="#_machine_counter_inhibit_mcountinhibit_register"></a>Machine Counter-Inhibit (<code>mcountinhibit</code>) Register</h4>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNq9UV1LwzAUfd-vuOSpRVqatNWtr4Low0B8k7GHdEtdMUtKUp0f9L97R4K26oqCDnI54ZxzP3ITrEXF29ZYKBrJawULj69FpVUbVXxby2cg8xOgDVxwKUu-uifdMpwEmApG76KNqO82LWT5gONrYaJKgaql50v9JGzUII0OSNmeNnwXrbR82CqfYrGzL8gScEPY-kUAnUIheSmkhcCIR3QKWJCEAKEYDANP6iBzkGOcuuvPD5t6nPmSiUdKlmEXTvzQ-Bggl9dzpHFi23AFrAs_i8mIuG_wvRjH8btEz74k5iNFs7FpDmlXNx_thkpySDi_HSh9qbcQKEpt3Kd2w_y_M7G0t6tjNPylif6X6Q1q7hhj" alt="Counter-inhibit `mcountinhibit` register">
</div>
<div class="title">Figure 18. Counter-inhibit <code>mcountinhibit</code> register</div>
</div>
<div class="paragraph">
<p>The counter-inhibit register <code>mcountinhibit</code> is a 32-bit <strong>WARL</strong> register that
controls which of the hardware performance-monitoring counters
increment. The settings in this register only control whether the
counters increment; their accessibility is not affected by the setting
of this register.</p>
</div>
<div class="paragraph">
<p>When the CY, IR, or HPM<em>n</em> bit in the <code>mcountinhibit</code> register is clear,
the <code>mcycle</code>, <code>minstret</code>, or <code>mhpmcountern</code> register increments as usual.
When the CY, IR, or HPM_n_ bit is set, the corresponding counter does
not increment.</p>
</div>
<div class="paragraph">
<p>The <code>mcycle</code> CSR may be shared between harts on the same core, in which
case the <code>mcountinhibit.CY</code> field is also shared between those harts,
and so writes to <code>mcountinhibit.CY</code> will be visible to those harts.</p>
</div>
<div class="paragraph">
<p>If the <code>mcountinhibit</code> register is not implemented, the implementation
behaves as though the register were set to zero.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When the <code>mcycle</code> and <code>minstret</code> counters are not needed, it is desirable
to conditionally inhibit them to reduce energy consumption. Providing a
single CSR to inhibit all counters also allows the counters to be
atomically sampled.</p>
</div>
<div class="paragraph">
<p>Because the <code>mtime</code> counter can be shared between multiple cores, it
cannot be inhibited with the <code>mcountinhibit</code> mechanism.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_machine_scratch_mscratch_register"><a class="anchor" href="#_machine_scratch_mscratch_register"></a>Machine Scratch (<code>mscratch</code>) Register</h4>
<div class="paragraph">
<p>The <code>mscratch</code> register is an MXLEN-bit read/write register dedicated
for use by machine mode. Typically, it is used to hold a pointer to a
machine-mode hart-local context space and swapped with a user register
upon entry to an M-mode trap handler.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNp1kE9rwzAMxe_9FMKnhmFI0jBG7uup23lQdlASuzFz7CAL2rXku09b29Hsz0nw9N7TDy07Y5GZEtSjRxdge5mn2sbA2uLg_DuopzsoRlij9w22bwrO2-SOBspqes0WSykCinvdG7frGaocZiJ2hrQNEJy_6N5Y1gPSTq4VeX51f6Z_y008mKRH6ZA6WJXZQnTCvZaF0L1sHp91oYQ6jSi5e6jZHFhjaPtIoBIjsVA3kYQjwWmastuC_P-oCd3P4G1ySC0ht726fuzrJ8UDnOtW5fQH6txcVt_m-aEPksaETw==" alt="Machine-mode scratch register.">
</div>
<div class="title">Figure 19. Machine-mode scratch register.</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The MIPS ISA allocated two user registers (<code>k0</code>/<code>k1</code>) for use by the
operating system. Although the MIPS scheme provides a fast and simple
implementation, it also reduces available user registers, and does not
scale to further privilege levels, or nested traps. It can also require
both registers are cleared before returning to user level to avoid a
potential security hole and to provide deterministic debugging behavior.</p>
</div>
<div class="paragraph">
<p>The RISC-V user ISA was designed to support many possible privileged
system environments and so we did not want to infect the user-level ISA
with any OS-dependent features. The RISC-V CSR swap instructions can
quickly save/restore values to the <code>mscratch</code> register. Unlike the MIPS
design, the OS can rely on holding a value in the <code>mscratch</code> register
while the user context is running.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_machine_exception_program_counter_mepc_register"><a class="anchor" href="#_machine_exception_program_counter_mepc_register"></a>Machine Exception Program Counter (<code>mepc</code>) Register</h4>
<div class="paragraph">
<p><code>mepc</code> is an MXLEN-bit read/write register formatted as shown in
<a href="#mepcreg">Machine exception program counter register.</a>. The low bit of <code>mepc</code> (<code>mepc[0]</code>) is
always zero. On implementations that support only IALIGN=32, the two low
bits (<code>mepc[1:0]</code>) are always zero.</p>
</div>
<div class="paragraph">
<p>If an implementation allows IALIGN to be either 16 or 32 (by changing
CSR <code>misa</code>, for example), then, whenever IALIGN=32, bit <code>mepc[1]</code> is
masked on reads so that it appears to be 0. This masking occurs also for
the implicit read by the MRET instruction. Though masked, <code>mepc[1]</code>
remains writable when IALIGN=32.</p>
</div>
<div class="paragraph">
<p><code>mepc</code> is a <strong>WARL</strong> register that must be able to hold all valid virtual
addresses. It need not be capable of holding all possible invalid
addresses. Prior to writing <code>mepc</code>, implementations may convert an
invalid address into some other invalid address that <code>mepc</code> is capable
of holding.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When address translation is not in effect, virtual addresses and
physical addresses are equal. Hence, the set of addresses <code>mepc</code> must be
able to represent includes the set of physical addresses that can be
used as a valid <code>pc</code> or effective address.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When a trap is taken into M-mode, <code>mepc</code> is written with the virtual
address of the instruction that was interrupted or that encountered the
exception. Otherwise, <code>mepc</code> is never written by the implementation,
though it may be explicitly written by software.</p>
</div>
<div id="mepcreg" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNp1kMFKxDAQhu_7FENOWyTQdhcPvetJPQviYdpOtmHTJCQDu7r03R21la3iKfDPfF9-ZtuTQeaUoYkOrYeX-b00JnjWBkfr3kA93kAV4R6da7E7KvieZvtOUO-n12KzFRGkcNID2cPAsC9hFWJPSRsP3ro5d2RYj5gO8ltVlsv2J_03bsOZso7iEB3s6mIjecKTloG0e364e9KVktY5onC30DCdWaPvhpBAZcbE0roNSXpkuExTcS0o_0fJ97_Ba3Kk2P3Au3qt_eqlllvO14Jld239ANwufhM=?id=mepcreg" alt="Machine exception program counter register.">
</div>
<div class="title">Figure 20. Machine exception program counter register.</div>
</div>
</div>
<div class="sect3">
<h4 id="mcause"><a class="anchor" href="#mcause"></a>Machine Cause (<code>mcause</code>) Register</h4>
<div class="paragraph">
<p>The <code>mcause</code> register is an MXLEN-bit read-write register formatted as
shown in <a href="#mcausereg">Machine Cause (<code>mcause</code>) register.</a>. When a trap is taken into
M-mode, <code>mcause</code> is written with a code indicating the event that
caused the trap. Otherwise, <code>mcause</code> is never written by the
implementation, though it may be explicitly written by software.</p>
</div>
<div class="paragraph">
<p>The Interrupt bit in the <code>mcause</code> register is set if the trap was caused
by an interrupt. The Exception Code field contains a code identifying
the last exception or interrupt. <a href="#mcauses">Machine cause (<code>mcause</code>) register values after trap.</a> lists
the possible machine-level exception codes. The Exception Code is a
<strong>WLRL</strong> field, so is only guaranteed to hold supported exception codes.</p>
</div>
<div id="mcausereg" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNqlUj1rwzAQ3fMrDk02RWA7KRSvJYVC2qFLC6WDbJ9jUVkS8oWkDfnvlZvEsbGHhk5C7-596HRBgaUgcg2kVgmp4f107tPSaOKlqKX6AvZ0A7GFB6FUJvJPBsdqI78RksXhI5wFXgic2fIK5boiWEQwAEWBjpcatFQnXGFJvBZu7d2SKDp3t-wxnJkdNtx6DS8H8yScedyJLfcFn-5ttXzmMfOpGys0LCDNjPOODewPh3DcmnSt8aAXUsIdcaHzyjhgDQlHbCgQ_Y2KumiJfeajJnRuY-mScyi93OVoSRoN96ZAuBjdToj3vFMy9nzlG-1QCcKiRYhMPVVpZz_Gh6MKWktgwevqZRWy80Jsj9_LMqPaB3YR55Oj-1fI31WYTtmf2hXfHnfPOG0uHInJ3ZD5A-o7Bk0=?id=mcausereg" alt="Machine Cause (`mcause`) register.">
</div>
<div class="title">Figure 21. Machine Cause (<code>mcause</code>) register.</div>
</div>
<div class="paragraph">
<p>Note that load and load-reserved instructions generate load exceptions,
whereas store, store-conditional, and AMO instructions generate
store/AMO exceptions.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Interrupts can be separated from other traps with a single branch on the
sign of the <code>mcause</code> register value. A shift left can remove the
interrupt bit and scale the exception codes to index into a trap vector
table.</p>
</div>
<hr>
<div class="paragraph">
<p>We do not distinguish privileged instruction exceptions from
illegal-instruction exceptions. This simplifies the architecture and also hides
details of which higher-privilege instructions are supported by an
implementation. The privilege level servicing the trap can implement a
policy on whether these need to be distinguished, and if so, whether a
given opcode should be treated as illegal or privileged.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If an instruction may raise multiple synchronous exceptions, the
decreasing priority order of
<a href="#exception-priority">Synchronous exception priority in decreasing priority order.</a> indicates which
exception is taken and reported in <code>mcause</code>. The priority of any custom
synchronous exceptions is implementation-defined.</p>
</div>
<div style="page-break-after: always;"></div>
<table id="mcauses" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 6. Machine cause (<code>mcause</code>) register values after trap.</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-right valign-top">Interrupt</th>
<th class="tableblock halign-right valign-top">Exception Code</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">1<br>
1<br>
1<br>
1</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">0<br>
1<br>
2<br>
3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Reserved</em><br>
Supervisor software interrupt<br>
<em>Reserved</em><br>
Machine software interrupt</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">1<br>
1<br>
1<br>
1</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">4<br>
5<br>
6<br>
7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Reserved</em><br>
Supervisor timer interrupt<br>
<em>Reserved</em><br>
Machine timer interrupt</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">1<br>
1<br>
1<br>
1</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">8<br>
9<br>
10<br>
11</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Reserved</em><br>
Supervisor external interrupt<br>
<em>Reserved</em><br>
Machine external interrupt</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">1<br>
1<br>
1<br>
1</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">12<br>
13<br>
14-15<br>
&#8805;16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Reserved</em><br>
Counter-overflow interrupt<br>
<em>Reserved</em><br>
<em>Designated for platform use</em></p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0<br>
0</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">0<br>
1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
10<br>
11<br>
12<br>
13<br>
14<br>
15<br>
16<br>
17<br>
18<br>
19<br>
20-23<br>
24-31<br>
32-47<br>
48-63<br>
&#8805;64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Instruction address misaligned<br>
Instruction access fault<br>
Illegal instruction<br>
Breakpoint<br>
Load address misaligned<br>
Load access fault<br>
Store/AMO address misaligned<br>
Store/AMO access fault<br>
Environment call from U-mode<br>
Environment call from S-mode<br>
<em>Reserved</em><br>
Environment call from M-mode<br>
Instruction page fault<br>
Load page fault<br>
<em>Reserved</em><br>
Store/AMO page fault<br>
Double trap<br>
<em>Reserved</em><br>
Software check<br>
Hardware error<br>
<em>Reserved</em><br>
<em>Designated for custom use</em><br>
<em>Reserved</em><br>
<em>Designated for custom use</em><br>
<em>Reserved</em></p></td>
</tr>
</tbody>
</table>
<div style="page-break-after: always;"></div>
<table id="exception-priority" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 7. Synchronous exception priority in decreasing priority order.</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Priority</th>
<th class="tableblock halign-right valign-top">Exc.Code</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Highest</em></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Instruction address breakpoint</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-right valign-bottom"><p class="tableblock">12, 1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">During instruction address translation:<br>
First encountered page fault or access fault</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-right valign-bottom"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">With physical address for instruction:<br>
Instruction access fault</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-right valign-bottom"><p class="tableblock">2<br>
0<br>
8,9,11<br>
3<br>
3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Illegal instruction<br>
Instruction address misaligned<br>
Environment call<br>
Environment break<br>
Load/store/AMO address breakpoint</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-right valign-bottom"><p class="tableblock">4,6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optionally:<br>
Load/store/AMO address misaligned</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-right valign-bottom"><p class="tableblock">13, 15, 5, 7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">During address translation for an explicit memory access:<br>
First encountered page fault or access fault</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-right valign-bottom"><p class="tableblock">5,7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">With physical address for an explicit memory access:<br>
Load/store/AMO access fault</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-bottom"><p class="tableblock"><em>Lowest</em></p></td>
<td class="tableblock halign-right valign-bottom"><p class="tableblock">4,6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If not higher priority:<br>
Load/store/AMO address misaligned</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>When a virtual address is translated into a physical address, the
address translation algorithm determines what specific exception may be
raised.</p>
</div>
<div class="paragraph">
<p>Load/store/AMO address-misaligned exceptions may have either higher or
lower priority than load/store/AMO page-fault and access-fault
exceptions.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The relative priority of load/store/AMO address-misaligned and
page-fault exceptions is implementation-defined to flexibly cater to two
design points. Implementations that never support misaligned accesses
can unconditionally raise the misaligned-address exception without
performing address translation or protection checks. Implementations
that support misaligned accesses only to some physical addresses must
translate and check the address before determining whether the
misaligned access may proceed, in which case raising the page-fault
exception or access is more appropriate.</p>
</div>
<hr>
<div class="paragraph">
<p>Instruction address breakpoints have the same cause value as, but
different priority than, data address breakpoints (a.k.a. watchpoints)
and environment break exceptions (which are raised by the EBREAK
instruction).</p>
</div>
<hr>
<div class="paragraph">
<p>Instruction address misaligned exceptions are raised by control-flow
instructions with misaligned targets, rather than by the act of fetching
an instruction. Therefore, these exceptions have lower priority than
other instruction address exceptions.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A Software Check exception is a synchronous exception that is triggered when
there are violations of checks and assertions defined by ISA extensions that
aim to safeguard the integrity of software assets, including e.g. control-flow
and memory-access constraints. When this exception is raised, the <code><em>x</em>tval</code>
register is set either to 0 or to an informative value defined by the extension
that stipulated the exception be raised.  The priority of this exception,
relative to other synchronous exceptions, depends on the cause of this exception
and is defined by the extension that stipulated the exception be raised.</p>
</div>
<div class="paragraph">
<p>A Hardware Error exception is a synchronous exception triggered when corrupted or
uncorrectable data is accessed explicitly or implicitly by an instruction.  In
this context, "data" encompasses all types of information used within a RISC-V
hart. Upon a hardware error exception, the <code><em>x</em>epc</code> register is set to the
address of the instruction that attempted to access corrupted data, while the
<code><em>x</em>tval</code> register is set either to 0 or to the virtual address of an
instruction fetch, load, or store that attempted to access corrupted data. The
priority of Hardware Error exception is implementation-defined, but any given
occurrence is generally expected to be recognized at the point in the overall
priority order at which the hardware error is discovered.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_machine_trap_value_mtval_register"><a class="anchor" href="#_machine_trap_value_mtval_register"></a>Machine Trap Value (<code>mtval</code>) Register</h4>
<div class="paragraph">
<p>The <code>mtval</code> register is an MXLEN-bit read-write register formatted as
shown in <a href="#mtvalreg">Machine Trap Value (<code>mtval</code>) register.</a>. When a trap is taken into
M-mode, <code>mtval</code> is either set to zero or written with exception-specific
information to assist software in handling the trap. Otherwise, <code>mtval</code>
is never written by the implementation, though it may be explicitly
written by software. The hardware platform will specify which exceptions
must set <code>mtval</code> informatively, which may unconditionally set it to
zero, and which may exhibit either behavior, depending on the underlying event
that caused the exception.
If the hardware platform specifies that no exceptions set <code>mtval</code>
to a nonzero value, then <code>mtval</code> is read-only zero.</p>
</div>
<div class="paragraph">
<p>If <code>mtval</code> is written with a nonzero value when a breakpoint,
address-misaligned, access-fault, or page-fault exception occurs on an
instruction fetch, load, or store, then <code>mtval</code> will contain the
faulting virtual address.</p>
</div>
<div class="paragraph">
<p>When page-based virtual memory is enabled, <code>mtval</code> is written with the
faulting virtual address, even for physical-memory access-fault
exceptions. This design reduces datapath cost for most implementations,
particularly those with hardware page-table walkers.</p>
</div>
<div id="mtvalreg" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNq1UMFqAjEQvfsVQ04bSmBdpYe9t6fac0E8zGqiobPJkqTaKvl3Z2ssiufCQJg3b968l2qjDaYUIrQDoXWwLO-pNd4lZbC39ANi8QTTAV6RqMP1p4DLNNqjhmaeV3JSsRAEf1A7bbe7BPMa7kDc6KCMA2ep4KRNUj2GLV9r6vrKHrcf4c5_66gG1mA5mDUjHPCg1p6-elf0I7su55vne4vQEnaaIlRB75mpYSlqAeKfavHx9vKupmOzkllOiltOAaJPeyTBVuOAjqNkeTv93RTX7_9zX7jQdj5ckuYsz8B4fT4=?id=mtvalreg" alt="Machine Trap Value (`mtval`) register.">
</div>
<div class="title">Figure 22. Machine Trap Value (<code>mtval</code>) register.</div>
</div>
<div class="paragraph">
<p>If <code>mtval</code> is written with a nonzero value when a misaligned load or
store causes an access-fault or page-fault exception, then <code>mtval</code> will
contain the virtual address of the portion of the access that caused the
fault.</p>
</div>
<div class="paragraph">
<p>If <code>mtval</code> is written with a nonzero value when an instruction
access-fault or page-fault exception occurs on a hart with
variable-length instructions, then <code>mtval</code> will contain the virtual
address of the portion of the instruction that caused the fault, while
<code>mepc</code> will point to the beginning of the instruction.</p>
</div>
<div class="paragraph">
<p>The <code>mtval</code> register can optionally also be used to return the faulting
instruction bits on an illegal-instruction exception (<code>mepc</code> points to
the faulting instruction in memory). If <code>mtval</code> is written with a
nonzero value when an illegal-instruction exception occurs, then <code>mtval</code>
will contain the shortest of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the actual faulting instruction</p>
</li>
<li>
<p>the first ILEN bits of the faulting instruction</p>
</li>
<li>
<p>the first MXLEN bits of the faulting instruction</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The value loaded into <code>mtval</code> on an illegal-instruction exception is
right-justified and all unused upper bits are cleared to zero.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Capturing the faulting instruction in <code>mtval</code> reduces the overhead of
instruction emulation, potentially avoiding several partial instruction
loads if the instruction is misaligned, and likely data cache misses or
slow uncached accesses when loads are used to fetch the instruction into
a data register. There is also a problem of atomicity if another agent
is manipulating the instruction memory, as might occur in a dynamic
translation system.</p>
</div>
<div class="paragraph">
<p>A requirement is that the entire instruction (or at least the first
MXLEN bits) are fetched into <code>mtval</code> before taking the trap. This should
not constrain implementations, which would typically fetch the entire
instruction before attempting to decode the instruction, and avoids
complicating software handlers.</p>
</div>
<div class="paragraph">
<p>A value of zero in <code>mtval</code> signifies either that the feature is not
supported, or an illegal zero instruction was fetched. A load from the
instruction memory pointed to by <code>mepc</code> can be used to distinguish these
two cases (or alternatively, the system configuration information can be
interrogated to install the appropriate trap handling before runtime).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>On a trap caused by a software check exception, the <code>mtval</code> register holds
the cause for the exception. The following encodings are defined:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>0 - No information provided.</p>
</li>
<li>
<p>2 - Landing Pad Fault. Defined by the Zicfilp extension (<a href="#priv-forward">[priv-forward]</a>).</p>
</li>
<li>
<p>3 - Shadow Stack Fault. Defined by the Zicfiss extension (<a href="#priv-backward">[priv-backward]</a>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For other traps, <code>mtval</code> is set to zero, but a future standard may
redefine <code>mtval</code>’s setting for other traps.</p>
</div>
<div class="paragraph">
<p>If <code>mtval</code> is not read-only zero, it is a <strong>WARL</strong> register that must be able to
hold all valid virtual addresses and the value zero. It need not be
capable of holding all possible invalid addresses. Prior to writing
<code>mtval</code>, implementations may convert an invalid address into some other
invalid address that <code>mtval</code> is capable of holding. If the feature to
return the faulting instruction bits is implemented, <code>mtval</code> must also
be able to hold all values less than 2<sup><em>N</em></sup>, where
<em>N</em> is the smaller of MXLEN and ILEN.</p>
</div>
</div>
<div class="sect3">
<h4 id="_machine_configuration_pointer_mconfigptr_register"><a class="anchor" href="#_machine_configuration_pointer_mconfigptr_register"></a>Machine Configuration Pointer (<code>mconfigptr</code>) Register</h4>
<div class="paragraph">
<p>The <code>mconfigptr</code> register is an MXLEN-bit read-only CSR, formatted as shown in
<a href="#mconfigptrreg">Machine Configuration Pointer (<code>mconfigptr</code>) register.</a>, that holds the physical
address of a configuration data structure. Software can traverse this
data structure to discover information about the harts, the platform,
and their configuration.</p>
</div>
<div id="mconfigptrreg" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNq1UctqwzAQvOcrFp0sisBxQw--N6ek50DIYe2sHBFZEpKaR4v-vXKjlIaeC4JFs7OzM2y1J4kx-gCt06gMbEv9bKU1UUgclb4CWz_B3MESte6wPzK4dYP6IGgWacdnVRYCb8_iQGo4RFjU8ADinryQBozSBdckoxjRD3lbU9d39jT9F-7shYJwWSPLwXMzwR7Porf6fTRFP2TXZX3z8mgRWo0d6QCVp1NmEmxZzYD901tvVq9vYj59djzxWXGbUwAbe2ukGlz0LPsNDk3Ok_hvyvc4u9_gJ0LhQttZf4ubEv8CW_9_Uw==?id=mconfigptrreg" alt="Machine Configuration Pointer (`mconfigptr`) register.">
</div>
<div class="title">Figure 23. Machine Configuration Pointer (<code>mconfigptr</code>) register.</div>
</div>
<div class="paragraph">
<p>The pointer alignment in bits must be no smaller than MXLEN:
i.e., if MXLEN is
\(8\times n\), then <code>mconfigptr</code>[\(\log_2n\)-1:0]
must be zero.</p>
</div>
<div class="paragraph">
<p>The <code>mconfigptr</code> register must be implemented, but it may be zero to indicate the
configuration data structure does not exist or that an alternative
mechanism must be used to locate it.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The format and schema of the configuration data structure have yet to be
standardized.</p>
</div>
<hr>
<div class="paragraph">
<p>While the <code>mconfigptr</code> register will simply be hardwired in some implementations,
other implementations may provide a means to configure the value
returned on CSR reads. For example, <code>mconfigptr</code> might present the value
of a memory-mapped register that is programmed by the platform or by
M-mode software towards the beginning of the boot process.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="sec:menvcfg"><a class="anchor" href="#sec:menvcfg"></a>Machine Environment Configuration (<code>menvcfg</code>) Register</h4>
<div class="paragraph">
<p>The <code>menvcfg</code> CSR is a 64-bit read/write register, formatted
as shown in <a href="#menvcfgreg">Machine environment configuration (<code>menvcfg</code>) register.</a>, that controls
certain characteristics of the execution environment for modes less
privileged than M.</p>
</div>
<div id="menvcfgreg" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UlAw1FHIS8xNtVJQd_P091Wv1cEqFx4Q5IlLzifAFZdUcDCalBFcytnJE6c2ZydnNzySUahyRiZ4nImwMMAX1XdGpkT5ziUEt0tccEo5uoTilAtw8sVtZnCIM1guVkchOT8vLTPdqjonMS8VqAjoy4zigsTkVCtDAyOT2loAOdx-Fg==?id=menvcfgreg" alt="Machine environment configuration (`menvcfg`) register.">
</div>
<div class="title">Figure 24. Machine environment configuration (<code>menvcfg</code>) register.</div>
</div>
<div class="paragraph">
<p>If bit FIOM (Fence of I/O implies Memory) is set to one in <code>menvcfg</code>,
FENCE instructions executed in modes less privileged than M are modified
so the requirement to order accesses to device I/O implies also the
requirement to order main memory accesses. <a href="#menvcfg-FIOM">Modified interpretation of FENCE predecessor and successor sets for modes less privileged than M when FIOM=1.</a>
details the modified interpretation of FENCE instruction bits PI, PO,
SI, and SO for modes less privileged than M when FIOM=1.</p>
</div>
<div class="paragraph">
<p>Similarly, for modes less privileged than M when FIOM=1, if an atomic
instruction that accesses a region ordered as device I/O has its <em>aq</em>
and/or <em>rl</em> bit set, then that instruction is ordered as though it
accesses both device I/O and memory.</p>
</div>
<div class="paragraph">
<p>If S-mode is not supported, or if <code>satp</code>.MODE is read-only zero (always
Bare), the implementation may make FIOM read-only zero.</p>
</div>
<table id="menvcfg-FIOM" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 8. Modified interpretation of FENCE predecessor and successor sets for modes less privileged than M when FIOM=1.</caption>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Instruction bit</th>
<th class="tableblock halign-left valign-top">Meaning when set</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">PI<br>
PO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Predecessor device input and memory reads (PR implied)<br>
Predecessor device output and memory writes (PW implied)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">SI<br>
SO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Successor device input and memory reads (SR implied)<br>
Successor device output and memory writes (SW implied)</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Bit FIOM is needed in <code>menvcfg</code> so M-mode can emulate the hypervisor
extension of <a href="#hypervisor">[hypervisor]</a>, which has an
equivalent FIOM bit in the hypervisor CSR <code>henvcfg</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The PBMTE bit controls whether the Svpbmt extension is available for use
in S-mode and G-stage address translation (i.e., for page tables pointed
to by <code>satp</code> or <code>hgatp</code>). When PBMTE=1, Svpbmt is available for S-mode
and G-stage address translation. When PBMTE=0, the implementation
behaves as though Svpbmt were not implemented. If Svpbmt is not
implemented, PBMTE is read-only zero. Furthermore, for implementations
with the hypervisor extension, <code>henvcfg</code>.PBMTE is read-only zero if
<code>menvcfg</code>.PBMTE is zero.</p>
</div>
<div class="paragraph">
<p>After changing <code>menvcfg</code>.PBMTE, executing an SFENCE.VMA instruction with
<em>rs1</em>=<code>x0</code> and <em>rs2</em>=<code>x0</code> suffices to synchronize address-translation caches
with respect to the altered interpretation of page-table entries' PBMT fields.
See <a href="#hyp-mm-fences">[hyp-mm-fences]</a> for additional synchronization requirements when the
hypervisor extension is implemented.</p>
</div>
<div class="paragraph">
<p>If the Svadu extension is implemented, the ADUE bit controls whether hardware
updating of PTE A/D bits is enabled for S-mode and G-stage address
translations.
When ADUE=1, hardware updating of PTE A/D bits is enabled during S-mode
address translation, and the implementation behaves as though the Svade
extension were not implemented for S-mode address translation.
When the hypervisor extension is implemented, if ADUE=1, hardware updating of
PTE A/D bits is enabled during G-stage address translation, and the
implementation behaves as though the Svade extension were not implemented for
G-stage address translation.
When ADUE=0, the implementation behaves as though Svade were implemented for
S-mode and G-stage address translation.
If Svadu is not implemented, ADUE is read-only zero.
Furthermore, for implementations with the hypervisor extension, <code>henvcfg</code>.ADUE
is read-only zero if <code>menvcfg</code>.ADUE is zero.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The Svade extension requires page-fault exceptions be raised when PTE
A/D bits need be set, hence Svade is implemented when ADUE=0.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the Smcdeleg extension is implemented, the CDE (Counter Delegation Enable) bit controls whether Zicntr and Zihpm counters can be delegated to S-mode. When CDE=1, the Smcdeleg extension is enabled, see <a href="#smcdeleg">[smcdeleg]</a>. When CDE=0, the Smcdeleg and Ssccfg extensions appear to be not implemented. If Smcdeleg is not implemented, CDE is read-only zero.</p>
</div>
<div class="paragraph">
<p>The definition of the STCE field is furnished by the Sstc extension.</p>
</div>
<div class="paragraph">
<p>The definition of the CBZE field is furnished by the Zicboz extension.</p>
</div>
<div class="paragraph">
<p>The definitions of the CBCFE and CBIE fields are furnished by the Zicbom extension.</p>
</div>
<div class="paragraph">
<p>The definition of the PMM field is furnished by the Smnpm extension.</p>
</div>
<div class="paragraph">
<p>The Zicfilp extension adds the <code>LPE</code> field in <code>menvcfg</code>. When the <code>LPE</code> field is
set to 1 and S-mode is implemented, the Zicfilp extension is enabled in S-mode.
If <code>LPE</code> field is set to 1 and S-mode is not implemented, the Zicfilp extension
is enabled in U-mode. When the <code>LPE</code> field is 0, the Zicfilp extension is not
enabled in S-mode, and the following rules apply to S-mode. If the <code>LPE</code> field
is 0 and S-mode is not implemented, then the same rules apply to U-mode.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The hart does not update the <code>ELP</code> state; it remains as <code>NO_LP_EXPECTED</code>.</p>
</li>
<li>
<p>The <code>LPAD</code> instruction operates as a no-op.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Zicfiss extension adds the <code>SSE</code> field to <code>menvcfg</code>. When the <code>SSE</code> field is
set to 1 the Zicfiss extension is activated in S-mode. When <code>SSE</code> field is 0,
the following rules apply to privilege modes that are less than M:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>32-bit Zicfiss instructions will revert to their behavior as defined by Zimop.</p>
</li>
<li>
<p>16-bit Zicfiss instructions will revert to their behavior as defined by Zcmop.</p>
</li>
<li>
<p>The <code>pte.xwr=010b</code> encoding in VS/S-stage page tables becomes reserved.</p>
</li>
<li>
<p><code>SSAMOSWAP.W/D</code> raises an illegal-instruction exception.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When <code>menvcfg.SSE</code> is 0, the <code>henvcfg.SSE</code> and <code>senvcfg.SSE</code> fields are
read-only zero.</p>
</div>
<div class="paragraph">
<p>The Ssdbltrp extension adds the double-trap-enable (<code>DTE</code>) field in <code>menvcfg</code>.
When <code>menvcfg.DTE</code> is zero, the implementation behaves as though Ssdbltrp is not
implemented. When Ssdbltrp is not implemented <code>sstatus.SDT</code>, <code>vsstatus.SDT</code>, and
<code>henvcfg.DTE</code> bits are read-only zero.</p>
</div>
<div class="paragraph">
<p>When XLEN=32, <code>menvcfgh</code> is a 32-bit read/write register
that aliases bits 63:32 of <code>menvcfg</code>.
The <code>menvcfgh</code> register does not exist when XLEN=64.</p>
</div>
<div class="paragraph">
<p>If U-mode is not supported, then registers <code>menvcfg</code> and <code>menvcfgh</code> do
not exist.</p>
</div>
</div>
<div class="sect3">
<h4 id="_machine_security_configuration_mseccfg_register"><a class="anchor" href="#_machine_security_configuration_mseccfg_register"></a>Machine Security Configuration (<code>mseccfg</code>) Register</h4>
<div class="paragraph">
<p><code>mseccfg</code> is an optional 64-bit read/write register, formatted as
shown in <a href="#mseccfg">Machine security configuration (<code>mseccfg</code>) register.</a>, that controls security features.</p>
</div>
<div id="mseccfg" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UlAw1FHIS8xNtVJQ9_X1Ua_VwSEVHoBLLsjHCVXKFC4VHhDkiUtbaLCrqwsuyWB8kr4-Aa4ocqbGGDbG6igk5-elZaZbVeck5qUCFZnoKGQUFyQmp1oZGhiZ1NYCADCZSmc=?id=mseccfg" alt="Machine security configuration (`mseccfg`) register.">
</div>
<div class="title">Figure 25. Machine security configuration (<code>mseccfg</code>) register.</div>
</div>
<div class="paragraph">
<p>The definitions of the SSEED and USEED fields are furnished by the
entropy-source extension, Zkr.</p>
</div>
<div class="paragraph">
<p>The definitions of the RLB, MMWP, and MML fields are furnished by the
PMP-enhancement extension, Smepmp.</p>
</div>
<div class="paragraph">
<p>The definition of the PMM field is furnished by the Smmpm extension.</p>
</div>
<div class="paragraph">
<p>The Zicfilp extension adds the <code>MLPE</code> field in <code>mseccfg</code>. When <code>MLPE</code> field is
1, Zicfilp extension is enabled in M-mode. When the <code>MLPE</code> field is 0, the
Zicfilp extension is not enabled in M-mode and the following rules apply to
M-mode.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The hart does not update the <code>ELP</code> state; it remains as <code>NO_LP_EXPECTED</code>.</p>
</li>
<li>
<p>The <code>LPAD</code> instruction operates as a no-op.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When XLEN=32 only, <code>mseccfgh</code> is a 32-bit read/write register that
aliases bits 63:32 of <code>mseccfg</code>.
Register <code>mseccfgh</code> does not exist when XLEN=64.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_machine_level_memory_mapped_registers"><a class="anchor" href="#_machine_level_memory_mapped_registers"></a>Machine-Level Memory-Mapped Registers</h3>
<div class="sect3">
<h4 id="_machine_timer_mtime_and_mtimecmp_registers"><a class="anchor" href="#_machine_timer_mtime_and_mtimecmp_registers"></a>Machine Timer (<code>mtime</code> and <code>mtimecmp</code>) Registers</h4>
<div class="paragraph">
<p>Platforms provide a real-time counter, exposed as a memory-mapped
machine-mode read-write register, <code>mtime</code>. <code>mtime</code> must increment at
constant frequency, and the platform must provide a mechanism for
determining the period of an <code>mtime</code> tick. The <code>mtime</code> register will
wrap around if the count overflows.</p>
</div>
<div class="paragraph">
<p>The <code>mtime</code> register has a 64-bit precision on all RV32 and RV64
systems. Platforms provide a 64-bit memory-mapped machine-mode timer
compare register (<code>mtimecmp</code>). A machine timer interrupt becomes pending
whenever <code>mtime</code> contains a value greater than or equal to <code>mtimecmp</code>,
treating the values as unsigned integers. The interrupt remains posted
until <code>mtimecmp</code> becomes greater than <code>mtime</code> (typically as a result of
writing <code>mtimecmp</code>). The interrupt will only be taken if interrupts are
enabled and the MTIE bit is set in the <code>mie</code> register.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNq1kE1qAzEMhfc5hdBqTDFMJ0MWc4DueoKQhSaRE1PZHmy36Q--ex3ilIauCwbD0_PT99wd2FDOMcG0CFkP23Z_TSb4rA05Kx-Azw_wuMATicy0f0G4TpP9ZBjGslOrrgZBDGd9Yns8ZRh7uBPpwFEbD95K04VN1o7isW4b-v7mvrz-K8_hnZNeakaNg_VwkSOd9T7Iq_MtP1Xqtn4Y7xFhEppZEnSR36qTYYs9Av7f2axxp4paNdBaANBl6xgrZVrI1xZF_Z5uRrx9-w91M8I0h3htWIr6BtmpeqE=" alt="Machine time register (memory-mapped control register).">
</div>
<div class="title">Figure 26. Machine time register (memory-mapped control register).</div>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNq1kE1qwzAQhfc5xaCVRRG4jvHCB-iuJwhZjJ1RIjr6QVKb_qC7VyFKaei6IBC8eXrzPXUH0phzTDAHRuNg1-6vWXuXlUZr-APE8wM8BnhC5gXXFwHXaTKfBMNY9nLT1SCI_qxOZI6nDGMPdyIeKCrtwBluOpPOymI81m1D39_cl9d_5cW_U1KhZtQ42A4XOeJZrZ5frWv5qVK39cN0jwgz40KcoIv0Vp0EO9ELEP93pq3YyyI3DbQWAGGzsbTaICpoCuhqkSJ_G6ZR3H7-B7wZYV58vJYsRX4DYrd74w==" alt="Machine time compare register (memory-mapped control register).">
</div>
<div class="title">Figure 27. Machine time compare register (memory-mapped control register).</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The timer facility is defined to use wall-clock time rather than a cycle
counter to support modern processors that run with a highly variable
clock frequency to save energy through dynamic voltage and frequency
scaling.</p>
</div>
<div class="paragraph">
<p>Accurate real-time clocks (RTCs) are relatively expensive to provide
(requiring a crystal or MEMS oscillator) and have to run even when the
rest of system is powered down, and so there is usually only one in a
system located in a different frequency/voltage domain from the
processors. Hence, the RTC must be shared by all the harts in a system
and accesses to the RTC will potentially incur the penalty of a
voltage-level-shifter and clock-domain crossing. It is thus more natural
to expose <code>mtime</code> as a memory-mapped register than as a CSR.</p>
</div>
<div class="paragraph">
<p>Lower privilege levels do not have their own <code>timecmp</code> registers.
Instead, machine-mode software can implement any number of virtual
timers on a hart by multiplexing the next timer interrupt into the
<code>mtimecmp</code> register.</p>
</div>
<div class="paragraph">
<p>Simple fixed-frequency systems can use a single clock for both cycle
counting and wall-clock time.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the result of the comparison between <code>mtime</code> and <code>mtimecmp</code> changes, it is
guaranteed to be reflected in MTIP eventually, but not necessarily
immediately.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A spurious timer interrupt might occur if an interrupt handler
increments <code>mtimecmp</code> then immediately returns, because MTIP might not
yet have fallen in the interim. All software should be written to assume
this event is possible, but most software should assume this event is
extremely unlikely. It is almost always more performant to incur an
occasional spurious timer interrupt than to poll MTIP until it falls.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In RV32, memory-mapped writes to <code>mtimecmp</code> modify only one 32-bit part
of the register. The following code sequence sets a 64-bit <code>mtimecmp</code>
value without spuriously generating a timer interrupt due to the
intermediate value of the comparand:</p>
</div>
<div class="paragraph">
<p>For RV64, naturally aligned 64-bit memory accesses to the <code>mtime</code> and
<code>mtimecmp</code> registers are additionally supported and are atomic.</p>
</div>
<div class="literalblock">
<div class="title">Sample code for setting the 64-bit time comparand in RV32 assuming a little-endian memory system and that the registers live in a strongly ordered I/O region.  Storing -1 to the low-order bits of <code>mtimecmp</code> prevents <code>mtimecmp</code> from temporarily becoming smaller than the lesser of the old and new values.</div>
<div class="content">
<pre>            # New comparand is in a1:a0.
            li t0, -1
            la t1, mtimecmp
            sw t0, 0(t1)     # No smaller than old value.
            sw a1, 4(t1)     # No smaller than new value.
            sw a0, 0(t1)     # New value.</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>time</code> CSR is a read-only shadow of the memory-mapped <code>mtime</code> register.
When XLEN=32, the <code>timeh</code> CSR is a read-only shadow of the upper 32 bits of the
memory-mapped <code>mtime</code> register, while <code>time</code> shadows only the lower 32 bits of
<code>mtime</code>.
When <code>mtime</code> changes, it is guaranteed to be reflected in <code>time</code> and <code>timeh</code>
eventually, but not necessarily immediately.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_machine_mode_privileged_instructions"><a class="anchor" href="#_machine_mode_privileged_instructions"></a>Machine-Mode Privileged Instructions</h3>
<div class="sect3">
<h4 id="_environment_call_and_breakpoint"><a class="anchor" href="#_environment_call_and_breakpoint"></a>Environment Call and Breakpoint</h4>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjDXUchLzE21UlDPL0jOT0lV11FILCkpAqpRN1fXUQ-ODA5x9UUwYnVqdRCaTeGai1KQNJoC1RuAMapyY7jytNK85BJjJC1AtnpAkGcYjMJpT7EhERYZGqHaZGiEpAnEUXd1dvTxAdFOQa6O3uo6sUDtsToKyfl5aZnAAII52Ki2FgDvfFSH" alt="svg">
</div>
</div>
<div class="paragraph">
<p>The ECALL instruction is used to make a request to the supporting
execution environment. When executed in U-mode, S-mode, or M-mode, it
generates an environment-call-from-U-mode exception,
environment-call-from-S-mode exception, or environment-call-from-M-mode
exception, respectively, and performs no other operation.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>ECALL generates a different exception for each originating privilege
mode so that environment call exceptions can be selectively delegated. A
typical use case for Unix-like operating systems is to delegate to
S-mode the environment-call-from-U-mode exception but not the others.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The EBREAK instruction is used by debuggers to cause control to be
transferred back to a debugging environment.
Unless overridden by an external debug environment, EBREAK raises
a breakpoint exception and performs no other operation.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>As described in the "C" Standard Extension for Compressed Instructions
in Volume I of this manual, the C.EBREAK instruction performs the same
operation as the EBREAK instruction.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>ECALL and EBREAK cause the receiving privilege mode’s <code>epc</code> register to
be set to the address of the ECALL or EBREAK instruction itself, <em>not</em>
the address of the following instruction. As ECALL and EBREAK cause
synchronous exceptions, they are not considered to retire, and should
not increment the <code>minstret</code> CSR.</p>
</div>
</div>
<div class="sect3">
<h4 id="otherpriv"><a class="anchor" href="#otherpriv"></a>Trap-Return Instructions</h4>
<div class="paragraph">
<p>Instructions to return from trap are encoded under the PRIV minor
opcode.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjDXUchLzE21UlDPL0jOT0lV11FILCkpAqpRN1fXUQ-ODA5x9VWP1anVQegxhespSkFSbwpUb4Cm1BiuNK00L7nEGEk5kK0eEOQZhtvwYkMCphsaoRpvaISkAcRR9w1yDdEPBhLqOrFAnbE6Csn5eWmZwDCAOdCothYAgSZOOQ==" alt="svg">
</div>
</div>
<div class="paragraph">
<p>To return after handling a trap, there are separate trap return
instructions per privilege level, MRET and SRET. MRET is always
provided. SRET must be provided if supervisor mode is supported, and
should raise an illegal-instruction exception otherwise. SRET should
also raise an illegal-instruction exception when TSR=1 in <code>mstatus</code>, as
described in <a href="#virt-control">Virtualization Support in <code>mstatus</code> Register</a>. An <em>x</em>RET instruction
can be executed in privilege mode <em>x</em> or higher, where executing a
lower-privilege <em>x</em>RET instruction will pop the relevant lower-privilege
interrupt enable and privilege mode stack. In addition to manipulating
the privilege stack as described in <a href="#privstack">Privilege and Global Interrupt-Enable Stack in <code>mstatus</code> register</a>,
<em>x</em>RET sets the <code>pc</code> to the value stored in the <code><em>x</em>epc</code> register.</p>
</div>
<div class="paragraph">
<p>If the A extension is supported, the <em>x</em>RET instruction is allowed to
clear any outstanding LR address reservation but is not required to.
Trap handlers should explicitly clear the reservation if required (e.g.,
by using a dummy SC) before executing the <em>x</em>RET.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If <em>x</em>RET instructions always cleared LR reservations, it would be
impossible to single-step through LR/SC sequences using a debugger.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="wfi"><a class="anchor" href="#wfi"></a>Wait for Interrupt</h4>
<div class="paragraph">
<p>The Wait for Interrupt instruction (WFI) informs the
implementation that the current hart can be stalled until an interrupt
might need servicing. Execution of the WFI instruction can also be used
to inform the hardware platform that suitable interrupts should
preferentially be routed to this hart. WFI is available in all
privileged modes, and optionally available to U-mode. This instruction
may raise an illegal-instruction exception when TW=1 in <code>mstatus</code>, as
described in <a href="#virt-control">Virtualization Support in <code>mstatus</code> Register</a>.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/wavedrom/svg/eNqrLkpNt1KI5lJQqE7KLCm2UjDXUchLzE21UlDPL0jOT0lV11FILCkpAqpRN1fXUQ-ODA5x9VWP1anVQegxhespSkFSbwpUb4Cm1BiuNK00L7nEGEk5kK0eEOQZhtvwYkMCphsaoRpvaISkAcRRD3fzVNeJBeqJ1VFIzs9LywT6HuY0o9paBQAAkEya" alt="svg">
</div>
</div>
<div class="paragraph">
<p>If an enabled interrupt is present or later becomes present while the
hart is stalled, the interrupt trap will be taken on the following
instruction, i.e., execution resumes in the trap handler and <code>mepc</code> =
<code>pc</code> + 4.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The following instruction takes the interrupt trap so that a simple
return from the trap handler will execute code after the WFI
instruction.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Implementations are permitted to resume execution for any reason, even if an
enabled interrupt has not become pending.  Hence, a legal implementation is to
simply implement the WFI instruction as a NOP.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If the implementation does not stall the hart on execution of the
instruction, then the interrupt will be taken on some instruction in the
idle loop containing the WFI, and on a simple return from the handler,
the idle loop will resume execution.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The WFI instruction can also be executed when interrupts are disabled.
The operation of WFI must be unaffected by the global interrupt bits in
<code>mstatus</code> (MIE and SIE) and the delegation register <code>mideleg</code> (i.e.,
the hart must resume if a locally enabled interrupt becomes pending,
even if it has been delegated to a less-privileged mode), but should
honor the individual interrupt enables (e.g, MTIE) (i.e.,
implementations should avoid resuming the hart if the interrupt is
pending but not individually enabled). WFI is also required to resume
execution for locally enabled interrupts pending at any privilege level,
regardless of the global interrupt enable at each privilege level.</p>
</div>
<div class="paragraph">
<p>If the event that causes the hart to resume execution does not cause an
interrupt to be taken, execution will resume at <code>pc</code> + 4, and software
must determine what action to take, including looping back to repeat the
WFI if there was no actionable event.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>By allowing wakeup when interrupts are disabled, an alternate entry
point to an interrupt handler can be called that does not require saving
the current context, as the current context can be saved or discarded
before the WFI is executed.</p>
</div>
<div class="paragraph">
<p>As implementations are free to implement WFI as a NOP, software must
explicitly check for any relevant pending but disabled interrupts in the
code following an WFI, and should loop back to the WFI if no suitable
interrupt was detected. The <code>mip</code> or <code>sip</code> registers can be interrogated
to determine the presence of any interrupt in machine or supervisor mode
respectively.</p>
</div>
<div class="paragraph">
<p>The operation of WFI is unaffected by the delegation register settings.</p>
</div>
<div class="paragraph">
<p>WFI is defined so that an implementation can trap into a higher
privilege mode, either immediately on encountering the WFI or after some
interval to initiate a machine-mode transition to a lower power state,
for example.</p>
</div>
<hr>
<div class="paragraph">
<p>The same "wait-for-event" template might be used for possible future
extensions that wait on memory locations changing, or message arrival.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_custom_system_instructions"><a class="anchor" href="#_custom_system_instructions"></a>Custom SYSTEM Instructions</h4>
<div class="paragraph">
<p>The subspace of the SYSTEM major opcode shown in <a href="#customsys">SYSTEM instruction encodings designated for custom use.</a> is designated for custom use. It is recommended that these instructions use bits 29:28 to designate the
minimum required privilege mode, as do other SYSTEM instructions.</p>
</div>
<div id="customsys" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNrtVc1vmzAUv_evePIpaELCkA-Je6cdFmla1sNU9eAYk1gzNrJN2qzif589CKVRiVKV7YRkbHjv975-fjazjOXEWm0gLQXhEu7b9TnNlbRhTgoujoDWnwCX8JkIsSX0F6ofgpuZMwWtHsM947u9hWQBr4QkYzrMJUguWrlguQ0LonfOf3TCetuTcH6SbtUTM2HpHDhfkMRerMljSJWoCtk6Ny7JNnY8hyZfw38ziCOAVJAtEwZmmh0clME9QvDGiJpl6Z5V84qxn-L2Y-6nxZumzYi9Ml6eSROMHoI6uGnzdvUAyitJrQM-p6YkEpZ10NfSylhVdFocvVb_NU46dXLR-EyrSqoyNqCdWfZkAX1nVBUFkxnL4FulS2W8QR2cjFaQemBIJN0rDajgWSYcJN0q3exFfVZur9IzVA_kye4qHob1Ch8GLa4Bra4AuY7tlT1YII6iqJf_cJUtxS-b1LSqPQoGiFsiOEUvTF_iIboi-_dFu0DV5ufmx-36-oh3stT8wAXbuR5yPXJn3Pn96o6f-GAnYTwR_X-I9jxPRHcRYVO5f9CBGzVaI0_89iKOTW-Ep3uiF_HLceTunej9l_T6u2Git4u4JnTPJRurdSdux-P2D1NKndo=?id=customsys" alt="SYSTEM instruction encodings designated for custom use.">
</div>
<div class="title">Figure 28. SYSTEM instruction encodings designated for custom use.</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="reset"><a class="anchor" href="#reset"></a>Reset</h3>
<div class="paragraph">
<p>Upon reset, a hart’s privilege mode is set to M. The <code>mstatus</code> fields
MIE and MPRV are reset to 0. If little-endian memory accesses are
supported, the <code>mstatus</code>/<code>mstatush</code> field MBE is reset to 0. The <code>misa</code>
register is reset to enable the maximal set of supported extensions,
as described in <a href="#misa">Machine ISA (<code>misa</code>) Register</a>.  For
implementations with the "A" standard extension, there is no valid
load reservation. The <code>pc</code> is set to an implementation-defined reset
vector. The <code>mcause</code> register is set to a value indicating the cause of
the reset. Writable PMP registers’ A and L fields are set to 0, unless
the platform mandates a different reset value for some PMP registers’ A
and L fields. If the hypervisor extension is implemented, the
<code>hgatp</code>.MODE and <code>vsatp</code>.MODE fields are reset to 0. If the Smrnmi
extension is implemented, the <code>mnstatus</code>.NMIE field is reset to 0. No
 <strong>WARL</strong> field contains an illegal value. If the Zicfilp extension is
implemented, the <code>mseccfg</code>.MLPE field is reset to 0. All other hart
state is UNSPECIFIED.</p>
</div>
<div class="paragraph">
<p>The <code>mcause</code> values after reset have implementation-specific
interpretation, but the value 0 should be returned on implementations
that do not distinguish different reset conditions. Implementations that
distinguish different reset conditions should only use 0 to indicate the
most complete reset.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Some designs may have multiple causes of reset (e.g., power-on reset,
external hard reset, brownout detected, watchdog timer elapse,
sleep-mode wakeup), which machine-mode software and debuggers may wish
to distinguish.</p>
</div>
<div class="paragraph">
<p><code>mcause</code> reset values may alias <code>mcause</code> values following synchronous
exceptions. There should be no ambiguity in this overlap, since on reset
the <code>pc</code> is typically set to a different value than on other traps.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="nmi"><a class="anchor" href="#nmi"></a>Non-Maskable Interrupts</h3>
<div class="paragraph">
<p>Non-maskable interrupts (NMIs) are only used for hardware error
conditions, and cause an immediate jump to an implementation-defined NMI
vector running in M-mode regardless of the state of a hart’s interrupt
enable bits. The <code>mepc</code> register is written with the virtual address of
the instruction that was interrupted, and <code>mcause</code> is set to a value
indicating the source of the NMI. The NMI can thus overwrite state in an
active machine-mode interrupt handler.</p>
</div>
<div class="paragraph">
<p>The values written to <code>mcause</code> on an NMI are implementation-defined. The
high Interrupt bit of <code>mcause</code> should be set to indicate that this was
an interrupt. An Exception Code of 0 is reserved to mean "unknown
cause" and implementations that do not distinguish sources of NMIs via
the <code>mcause</code> register should return 0 in the Exception Code.</p>
</div>
<div class="paragraph">
<p>Unlike resets, NMIs do not reset processor state, enabling diagnosis,
reporting, and possible containment of the hardware error.</p>
</div>
</div>
<div class="sect2">
<h3 id="pma"><a class="anchor" href="#pma"></a>Physical Memory Attributes</h3>
<div class="paragraph">
<p>The physical memory map for a complete system includes various address
ranges, some corresponding to memory regions and some to memory-mapped
control registers, portions of which might not be accessible.  Some
memory regions might not support reads, writes, or execution; some might
not support subword or subblock accesses; some might not support atomic
operations; and some might not support cache coherence or might have
different memory models. Similarly, memory-mapped control registers vary
in their supported access widths, support for atomic operations, and
whether read and write accesses have associated side effects. In RISC-V
systems, these properties and capabilities of each region of the
machine&#8217;s physical address space are termed <em>physical memory attributes</em>
(PMAs). This section describes RISC-V PMA terminology and how RISC-V
systems implement and check PMAs.</p>
</div>
<div class="paragraph">
<p>PMAs are inherent properties of the underlying hardware and rarely
change during system operation. Unlike physical memory protection values
described in <a href="#pmp">Physical Memory Protection</a>, PMAs do not vary by execution
context. The PMAs of some memory regions are fixed at chip design
time—for example, for an on-chip ROM. Others are fixed at board design
time, depending, for example, on which other chips are connected to
off-chip buses. Off-chip buses might also support devices that could be
changed on every power cycle (cold pluggable) or dynamically while the
system is running (hot pluggable). Some devices might be configurable at
run time to support different uses that imply different PMAs—for
example, an on-chip scratchpad RAM might be cached privately by one core
in one end-application, or accessed as a shared non-cached memory in
another end-application.</p>
</div>
<div class="paragraph">
<p>Most systems will require that at least some PMAs are dynamically
checked in hardware later in the execution pipeline after the physical
address is known, as some operations will not be supported at all
physical memory addresses, and some operations require knowing the
current setting of a configurable PMA attribute. While many other
architectures specify some PMAs in the virtual memory page tables and
use the TLB to inform the pipeline of these properties, this approach
injects platform-specific information into a virtualized layer and can
cause system errors unless attributes are correctly initialized in each
page-table entry for each physical memory region. In addition, the
available page sizes might not be optimal for specifying attributes in
the physical memory space, leading to address-space fragmentation and
inefficient use of expensive TLB entries.</p>
</div>
<div class="paragraph">
<p>For RISC-V, we separate out specification and checking of PMAs into a
separate hardware structure, the <em>PMA checker</em>. In many cases, the
attributes are known at system design time for each physical address
region, and can be hardwired into the PMA checker. Where the attributes
are run-time configurable, platform-specific memory-mapped control
registers can be provided to specify these attributes at a granularity
appropriate to each region on the platform (e.g., for an on-chip SRAM
that can be flexibly divided between cacheable and uncacheable uses).
PMAs are checked for any access to physical memory, including accesses
that have undergone virtual to physical memory translation. To aid in
system debugging, we strongly recommend that, where possible, RISC-V
processors precisely trap physical memory accesses that fail PMA checks.
Precisely trapped PMA violations manifest as instruction, load, or store
access-fault exceptions, distinct from virtual-memory page-fault
exceptions. Precise PMA traps might not always be possible, for example,
when probing a legacy bus architecture that uses access failures as part
of the discovery mechanism. In this case, error responses from
peripheral devices will be reported as imprecise bus-error interrupts.</p>
</div>
<div class="paragraph">
<p>PMAs must also be readable by software to correctly access certain
devices or to correctly configure other hardware components that access
memory, such as DMA engines. As PMAs are tightly tied to a given
physical platform’s organization, many details are inherently
platform-specific, as is the means by which software can learn the PMA
values for a platform. Some devices, particularly legacy buses, do not
support discovery of PMAs and so will give error responses or time out
if an unsupported access is attempted. Typically, platform-specific
machine-mode code will extract PMAs and ultimately present this
information to higher-level less-privileged software using some standard
representation.</p>
</div>
<div class="paragraph">
<p>Where platforms support dynamic reconfiguration of PMAs, an interface
will be provided to set the attributes by passing requests to a
machine-mode driver that can correctly reconfigure the platform. For
example, switching cacheability attributes on some memory regions might
involve platform-specific operations, such as cache flushes, that are
available only to machine-mode.</p>
</div>
<div class="sect3">
<h4 id="_main_memory_versus_io_regions"><a class="anchor" href="#_main_memory_versus_io_regions"></a>Main Memory versus I/O Regions</h4>
<div class="paragraph">
<p>The most important characterization of a given memory address range is
whether it holds regular main memory or I/O devices.
Regular main memory is required to have a number of properties,
specified below, whereas I/O devices can have a much broader range of
attributes. Memory regions that do not fit into regular main memory, for
example, device scratchpad RAMs, are categorized as I/O regions.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
What previous versions of this specification termed <em>vacant</em> regions are
no longer a distinct category; they are now described as I/O regions that are
not accessible (i.e. lacking read, write, and execute permissions).
Main memory regions that are not accessible are also allowed.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_supported_access_type_pmas"><a class="anchor" href="#_supported_access_type_pmas"></a>Supported Access Type PMAs</h4>
<div class="paragraph">
<p>Access types specify which access widths, from 8-bit byte to long
multi-word burst, are supported, and also whether misaligned accesses
are supported for each access width.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Although software running on a RISC-V hart cannot directly generate
bursts to memory, software might have to program DMA engines to access
I/O devices and might therefore need to know which access sizes are
supported.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Main memory regions always support read and write of all access widths
required by the attached devices, and can specify whether instruction
fetch is supported.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Some platforms might mandate that all of main memory support instruction
fetch. Other platforms might prohibit instruction fetch from some main
memory regions.</p>
</div>
<hr>
<div class="paragraph">
<p>In some cases, the design of a processor or device accessing main memory
might support other widths, but must be able to function with the types
supported by the main memory.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>I/O regions can specify which combinations of read, write, or execute
accesses to which data widths are supported.</p>
</div>
<div class="paragraph">
<p>For systems with page-based virtual memory, I/O and memory regions can
specify which combinations of hardware page-table reads and hardware
page-table writes are supported.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Unix-like operating systems generally require that all of cacheable main
memory supports page-table walks.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_atomicity_pmas"><a class="anchor" href="#_atomicity_pmas"></a>Atomicity PMAs</h4>
<div class="paragraph">
<p>Atomicity PMAs describes which atomic instructions are supported in this
address region. Support for atomic instructions is divided into two
categories: <em>LR/SC</em> and <em>AMOs</em>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Some platforms might mandate that all of cacheable main memory support
all atomic operations required by the attached processors.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_amo_pma"><a class="anchor" href="#_amo_pma"></a>AMO PMA</h5>
<div class="paragraph">
<p>Within AMOs, there are four levels of support: <em>AMONone</em>, <em>AMOSwap</em>,
<em>AMOLogical</em>, and <em>AMOArithmetic</em>. AMONone indicates that no AMO
operations are supported. AMOSwap indicates that only <code>amoswap</code>
instructions are supported in this address range. AMOLogical indicates
that swap instructions plus all the logical AMOs (<code>amoand</code>, <code>amoor</code>,
<code>amoxor</code>) are supported. AMOArithmetic indicates that all RISC-V AMOs
are supported. For each level of support, naturally aligned AMOs of a
given width are supported if the underlying memory region supports reads
and writes of that width. Main memory and I/O regions may only support a
subset or none of the processor-supported atomic operations.</p>
</div>
<table class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 9. Classes of AMOs supported by I/O regions.</caption>
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">AMO Class</th>
<th class="tableblock halign-left valign-top">Supported Operations</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">AMONone<br>
AMOSwap<br>
AMOLogical<br>
AMOArithmetic</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>None</em><br>
<code>amoswap</code><br>
above + <code>amoand</code>, <code>amoor</code>, <code>amoxor</code><br>
above + <code>amoadd</code>, <code>amomin</code>, <code>amomax</code>, <code>amominu</code>,
<code>amomaxu</code></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>We recommend providing at least AMOLogical support for I/O regions where
possible.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_reservability_pma"><a class="anchor" href="#_reservability_pma"></a>Reservability PMA</h5>
<div class="paragraph">
<p>For <em>LR/SC</em>, there are three levels of support indicating combinations
of the reservability and eventuality properties: <em>RsrvNone</em>,
<em>RsrvNonEventual</em>, and <em>RsrvEventual</em>. RsrvNone indicates that no LR/SC
operations are supported (the location is non-reservable).
RsrvNonEventual indicates that the operations are supported (the
location is reservable), but without the eventual success guarantee
described in the unprivileged ISA specification. RsrvEventual indicates
that the operations are supported and provide the eventual success
guarantee.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>We recommend providing RsrvEventual support for main memory regions
where possible. Most I/O regions will not support LR/SC accesses, as
these are most conveniently built on top of a cache-coherence scheme,
but some may support RsrvNonEventual or RsrvEventual.</p>
</div>
<hr>
<div class="paragraph">
<p>When LR/SC is used for memory locations marked RsrvNonEventual, software
should provide alternative fall-back mechanisms used when lack of
progress is detected.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_misaligned_atomicity_granule_pma"><a class="anchor" href="#_misaligned_atomicity_granule_pma"></a>Misaligned Atomicity Granule PMA</h4>
<div class="paragraph">
<p>The misaligned atomicity granule PMA provides constrained support for
misaligned AMOs.
This PMA, if present, specifies the size of a <em>misaligned atomicity granule</em>,
a naturally aligned power-of-two number of bytes.
Specific supported values for this PMA are represented by MAG<em>NN</em>, e.g.,
MAG16 indicates the misaligned atomicity granule is at least 16 bytes.</p>
</div>
<div class="paragraph">
<p>The misaligned atomicity granule PMA applies only to AMOs, loads and stores
defined in the base ISAs, and loads and stores of no more than XLEN bits
defined in the F, D, and Q extensions.
For an instruction in that set, if all accessed bytes lie within the same
misaligned atomicity granule, the instruction will not raise an exception for
reasons of address alignment, and the instruction will give rise to only one
memory operation for the purposes of RVWMO&#8212;&#8203;i.e., it will execute atomically.</p>
</div>
<div class="paragraph">
<p>If a misaligned AMO accesses a region that does not specify a misaligned
atomicity granule PMA, or if not all accessed bytes lie within the same
misaligned atomicity granule, then an exception is raised.
For regular loads and stores that access such a region or for which not all
accessed bytes lie within the same atomicity granule, then either an exception
is raised, or the access proceeds but is not guaranteed to be atomic.
Implementations may raise access-fault exceptions instead of
address-misaligned exceptions for some misaligned accesses, indicating the
instruction should not be emulated by a trap handler.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
LR/SC instructions are unaffected by this PMA and so always raise an
exception when misaligned.  Vector memory accesses are also unaffected, so
might execute non-atomically even when contained within a misaligned atomicity
granule.  Implicit accesses are similarly unaffected by this PMA.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_memory_ordering_pmas"><a class="anchor" href="#_memory_ordering_pmas"></a>Memory-Ordering PMAs</h4>
<div class="paragraph">
<p>Regions of the address space are classified as either <em>main memory</em> or
<em>I/O</em> for the purposes of ordering by the FENCE instruction and
atomic-instruction ordering bits.</p>
</div>
<div class="paragraph">
<p>Accesses by one hart to main memory regions are observable not only by
other harts but also by other devices with the capability to initiate
requests in the main memory system (e.g., DMA engines). Coherent main
memory regions always have either the RVWMO or RVTSO memory model.
Incoherent main memory regions have an implementation-defined memory
model.</p>
</div>
<div class="paragraph">
<p>Accesses by one hart to an I/O region are observable not only by other
harts and bus mastering devices but also by the targeted I/O devices,
and I/O regions may be accessed with either <em>relaxed</em> or <em>strong</em>
ordering. Accesses to an I/O region with relaxed ordering are generally
observed by other harts and bus mastering devices in a manner similar to
the ordering of accesses to an RVWMO memory region, as discussed in
Section A.4.2 in Volume I of this specification. By contrast, accesses
to an I/O region with strong ordering are generally observed by other
harts and bus mastering devices in program order.</p>
</div>
<div class="paragraph">
<p>Each strongly ordered I/O region specifies a numbered ordering channel,
which is a mechanism by which ordering guarantees can be provided
between different I/O regions. Channel 0 is used to indicate
point-to-point strong ordering only, where only accesses by the hart to
the single associated I/O region are strongly ordered.</p>
</div>
<div class="paragraph">
<p>Channel 1 is used to provide global strong ordering across all I/O
regions. Any accesses by a hart to any I/O region associated with
channel 1 can only be observed to have occurred in program order by all
other harts and I/O devices, including relative to accesses made by that
hart to relaxed I/O regions or strongly ordered I/O regions with
different channel numbers. In other words, any access to a region in
channel 1 is equivalent to executing a <code>fence io,io</code> instruction before
and after the instruction.</p>
</div>
<div class="paragraph">
<p>Other larger channel numbers provide program ordering to accesses by
that hart across any regions with the same channel number.</p>
</div>
<div class="paragraph">
<p>Systems might support dynamic configuration of ordering properties on
each memory region.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Strong ordering can be used to improve compatibility with legacy device
driver code, or to enable increased performance compared to insertion of
explicit ordering instructions when the implementation is known to not
reorder accesses.</p>
</div>
<div class="paragraph">
<p>Local strong ordering (channel 0) is the default form of strong ordering
as it is often straightforward to provide if there is only a single
in-order communication path between the hart and the I/O device.</p>
</div>
<div class="paragraph">
<p>Generally, different strongly ordered I/O regions can share the same
ordering channel without additional ordering hardware if they share the
same interconnect path and the path does not reorder requests.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_coherence_and_cacheability_pmas"><a class="anchor" href="#_coherence_and_cacheability_pmas"></a>Coherence and Cacheability PMAs</h4>
<div class="paragraph">
<p>Coherence is a property defined for a single physical address, and
indicates that writes to that address by one agent will eventually be
made visible to other coherent agents in the system. Coherence is not to be
confused with the memory consistency model of a system, which defines
what values a memory read can return given the previous history of reads
and writes to the entire memory system. In RISC-V platforms, the use of
hardware-incoherent regions is discouraged due to software complexity,
performance, and energy impacts.</p>
</div>
<div class="paragraph">
<p>The cacheability of a memory region should not affect the software view
of the region except for differences reflected in other PMAs, such as
main memory versus I/O classification, memory ordering, supported
accesses and atomic operations, and coherence. For this reason, we treat
cacheability as a platform-level setting managed by machine-mode
software only.</p>
</div>
<div class="paragraph">
<p>Where a platform supports configurable cacheability settings for a
memory region, a platform-specific machine-mode routine will change the
settings and flush caches if necessary, so the system is only incoherent
during the transition between cacheability settings. This transitory
state should not be visible to lower privilege levels.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Coherence is straightforward to provide for a shared memory region that
is not cached by any agent. The PMA for such a region would simply
indicate it should not be cached in a private or shared cache.</p>
</div>
<div class="paragraph">
<p>Coherence is also straightforward for read-only regions, which can be
safely cached by multiple agents without requiring a cache-coherence
scheme. The PMA for this region would indicate that it can be cached,
but that writes are not supported.</p>
</div>
<div class="paragraph">
<p>Some read-write regions might only be accessed by a single agent, in
which case they can be cached privately by that agent without requiring
a coherence scheme. The PMA for such regions would indicate they can be
cached. The data can also be cached in a shared cache, as other agents
should not access the region.</p>
</div>
<div class="paragraph">
<p>If an agent can cache a read-write region that is accessible by other
agents, whether caching or non-caching, a cache-coherence scheme is
required to avoid use of stale values. In regions lacking hardware cache
coherence (hardware-incoherent regions), cache coherence can be
implemented entirely in software, but software coherence schemes are
notoriously difficult to implement correctly and often have severe
performance impacts due to the need for conservative software-directed
cache-flushing. Hardware cache-coherence schemes require more complex
hardware and can impact performance due to the cache-coherence probes,
but are otherwise invisible to software.</p>
</div>
<div class="paragraph">
<p>For each hardware cache-coherent region, the PMA would indicate that the
region is coherent and which hardware coherence controller to use if the
system has multiple coherence controllers. For some systems, the
coherence controller might be an outer-level shared cache, which might
itself access further outer-level cache-coherence controllers
hierarchically.</p>
</div>
<div class="paragraph">
<p>Most memory regions within a platform will be coherent to software,
because they will be fixed as either uncached, read-only, hardware
cache-coherent, or only accessed by one agent.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If a PMA indicates non-cacheability, then accesses to that region must
be satisfied by the memory itself, not by any caches.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>For implementations with a cacheability-control mechanism, the situation
may arise that a program uncacheably accesses a memory location that is
currently cache-resident. In this situation, the cached copy must be
ignored. This constraint is necessary to prevent more-privileged modes’
speculative cache refills from affecting the behavior of less-privileged
modes’ uncacheable accesses.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_idempotency_pmas"><a class="anchor" href="#_idempotency_pmas"></a>Idempotency PMAs</h4>
<div class="paragraph">
<p>Idempotency PMAs describe whether reads and writes to an address region
are idempotent. Main memory regions are assumed to be idempotent. For
I/O regions, idempotency on reads and writes can be specified separately
(e.g., reads are idempotent but writes are not). If accesses are
non-idempotent, i.e., there is potentially a side effect on any read or
write access, then speculative or redundant accesses must be avoided.</p>
</div>
<div class="paragraph">
<p>For the purposes of defining the idempotency PMAs, changes in observed
memory ordering created by redundant accesses are not considered a side
effect.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>While hardware should always be designed to avoid speculative or
redundant accesses to memory regions marked as non-idempotent, it is
also necessary to ensure software or compiler optimizations do not
generate spurious accesses to non-idempotent memory regions.</p>
</div>
<div class="paragraph">
<p>Non-idempotent regions might not support misaligned accesses. Misaligned
accesses to such regions should raise access-fault exceptions rather
than address-misaligned exceptions, indicating that software should not
emulate the misaligned access using multiple smaller accesses, which
could cause unexpected side effects.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For non-idempotent regions, implicit reads and writes must not be
performed early or speculatively, with the following exceptions. When a
non-speculative implicit read is performed, an implementation is
permitted to additionally read any of the bytes within a naturally
aligned power-of-2 region containing the address of the non-speculative
implicit read. Furthermore, when a non-speculative instruction fetch is
performed, an implementation is permitted to additionally read any of
the bytes within the <em>next</em> naturally aligned power-of-2 region of the
same size (with the address of the region taken modulo
2<sup>XLEN</sup>. The results of these additional reads
may be used to satisfy subsequent early or speculative implicit reads.
The size of these naturally aligned power-of-2 regions is
implementation-defined, but, for systems with page-based virtual memory,
must not exceed the smallest supported page size.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pmp"><a class="anchor" href="#pmp"></a>Physical Memory Protection</h3>
<div class="paragraph">
<p>To support secure processing and contain faults, it is desirable to
limit the physical addresses accessible by software running on a hart.
An optional physical memory protection (PMP) unit provides per-hart
machine-mode control registers to allow physical memory access
privileges (read, write, execute) to be specified for each physical
memory region. The PMP values are checked in parallel with the PMA
checks described in <a href="#pma">Physical Memory Attributes</a>.</p>
</div>
<div class="paragraph">
<p>The granularity of PMP access control settings are platform-specific,
but the standard PMP encoding supports regions as small as four bytes.
Certain regions’ privileges can be hardwired—for example, some regions
might only ever be visible in machine mode but in no lower-privilege
layers.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Platforms vary widely in demands for physical memory protection, and
some platforms may provide other PMP structures in addition to or
instead of the scheme described in this section.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>PMP checks are applied to all accesses whose effective privilege mode is
S or U, including instruction fetches and data accesses in S and U mode,
and data accesses in M-mode when the MPRV bit in <code>mstatus</code> is set and
the MPP field in <code>mstatus</code> contains S or U. PMP checks are also applied
to page-table accesses for virtual-address translation, for which the
effective privilege mode is S. Optionally, PMP checks may additionally
apply to M-mode accesses, in which case the PMP registers themselves are
locked, so that even M-mode software cannot change them until the hart
is reset. In effect, PMP can <em>grant</em> permissions to S and U modes, which
by default have none, and can <em>revoke</em> permissions from M-mode, which by
default has full permissions.</p>
</div>
<div class="paragraph">
<p>PMP violations are always trapped precisely at the processor.</p>
</div>
<div class="sect3">
<h4 id="_physical_memory_protection_csrs"><a class="anchor" href="#_physical_memory_protection_csrs"></a>Physical Memory Protection CSRs</h4>
<div class="paragraph">
<p>PMP entries are described by an 8-bit configuration register and one
MXLEN-bit address register. Some PMP settings additionally use the
address register associated with the preceding PMP entry. Up to 64 PMP
entries are supported. Implementations may implement zero, 16, or 64 PMP
entries; the lowest-numbered PMP entries must be implemented first. All
PMP CSR fields are <strong>WARL</strong> and may be read-only zero. PMP CSRs are only
accessible to M-mode.</p>
</div>
<div class="paragraph">
<p>The PMP configuration registers are densely packed into CSRs to minimize
context-switch time. For RV32, sixteen CSRs, <code>pmpcfg0</code>–<code>pmpcfg15</code>, hold
the configurations <code>pmp0cfg</code>–<code>pmp63cfg</code> for the 64 PMP entries, as shown
in <a href="#pmpcfg-rv32">RV32 PMP configuration CSR layout.</a>. For RV64, eight
even-numbered CSRs, <code>pmpcfg0</code>, <code>pmpcfg2</code>, …, <code>pmpcfg14</code>, hold the
configurations for the 64 PMP entries, as shown in
<a href="#pmpcfg-rv64">RV64 PMP configuration CSR layout.</a>. For RV64, the odd-numbered
configuration registers, <code>pmpcfg1</code>, <code>pmpcfg3</code>, …, <code>pmpcfg15</code>, are
illegal.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>RV64 harts use <code>pmpcfg2</code>, rather than <code>pmpcfg1</code>, to hold
configurations for PMP entries 8-15. This design reduces the cost of
supporting multiple MXLEN values, since the configurations for PMP
entries 8-11 appear in <code>pmpcfg2</code>[31:0] for both RV32 and RV64.</p>
</div>
</td>
</tr>
</table>
</div>
<div id="pmpcfg-rv32" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNrtVUtugzAQ3fcUI68SVZYwEAdxgOx6gqoLAzag8pOxlFQRJ-hdeqiepLOAFqRiUjaVIlaW3pvxe-D57BKphDG6hbApRF7Bc39eQ1VXhipR5sUbkKdHYA2cRFFEIn4l3cv-YYepoOszzaRIpKaqgiovejyqL7KlDcIYAa7Tw4VUhpZCp6jgOgOq8zSbwohrcaZ4CxCPEXTTNgI5CI28GCqqOKs1kNYIbQiEUa3RQQvXrtuPU11_NlVWiS3RW63J-EpNdlitGayUPK5WdNYpYoEMef4timPJpmy8WKXfwv7UEdKunWZ22rHTyP58tG_xGcxG_VvQ9LfPOt86beu0vtqP9mbgdvpgp_3FTmP33WmjKNe55a5g3tXn-weBIY79sbpsRrbJsE2GXyYDX1jCfGEL84U1zJf38OiV7mY8fAExoMLy?id=pmpcfg-rv32" alt="RV32 PMP configuration CSR layout.">
</div>
<div class="title">Figure 29. RV32 PMP configuration CSR layout.</div>
</div>
<div id="pmpcfg-rv64" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNrtl0FOwzAQRfecYpRVK2QpdmyT9gDsOAFi4bZOG5EmkWOphaon4C4cipNgoC0FUU_wqqq8ijTfM380Gvspg5kulLWmg3FbqbKG-913My6a2pJCLcvqCZK7a6At3KqqmqjpYwJfalc-a2Bs-zC8GrhCYJoVWWg104YUNdRltYtPmrXuSOvC7gTwdBeudGHJUpm582PpPmrK-eKv8GftDw2Ei7mgUSviKkMis8T127XKnYex1WtLVD1dNAaSzipjXbuTxriuOthst8PjVCFPpup65ksUwZ48D_TkN-GeaaBnNgr2zFioJw32ZDzQk4XvEA3dIRq-Q6ErFL5BgQvkHoF9Xt7H8diyXbY302J-MOY_O3Ky9MvCL3O_nPll5pepX079slO_B877TJd7Bpn3KBUP_drVk9OMuIm4ibi5SNxQhBgUQQZFmEExaCDUoAg2Rn45R6HDInTOEjrHM0_71KLydFtvL68JHK4X_9_N9HUSKRkpGSl58ZSUCOUkQjmJUE4ilBMI5gTCOYH8VQqJcpLyCMqzAeU7edrAUg==?id=pmpcfg-rv64" alt="RV64 PMP configuration CSR layout.">
</div>
<div class="title">Figure 30. RV64 PMP configuration CSR layout.</div>
</div>
<div class="paragraph">
<p>The PMP address registers are CSRs named <code>pmpaddr0</code>-<code>pmpaddr63</code>. Each
PMP address register encodes bits 33-2 of a 34-bit physical address for
RV32, as shown in <a href="#pmpaddr-rv32">PMP address register format, RV32.</a>. For RV64,
each PMP address register encodes bits 55-2 of a 56-bit physical
address, as shown in <a href="#pmpaddr-rv64">PMP address register format, RV64.</a>. Not all
physical address bits may be implemented, and so the <code>pmpaddr</code> registers
are <strong>WARL</strong>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The Sv32 page-based virtual-memory scheme described in
<a href="#sv32">[sv32]</a> supports 34-bit physical addresses for
RV32, so the PMP scheme must support addresses wider than XLEN for RV32.
The Sv39 and Sv48 page-based virtual-memory schemes described in
<a href="#sv39">[sv39]</a> and <a href="#sv48">[sv48]</a> support a
56-bit physical address space, so the RV64 PMP address registers impose
the same limit.</p>
</div>
</td>
</tr>
</table>
</div>
<div id="pmpaddr-rv32" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNq1kT1PwzAQhvf-ipOnRMhS6lQM2ViYYGFhiDpc6ksb1bEj-0oKKP8dp02hVcuChGTJutf38dzrRFONzD5A0RlsLJTT_VnUzrKssW3MO4jnO5h38IjGVLjaCji-huaDQC2GZTpLYiPwrpcbatYbhkUGFyJq8rK2YBsz6YZqli36dZymsuyUPVZfy5XbU5Bd7BHbQa5G2WMvV87sWjv1D5F6Gq8Wl4hQGKzIBEg8vcVMglJkAsT_nXwulumQzibQuAAI1NpTCGWeF2opIm3o0ML8HgqmPUu0q43zIMjq6HDl_LQTu-4Uyp31ZJBJjwqza2-9jNZe68OQnsEk40gQyevDy1MqTv_9bdch6o9misoZLYb0V-DA6PkH-Q_Eh2-_jXxuYK6uSQ9IuTozLFZ9ASzn4PA=?id=pmpaddr-rv32" alt="PMP address register format, RV32.">
</div>
<div class="title">Figure 31. PMP address register format, RV32.</div>
</div>
<div id="pmpaddr-rv64" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNrVkjFvgzAQhff8ipMnUGUJSKgqti6d2qVLhyjDEY4E1djIdpq0iP9eOyEoCak6RB0qIdl-9t37_ExQUInWagNZI7CSMO_HNiuVtLzEuhKfwF7uIG7gCYXIcfnO4LBrqi-CZNYtwkngGoFWW76marW2kEZwJmJBmpcSZCV6XVBpeY165dySKDqe9tVjOVc7MrxxPVw7mCZe1rjlSyU2tez7G0fd2yezc0TIBOYkDASaPtxJgjmLGLDbv3R6KcyG6f2ULcIunPSw7hLgXdvMNCjBQVnaWY5yuVYaGMnCBZsr7a_SZlY1xxXfSE0CLRVesVbV13Z8oGO968IT-8A7AgveHl-fQ3Z85SGk_Wp7iJDlShSsC3_CNRa1vQl4_9a_ETMsCk3GzNM0SxZDeHHyv9Ib8f5pfKf5xdGYdI_0MJhDe5G5_4ev1vjJadE3LZ9dSg==?id=pmpaddr-rv64" alt="PMP address register format, RV64.">
</div>
<div class="title">Figure 32. PMP address register format, RV64.</div>
</div>
<div class="paragraph">
<p><a href="#pmpcfg">PMP configuration register format.</a> shows the layout of a PMP configuration
register. The R, W, and X bits, when set, indicate that the PMP entry
permits read, write, and instruction execution, respectively. When one
of these bits is clear, the corresponding access type is denied. The R,
W, and X fields form a collective <strong>WARL</strong> field for which the combinations with R=0 and W=1 are reserved. The remaining two fields, A and L, are described in the following sections.</p>
</div>
<div id="pmpcfg" class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/bytefield/svg/eNqtkD9rwzAUxPd8ioemmCLwv7jgrUundsmSQunwHEuxiCIZ6UHSBn_3qjRtYopKmmYy3P3uTn7TVkgkch7qXqMy8Hz47mtpDXGJG6VfgT3eQNbDPWrd4HLN4NP16k1AXg4vyWQaisDZLe-EWnUEZQojEVvhuDRglD7oWkjiG3SrsJal6Rf9kf4pN3YnPO9DR6iDIk8mQXe45cEAdsvCe32PBmZQN9aFLQ_7YUhOoeobKqAmsSOOZtlZB8wTOmLx5CyaFKb9JVdevFhcuJifc4jsHCiNQqfUw5GKxauxcRcznmJVi5gxHxl__sPjrap_QtnVrh6F3gGPkyno?id=pmpcfg" alt="PMP configuration register format.">
</div>
<div class="title">Figure 33. PMP configuration register format.</div>
</div>
<div class="paragraph">
<p>Attempting to fetch an instruction from a PMP region that does not have
execute permissions raises an instruction access-fault exception.
Attempting to execute a load or load-reserved instruction which accesses
a physical address within a PMP region without read permissions raises a
load access-fault exception. Attempting to execute a store,
store-conditional, or AMO instruction which accesses a physical address
within a PMP region without write permissions raises a store
access-fault exception.</p>
</div>
<div class="sect4">
<h5 id="_address_matching"><a class="anchor" href="#_address_matching"></a>Address Matching</h5>
<div class="paragraph">
<p>The A field in a PMP entry&#8217;s configuration register encodes the
address-matching mode of the associated PMP address register. The
encoding of this field is shown in <a href="#pmpcfg-a">Encoding of A field in PMP configuration registers.</a>.
When A=0, this PMP entry is disabled and matches no addresses. Two other
address-matching modes are supported: naturally aligned power-of-2
regions (NAPOT), including the special case of naturally aligned
four-byte regions (NA4); and the top boundary of an arbitrary range
(TOR). These modes support four-byte granularity.</p>
</div>
<table id="pmpcfg-a" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 10. Encoding of A field in PMP configuration registers.</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-right valign-top">A</th>
<th class="tableblock halign-center valign-top">Name</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">0<br>
1<br>
2<br>
3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">OFF<br>
TOR<br>
NA4<br>
NAPOT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Null region (disabled)<br>
Top of range<br>
Naturally aligned four-byte region<br>
Naturally aligned power-of-two region, &#8805;8
bytes</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>NAPOT ranges make use of the low-order bits of the associated address
register to encode the size of the range, as shown in
<a href="#pmpcfg-napot"><code>NAPOT</code> range encoding in PMP address and configuration registers.</a>.</p>
</div>
<table id="pmpcfg-napot" class="tableblock frame-all grid-all fit-content center">
<caption class="title">Table 11. <code>NAPOT</code> range encoding in PMP address and configuration registers.</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top"><code>pmpaddr</code></th>
<th class="tableblock halign-center valign-top"><code>pmpcfg</code>.A</th>
<th class="tableblock halign-left valign-top">Match type and size</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>yyyy&#8230;&#8203;yyyy</code><br>
<code>yyyy&#8230;&#8203;yyy0</code><br>
<code>yyyy&#8230;&#8203;yy01</code><br>
<code>yyyy&#8230;&#8203;y011</code><br>
&#8230;&#8203;<br>
<code>yy01&#8230;&#8203;1111</code><br>
<code>y011&#8230;&#8203;1111</code><br>
<code>0111&#8230;&#8203;1111</code><br>
<code>1111&#8230;&#8203;1111</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">NA4<br>
NAPOT<br>
NAPOT<br>
NAPOT<br>
&#8230;&#8203;<br>
NAPOT<br>
NAPOT<br>
NAPOT<br>
NAPOT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4-byte NAPOT range<br>
8-byte NAPOT range<br>
16-byte NAPOT range<br>
32-byte NAPOT range<br>
…<br>
2<sup>XLEN</sup>-byte NAPOT range<br>
2<sup>XLEN+1</sup>-byte NAPOT range<br>
2<sup>XLEN+2</sup>-byte NAPOT range<br>
2<sup>XLEN+3</sup>-byte NAPOT range</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>If TOR is selected, the associated address register forms the top of the
address range, and the preceding PMP address register forms the bottom
of the address range. If PMP entry <em>i</em>'s A field is set to
TOR, the entry matches any address <em>y</em> such that <code>pmpaddr<sub>i-1</sub></code>&#8804;<em>y</em>&lt;<code>pmpaddr<sub>i</sub></code> (irrespective of the value of <code>pmpcfg<sub>i-1</sub></code>). If PMP entry 0&#8217;s A field is set to TOR, zero is used for the lower bound, and so it matches
any address <code>y&lt;pmpaddr<sub>0</sub></code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If  <code>pmpaddr<sub>i-1</sub>&#8805;<code>pmpaddr<sub>i</sub></code></code> and <code>pmpcfg<sub>i</sub>.A</code>=TOR, then PMP entry <em>i</em> matches no addresses.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Although the PMP mechanism supports regions as small as four bytes,
platforms may specify coarser PMP regions. In general, the PMP grain is
\(2^{G+2}\) bytes and must be the same across all PMP regions.
When \(G \geq 1\), the NA4 mode is not selectable. When
\(G \geq 2\) and \({\tt pmpcfg}_i\).A[1] is set,
i.e. the mode is NAPOT, then bits \({\tt pmpaddr}_i\)[G-2:0]
read as all ones. When \(G \geq 1\) and
\({\tt pmpcfg}_i\).A[1] is clear, i.e. the mode is OFF or TOR,
then bits \({\tt pmpaddr}_i\)[G-1:0] read as all zeros. Bits
\({\tt
pmpaddr}_i\)[G-1:0] do not affect the TOR address-matching logic.
Although changing \({\tt pmpcfg}_i\).A[1] affects the value
read from \({\tt pmpaddr}_i\), it does not affect the
underlying value stored in that register—in particular,
\({\tt pmpaddr}_i\)[G-1] retains its original value when
\({\tt pmpcfg}_i\).A is changed from NAPOT to TOR/OFF then
back to NAPOT.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Software may determine the PMP granularity by writing zero to <code>pmp0cfg</code>, then writing all ones to <code>pmpaddr0</code>, then reading back <code>pmpaddr0</code>. If <em>G</em> is the index of the least-significant bit set, the PMP granularity is 2<sup>G+2</sup> bytes.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the current XLEN is greater than MXLEN, the PMP address registers are
zero-extended from MXLEN to XLEN bits for the purposes of address
matching.</p>
</div>
</div>
<div class="sect4">
<h5 id="_locking_and_privilege_mode"><a class="anchor" href="#_locking_and_privilege_mode"></a>Locking and Privilege Mode</h5>
<div class="paragraph">
<p>The L bit indicates that the PMP entry is locked, i.e., writes to the
configuration register and associated address registers are ignored.
Locked PMP entries remain locked until the hart is reset. If PMP entry
<em>i</em> is locked, writes to <code>pmp</code><em>i</em><code>cfg</code> and <code>pmpaddr</code><em>i</em> are ignored. Additionally, if PMP
entry <em>i</em> is locked and <code>pmp</code><em>i</em><code>cfg.A</code> is set
to TOR, writes to <code>pmpaddr</code><em>i</em>-1 are ignored.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Setting the L bit locks the PMP entry even when the A field is set to
OFF.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In addition to locking the PMP entry, the L bit indicates whether the
R/W/X permissions are enforced on M-mode accesses. When the L bit is
set, these permissions are enforced for all privilege modes. When the L
bit is clear, any M-mode access matching the PMP entry will succeed; the
R/W/X permissions apply only to S and U modes.</p>
</div>
</div>
<div class="sect4">
<h5 id="_priority_and_matching_logic"><a class="anchor" href="#_priority_and_matching_logic"></a>Priority and Matching Logic</h5>
<div class="paragraph">
<p>PMP entries are statically prioritized. The lowest-numbered PMP entry
that matches any byte of an access determines whether that access
succeeds or fails. The matching PMP entry must match all bytes of an
access, or the access fails, irrespective of the L, R, W, and X bits.
For example, if a PMP entry is configured to match the four-byte range
<code>0xC</code>–<code>0xF</code>, then an 8-byte access to the range <code>0x8</code>–<code>0xF</code> will fail,
assuming that PMP entry is the highest-priority entry that matches those
addresses.</p>
</div>
<div class="paragraph">
<p>If a PMP entry matches all bytes of an access, then the L, R, W, and X
bits determine whether the access succeeds or fails. If the L bit is
clear and the privilege mode of the access is M, the access succeeds.
Otherwise, if the L bit is set or the privilege mode of the access is S
or U, then the access succeeds only if the R, W, or X bit corresponding
to the access type is set.</p>
</div>
<div class="paragraph">
<p>If no PMP entry matches an M-mode access, the access succeeds. If no PMP
entry matches an S-mode or U-mode access, but at least one PMP entry is
implemented, the access fails.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If at least one PMP entry is implemented, but all PMP entries’ A fields
are set to OFF, then all S-mode and U-mode memory accesses will fail.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Failed accesses generate an instruction, load, or store access-fault
exception. Note that a single instruction may generate multiple
accesses, which may not be mutually atomic. An access-fault exception is
generated if at least one access generated by an instruction fails,
though other accesses generated by that instruction may succeed with
visible side effects. Notably, instructions that reference virtual
memory are decomposed into multiple accesses.</p>
</div>
<div class="paragraph">
<p>On some implementations, misaligned loads, stores, and instruction
fetches may also be decomposed into multiple accesses, some of which may
succeed before an access-fault exception occurs. In particular, a
portion of a misaligned store that passes the PMP check may become
visible, even if another portion fails the PMP check. The same behavior
may manifest for stores wider than XLEN bits (e.g., the FSD instruction
in RV32D), even when the store address is naturally aligned.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pmp-vmem"><a class="anchor" href="#pmp-vmem"></a>Physical Memory Protection and Paging</h4>
<div class="paragraph">
<p>The Physical Memory Protection mechanism is designed to compose with the
page-based virtual memory systems described in
<a href="#supervisor">[supervisor]</a>. When paging is enabled,
instructions that access virtual memory may result in multiple
physical-memory accesses, including implicit references to the page
tables. The PMP checks apply to all of these accesses. The effective
privilege mode for implicit page-table accesses is S.</p>
</div>
<div class="paragraph">
<p>Implementations with virtual memory are permitted to perform address
translations speculatively and earlier than required by an explicit
memory access, and are permitted to cache them in address translation
cache structures—including possibly caching the identity mappings from
effective address to physical address used in Bare translation modes and
M-mode. The PMP settings for the resulting physical address may be
checked (and possibly cached) at any point between the address
translation and the explicit memory access. Hence, when the PMP settings
are modified, M-mode software must synchronize the PMP settings with the
virtual memory system and any PMP or address-translation caches. This is
accomplished by executing an SFENCE.VMA instruction with <em>rs1</em>=<code>x0</code> and
<em>rs2</em>=<code>x0</code>, after the PMP CSRs are written.
See <a href="#hyp-mm-fences">[hyp-mm-fences]</a> for additional synchronization requirements when the
hypervisor extension is implemented.</p>
</div>
<div class="paragraph">
<p>If page-based virtual memory is not implemented, memory accesses check
the PMP settings synchronously, so no SFENCE.VMA is needed.</p>
</div>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="hidden">
</footer><script id="site-script" src="../../../_/js/site.js" data-ui-root-path="../../../_"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
<script src="../../../_/js/vendor/lunr.js"></script>
<script src="../../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../../.." data-snippet-length="100" data-stylesheet="../../../_/css/search.css"></script>
<script async src="../../../search-index.js"></script>
  </body>
</html>
