<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Untitled :: RISC-V Ratified Specifications Library</title>
    <link rel="prev" href="IMSIC.html">
    <link rel="next" href="MSLevel.html">
    <meta name="generator" content="Antora 3.1.12">
    <script>
!function (theme, navWidth) {
  if (theme === 'dark') document.documentElement.classList.add('dark-theme')
  if (navWidth) document.documentElement.style.setProperty('--nav-width', `${navWidth}px`)
}(localStorage && localStorage.getItem('theme') || (matchMedia('(prefers-color-scheme: dark)')?.matches && 'dark'),
  localStorage && localStorage.getItem('nav-width'))
    </script>
    <link rel="stylesheet" href="../../_/css/site.css">
    <link rel="stylesheet" href="../../_/css/vendor/search.css">
    <link rel="stylesheet" href="../../_/css/vendor/page-search.css">
    <link rel="stylesheet" href="../../_/css/vendor/spring-tabs.css">

    <meta name="antora-ui-version" content="24b0ea9bb868390e1ef3290e476fd66788c083d5"> 
    <meta name="version" content="v1.0">
    <meta name="component" content="aia">
    <meta name="latest-version" content="false">
    <link rel="icon" href="../../_/img/favicon.ico" type="image/vnd.microsoft.icon">
  </head>
  <body class="article">
<header class="header">
  <script>
    console.log("--- Antora Objects ---");
    // window.addEventListener('popstate', function(event) {
    //   console.log('URL changed to: ' + document.location.pathname);
    // });
    var locationObject = window.location;
    var pathnameToChange = locationObject.pathname;
    console.log(pathnameToChange)
    console.log(locationObject)

    // window.location.assign("test")

    // do stuffs to "copy" of pathname, this will not reload the page
    // var myNewPathname = doSomethingMyPathname( pathnameToChange );

  </script>

  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../..">RISC-V Ratified Specifications Library</a>
      <button class="navbar-burger" aria-controls="topbar-nav" aria-expanded="false" aria-label="Toggle main menu">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="aia" data-version="v1.0">
  <aside class="nav">
    <div class="panels">
      <div class="nav-panel-menu is-active" data-panel="menu">
        <nav class="nav-menu">
<div class="context">
  <span class="title">Advanced Interrupt Architecture</span>
  <span class="version">v1.0</span>
  <button class="browse-version" id="browse-version">
    <svg
      height="24px"
      id="Layer_1"
      style="enable-background:new 0 0 512 512;"
      version="1.1"
      viewBox="0 0 512 512"
      width="24px"
      xml:space="preserve"
    ><g><path
          d="M256,224c-17.7,0-32,14.3-32,32s14.3,32,32,32c17.7,0,32-14.3,32-32S273.7,224,256,224L256,224z"
        ></path><path
          d="M128.4,224c-17.7,0-32,14.3-32,32s14.3,32,32,32c17.7,0,32-14.3,32-32S146,224,128.4,224L128.4,224z"
        ></path><path
          d="M384,224c-17.7,0-32,14.3-32,32s14.3,32,32,32s32-14.3,32-32S401.7,224,384,224L384,224z"
        ></path></g></svg>
  </button>
  </div><ul class="nav-list">
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">RISC-V Advanced Interrupt Architecture</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="intro.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="CSRs.html">Control and Status Registers (CSRs) Added to Harts</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="IMSIC.html">Incoming MSI Controller (IMSIC)</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link"  href="AdvPLIC.html">Advanced Platform-Level Interrupt Controller (APLIC)</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="MSLevel.html">Interrupts for Machine and Supervisor Levels</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="VSLevel.html">Interrupts for Virtual Machines (VS Level)</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="IPIs.html">Interprocessor Interrupts (IPIs)</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link"  href="IOMMU.html">IOMMU Support for MSIs to Virtual Machines</a>
  </li>
</ul>
  </li>
</ul>
          <div class="toggle-sm">
            <button id="nav-toggle-2" class="nav-toggle"></button>
          </div>
        </nav>
      </div>
      <div class="nav-collapse">
        <button id="nav-collapse-toggle"><span></span></button>        
      </div>
    </div>
    <div class="nav-resize"></div>
  </aside>
</div>
<script>
!function (sidebar) {
  if (sidebar) {
    document.body.classList.add('nav-sm')
  }
}(localStorage && localStorage.getItem('sidebar') === 'close')
</script><main class="article">
<div class="toolbar" role="navigation">
  <button id="nav-toggle-1" class="nav-toggle"></button>
</div>
  <div class="content">
<aside class="sidebar">
  <div class="content">
    <div
      class="toc"
      data-title=""
      data-levels="2"
    >
      <div class="toc-menu"></div>
    </div>
    <div class="sidebar-links">
        <a href="https://github.com/riscv/riscv-aia/edit/antora-refactor/modules/ROOT/pages/AdvPLIC.adoc">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            height="24"
            viewBox="0 0 24 24"
            width="24"
          ><path
              d="m16 2.012 3 3L16.713 7.3l-3-3zM4 14v3h3l8.299-8.287-3-3zm0 6h16v2H4z"
            ></path></svg>
          Edit this Page
        </a>
              <a href="https://github.com/riscv/riscv-aia" title="GitHub">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            height="512px"
            id="Layer_1"
            version="1.1"
            viewBox="0 0 512 512"
            width="512px"
          ><style type="text/css"><![CDATA[
              .st0{fill-rule:evenodd;clip-rule:evenodd;} ]]></style><g><path
                class="st0"
                d="M256,32C132.3,32,32,134.8,32,261.7c0,101.5,64.2,187.5,153.2,217.9c11.2,2.1,15.3-5,15.3-11.1   c0-5.5-0.2-19.9-0.3-39.1c-62.3,13.9-75.5-30.8-75.5-30.8c-10.2-26.5-24.9-33.6-24.9-33.6c-20.3-14.3,1.5-14,1.5-14   c22.5,1.6,34.3,23.7,34.3,23.7c20,35.1,52.4,25,65.2,19.1c2-14.8,7.8-25,14.2-30.7c-49.7-5.8-102-25.5-102-113.5   c0-25.1,8.7-45.6,23-61.6c-2.3-5.8-10-29.2,2.2-60.8c0,0,18.8-6.2,61.6,23.5c17.9-5.1,37-7.6,56.1-7.7c19,0.1,38.2,2.6,56.1,7.7   c42.8-29.7,61.5-23.5,61.5-23.5c12.2,31.6,4.5,55,2.2,60.8c14.3,16.1,23,36.6,23,61.6c0,88.2-52.4,107.6-102.3,113.3   c8,7.1,15.2,21.1,15.2,42.5c0,30.7-0.3,55.5-0.3,63c0,6.1,4,13.3,15.4,11C415.9,449.1,480,363.1,480,261.7   C480,134.8,379.7,32,256,32z"
              ></path></g></svg>
          GitHub Project
        </a>
    </div>
  </div>
</aside>
<article class="doc">
<div class="breadcrumbs-container">
  <nav class="breadcrumbs" aria-label="breadcrumbs">
    <ul>
      <li><a href="index.html">Advanced Interrupt Architecture</a></li>
      <li>RISC-V Advanced Interrupt Architecture</li>
      <li><a href="AdvPLIC.html">Advanced Platform-Level Interrupt Controller (APLIC)</a></li>
    </ul>
  </nav>
</div><div class="sect1">
<h2 id="AdvPLIC"><a class="anchor" href="#AdvPLIC"></a>Advanced Platform-Level Interrupt Controller (APLIC)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In a RISC-V system, a Platform-Level Interrupt Controller (PLIC) handles
external interrupts that are signaled through wires rather than by MSIs.
When the RISC-V harts in a system do not have IMSICs, the harts themselves do
not support MSIs, and all external interrupts to such harts must pass
through a PLIC. But even in machines where harts have IMSICs and most
interrupts are communicated via MSIs, it is not unusual for some device
interrupts still to be signaled by dedicated wires. In particular, for
devices (or device controllers) that do not otherwise need to initiate
bus transactions in the system, the cost of supporting MSIs is
especially high, so wired interrupts are a frugal alternative. Wired
interrupts also continue to be universally supported by all current
computer platforms, unlike MSIs, making another reason for many
commodity devices or controllers to choose wired interrupts over MSIs,
unless conforming to a standard like PCI Express that dictates MSIs.</p>
</div>
<div class="paragraph">
<p>This chapter specifies an <em>Advanced PLIC</em> (APLIC) that is not backward
compatible with the earlier RISC-V PLIC. Full conformance to the Advanced
Interrupt Architecture requires the APLIC. However, a workable system
can be built substituting the older PLIC instead, assuming only wired
interrupts to harts, not MSIs.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>We intend eventually to provide a free example parameterized
implementation of an APLIC, written in portable SystemVerilog, that we
expect will be suitable for many RISC-V systems without modification.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A draft specification exists for a <em>Duo-PLIC</em> that is
software-configurable to act as either an original RISC-V PLIC or an APLIC.
However, at this time, it appears unlikely that RISC-V International will ever ratify the Duo-PLIC specification as a standard.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In a machine without IMSICs, every RISC-V hart accepts interrupts from exactly one PLIC or APLIC that is the <em>external interrupt controller</em> for that
hart. A hart’s external interrupt controller (the PLIC or APLIC) signals
interrupts to the hart through a dedicated connection, usually a wire,
for each privilege level that the hart may receive interrupts. (Recall
<a href="#intrsWithoutIMSICs">[intrsWithoutIMSICs]</a>). A
system without IMSICs will typically have only one PLIC or APLIC,
serving as the external interrupt controller for all RISC-V harts.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Because every RISC-V hart without an IMSIC has exactly one PLIC or APLIC as its
external interrupt controller, a system with multiple APLICs must
partition the harts into disjoint subsets, making each APLIC the
external interrupt controller for a separate subset of the harts. While
not prohibited, this arrangement is likely to be less efficient than
having all harts share a single APLIC.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>RISC-V harts that employ IMSICs as their external interrupt controllers can
receive external interrupts only in the form of MSIs. In that case, the
role of an APLIC is to convert wired interrupts into MSIs for harts.
(Recall <a href="#intrsWithIMSICs">[intrsWithIMSICs]</a>.)
The APLIC is said to <em>forward</em> incoming wire-signaled interrupts to
harts by sending MSIs to the harts.</p>
</div>
<div class="paragraph">
<p>When harts have IMSICs to support MSIs, a system may easily contain
multiple APLICs for converting wired interrupts into MSIs, with each
APLIC forwarding interrupts from a different subset of devices. Multiple
APLICs are presumably more likely to arise when groups of devices are
physically distant from one another, perhaps even on separate chips
(including chiplets in a multi-chip module).</p>
</div>
<div class="sect2">
<h3 id="interrupt-sources-and-identities"><a class="anchor" href="#interrupt-sources-and-identities"></a>Interrupt sources and identities</h3>
<div class="paragraph">
<p>An individual APLIC supports a fixed number of <em>interrupt sources</em>,
corresponding exactly with the set of physical incoming interrupt wires
at the APLIC. Most often, each source’s incoming wire is connected to
the output interrupt wire from a single device or device controller.
(For level-sensitive interrupts, the interrupt outputs of multiple
devices or controllers may be combined to drive the incoming wire of a
single interrupt source at an APLIC. An interrupt source’s incoming wire
might also be simply tied high or low, if, for example, the source will
always be configured as Detached. See
<a href="#AdvPLIC-reg-sourcecfg">Source configurations (<code>sourcecfg[1]–sourcecfg[1023]</code>)</a> for a description of <em>source
modes</em>.)</p>
</div>
<div class="paragraph">
<p>Each of an APLIC&#8217;s interrupt sources has a fixed unique <em>identity
number</em> in the range 1 to \(N\), where \(N\) is the
total number of sources at the APLIC. The number zero is not a valid
interrupt identity number at an APLIC. The maximum number of interrupt
sources an APLIC may support is 1023.</p>
</div>
<div class="paragraph">
<p>When an APLIC delivers interrupts directly to harts at a given privilege
level (rather than forwarding interrupts as MSIs), the APLIC is the
external interrupt controller for the harts at that privilege level, and
the interrupt identities at the APLIC become directly the <em>minor
identities</em> for external interrupts at the harts.</p>
</div>
<div class="paragraph">
<p>On the other hand, when an APLIC forwards interrupts by MSIs, software
configures a new interrupt identity number for the outgoing MSIs of each
source. Consequently, in this case, the source identity numbers at a
given APLIC only distinguish the incoming interrupts at the APLIC and
have no relevance outside the APLIC.</p>
</div>
</div>
<div class="sect2">
<h3 id="interrupt-domains"><a class="anchor" href="#interrupt-domains"></a>Interrupt domains</h3>
<div class="paragraph">
<p>An APLIC supports one or more <em>interrupt domains</em>, each associated with
a subset of RISC-V harts at one privilege level (machine or supervisor level).
The harts within an interrupt domain are those that the domain can
interrupt at the corresponding privilege level. Each domain has its own
memory-mapped control region in the machine’s address space that appears
to control a complete, separate APLIC, though in fact all domain
interfaces together access a single combined interrupt controller.</p>
</div>
<div class="paragraph">
<p><a href="#AdvPLIC-ex-1Domain">Example of a RISC-V system that has a single hart implementing only M-mode, with a single machine-level interrupt domain for that hart.</a> through
<a href="#AdvPLIC-ex-3Domains">A RISC-V system that extends the example of An example system with four harts that implement M-mode and S-mode, with two APLIC interrupt domains, one each for machine and supervisor levels. with a fifth M-mode-only "manager" hart, with a separate machine-level interrupt domain above the other domains.</a> depict some possible hierarchies of
interrupt domains implemented by an APLIC in a RISC-V system.</p>
</div>
<div class="paragraph">
<p>The first figure represents a minimal system that has a single hart not
supporting supervisor mode, with a single interrupt domain for machine
level on that hart. The next figure, <a href="#AdvPLIC-ex-2Domains">An example system with four harts that implement M-mode and S-mode, with two APLIC interrupt domains, one each for machine and supervisor levels.</a>,
shows a basic arrangement for a larger system designed for symmetric
multiprocessing (SMP), with multiple harts that all implement supervisor
mode. In such cases, the APLIC will usually provide a separate interrupt
domain for supervisor level, as the figure portrays. This
supervisor-level interrupt domain allows an operating system, running in
S-mode on the multiple harts, to have direct control over the interrupts
it receives, avoiding the need to call upon M-mode to exercise that
control.</p>
</div>
<div id="AdvPLIC-ex-1Domain" class="imageblock unresolved">
<div class="content">
<img src="AdvPLIC-ex-1Domain.png" alt="AdvPLIC ex 1Domain">
</div>
<div class="title">Figure 1. Example of a RISC-V system that has a single hart implementing only M-mode, with a single machine-level interrupt domain for that hart.</div>
</div>
<div class="paragraph">
<p>An APLIC&#8217;s interrupt domains are arranged in a tree hierarchy, with the
root domain always being at machine level. Incoming interrupt wires
arrive first at the root domain. Each domain may then selectively
delegate all or a subset of interrupt sources to its child domains in
the hierarchy. Within a given APLIC, interrupt source numbers are
invariant across all domains, so source identity number \(i\)
always refers to the same source in every domain, corresponding to
incoming wire number \(i\). For an interrupt domain below the
root, interrupt sources not delegated down to that domain appear to the
domain as being not implemented.</p>
</div>
<div class="paragraph">
<p><a href="#AdvPLIC-ex-3Domains">A RISC-V system that extends the example of An example system with four harts that implement M-mode and S-mode, with two APLIC interrupt domains, one each for machine and supervisor levels. with a fifth M-mode-only "manager" hart, with a separate machine-level interrupt domain above the other domains.</a> shows a hierarchy of three
interrupt domains, two at machine level and one at supervisor level. The
arrangement in the figure, when combined with PMP (physical memory
protection), allows machine-level software to isolate a selection of
interrupts exclusively for hart 0, beyond the reach of the four
application harts, even at machine level.</p>
</div>
<div id="AdvPLIC-ex-2Domains" class="imageblock unresolved">
<div class="content">
<img src="AdvPLIC-ex-2Domains.png" alt="AdvPLIC ex 2Domains">
</div>
<div class="title">Figure 2. An example system with four harts that implement M-mode and S-mode, with two APLIC interrupt domains, one each for machine and supervisor levels.</div>
</div>
<div id="AdvPLIC-ex-3Domains" class="imageblock unresolved">
<div class="content">
<img src="AdvPLIC-ex-3Domains.png" alt="AdvPLIC ex 3Domains">
</div>
<div class="title">Figure 3. A RISC-V system that extends the example of <a href="#AdvPLIC-ex-2Domains">An example system with four harts that implement M-mode and S-mode, with two APLIC interrupt domains, one each for machine and supervisor levels.</a> with a fifth M-mode-only "manager" hart, with a separate machine-level interrupt domain above the other domains.</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In order for the harts within an interrupt domain to have direct control
over the interrupts from the domain, the harts must be cooperatively
controlled by software at the same privilege level. In particular, a
single operating system should control all of the harts associated with
a supervisor-level interrupt domain. In the examples of <a href="#AdvPLIC-ex-2Domains">An example system with four harts that implement M-mode and S-mode, with two APLIC interrupt domains, one each for machine and supervisor levels.</a> and <a href="#AdvPLIC-ex-3Domains">A RISC-V system that extends the example of An example system with four harts that implement M-mode and S-mode, with two APLIC interrupt domains, one each for machine and supervisor levels. with a fifth M-mode-only "manager" hart, with a separate machine-level interrupt domain above the other domains.</a>, control
of the APLIC&#8217;s supervisor-level interrupt domain could not be safely
split among multiple independent OSes.</p>
</div>
<div class="paragraph">
<p>Given the domain hierarchies depicted in the figures, if it were
necessary to partition the application harts for multiple OSes,
machine-level software would need to prevent direct OS access to the
supervisor-level interrupt domain and instead provide SBI services for
controlling APLIC interrupts or, alternatively, emulate the control
interfaces of separate supervisor-level interrupt domains, one for each
OS. Note that such emulation might still make use of the APLIC&#8217;s
physical supervisor-level interrupt domain, but under the control of
machine-level software.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>An APLIC&#8217;s interrupt domain hierarchy satisfies these rules:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The root domain is at machine level.</p>
</li>
<li>
<p>The parent of any supervisor-level interrupt domain is a machine-level
domain that includes at least the same harts (but at machine level,
obviously). The parent domain may have a larger set of harts at machine
level.</p>
</li>
<li>
<p>For each interrupt domain, interrupts from the domain are signaled to
harts all by the same method, either by wire or by MSIs, not by a
mixture of methods among the harts.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When a RISC-V hart&#8217;s external interrupt controller is an APLIC, not an IMSIC,
the hart can be within only one interrupt domain of this APLIC at each
privilege level.</p>
</div>
<div class="paragraph">
<p>On the other hand, a hart that has an IMSIC for its external interrupt
controller may, at each privilege level, be in multiple APLIC interrupt
domains, even those of the same APLIC, and may potentially receive MSIs
from multiple different APLICs in the machine.</p>
</div>
<div class="paragraph">
<p>A platform might give software a way to choose between multiple
interrupt domain hierarchies for any given APLIC. Any such
configurability is outside the scope of this specification, but should
be available to machine level only.</p>
</div>
</div>
<div class="sect2">
<h3 id="hart-index-numbers"><a class="anchor" href="#hart-index-numbers"></a>Hart index numbers</h3>
<div class="paragraph">
<p>Within a given interrupt domain, each of the domain’s harts has a unique
<em>index number</em> in the range 0 to \({{2}^{14}-{1}}\)
(= 16,383). The index number a domain associates with a hart may or may
not have any relationship to the unique hart identifier ("hart ID")
that the Privileged Architecture assigns to the hart. Two different
interrupt domains may employ a different mapping of index numbers to the
same set of harts. However, if any of an APLIC&#8217;s interrupt domains can
forward interrupts by MSI, then all machine-level domains of the APLIC
share a common mapping of index numbers to harts.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>For efficiency, implementations should prefer small integers for hart
index numbers.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="overview-of-interrupt-control-for-a-single-domain"><a class="anchor" href="#overview-of-interrupt-control-for-a-single-domain"></a>Overview of interrupt control for a single domain</h3>
<div class="paragraph">
<p>Each interrupt domain implemented by an APLIC has its own separate
physical control interface that is memory-mapped in the machine’s
address space, allowing access to each domain to be easily regulated by
both PMP (physical memory protection) and page-based address
translation. The control interfaces of all interrupt domains have a
common structure. In most respects, every domain appears to software as
though it were a root domain, without visibility of the domains above it
in the hierarchy.</p>
</div>
<div class="paragraph">
<p>An individual interrupt domain has the following components for each
interrupt source at the APLIC:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Source configuration. This determines whether the specific source is
active in the domain and, if so, how the incoming wire is to be
interpreted, such as level-sensitive or edge-sensitive. For a source
that is inactive in the domain, source configuration controls any
delegation to a child domain.</p>
</li>
<li>
<p>Interrupt-pending and interrupt-enable bits. For an inactive source,
these two bits are read-only zeros. Otherwise, the pending bit records
an interrupt that arrived and has not yet been signaled or forwarded,
while the enable bit determines whether interrupts from this source
should currently be delivered, or should remain pending.</p>
</li>
<li>
<p>Target selection. For an active source, target selection determines
the hart to receive the interrupt and either the interrupt&#8217;s priority or
the new interrupt identity when forwarding as an MSI.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For interrupt domains that deliver interrupts directly to harts rather
than forwarding by MSIs, the domain has a final set of components for
controlling interrupt delivery to harts, one instance per hart in the
domain.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Although an APLIC with multiple interrupt domains may appear to
duplicate the per-source state listed above (source configuration,
etc.) by a factor equal to the number of domains, in fact, APLIC
implementations can exploit the fact that each source is ultimately
active in only one domain. In all domains to which a specific interrupt
source has not been delegated, the state associated with the source
appears as read-only zeros, requiring no physical register bits.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="AdvPLIC-domainControlRegion"><a class="anchor" href="#AdvPLIC-domainControlRegion"></a>Memory-mapped control region for an interrupt domain</h3>
<div class="paragraph">
<p>For each interrupt domain that an APLIC supports, there is a dedicated
memory-mapped control region for managing interrupts in that domain.
This control region is a multiple of 4 KiB in size and aligned to a
4-KiB address boundary. The smallest valid control region is 16 KiB. An
interrupt domain&#8217;s control region is populated by a set of 32-bit
registers. The first 16 KiB contains the registers listed in
<a href="#TableAdvPLIC-domainControlRegion">The registers of the first 16 KiB of an interrupt domain&#8217;s memory-mapped control region.</a>.</p>
</div>
<table id="TableAdvPLIC-domainControlRegion" class="tableblock frame-none grid-none fit-content center">
<caption class="title">Table 1. The registers of the first 16 KiB of an interrupt domain&#8217;s memory-mapped control region.</caption>
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">offset</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">size</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">register name</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x0000</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>domaincfg</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x0004</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sourcecfg[1]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x0008</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sourcecfg[2]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">…</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">…</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x0FFC</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sourcecfg[1023]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1BC0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mmsiaddrcfg</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(machine-level interrupt domains only)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1BC4</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mmsiaddrcfgh</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">”</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1BC8</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>smsiaddrcfg</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">”</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1BCC</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>smsiaddrcfgh</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">”</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1C00</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>setip[0]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1C04</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>setip[1]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">…</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">…</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1C7C</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>setip[31]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1CDC</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>setipnum</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1D00</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>in_clrip[0]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1D04</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>in_clrip[1]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">…</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">…</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1D7C</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>in_clrip[31]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1DDC</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>clripnum</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1E00</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>setie[0]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1E04</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>setie[1]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">…</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">…</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1E7C</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>setie[31]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1EDC</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>setienum</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1F00</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>clrie[0]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1F04</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>clrie[1]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">…</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">…</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1F7C</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>clrie[31]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x1FDC</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>clrienum</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x2000</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>setipnum_le</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x2004</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>setipnum_be</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x3000</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>genmsi</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x3004</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>target[1]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x3008</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>target[2]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">…</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">…</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x3FFC</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>target[1023]</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Starting at offset <code>0x4000</code>, an interrupt domain&#8217;s control region may optionally
have an array of <em>interrupt delivery control</em> (IDC) structures, one for
each potential hart index number in the range 0 to some maximum that is
at least as large as the maximum hart index number for the interrupt
domain. IDC structures are used only when the domain is configured to
deliver interrupts directly to harts instead of being forwarded by MSIs.
An interrupt domain that supports only interrupt forwarding by MSIs and
not the direct delivery of interrupts by the APLIC does not need IDC
structures in its control region.</p>
</div>
<div class="paragraph">
<p>The first IDC structure, if any, is for the hart with index number 0;
the second is for the hart with index number 1; and so forth. Each IDC
structure is 32 bytes and has these defined registers:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">offset</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">size</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">register name</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x00</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>idelivery</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x04</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>iforce</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x08</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ithreshold</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>0x18</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>topi</code></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>ox1C</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>claimi</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>IDC structures are packed contiguously, 32 bytes per structure, so the
offset from the beginning of an interrupt domain&#8217;s control region to its
second IDC structure (hart index 1), if it exists, is <code>0x4020</code>; the offset to
the third IDC structure (hart index 2), if it exists, is <code>0x4040</code>; etc.</p>
</div>
<div class="paragraph">
<p>The array of IDC structures may include some for <em>potential</em> hart index
numbers that are not <em>actual</em> hart index numbers in the domain. For
example, the first IDC structure is always for hart index 0, but 0 is
not necessarily a valid index number for any hart in the domain. For
each IDC structure in the array that does not correspond to a valid hart
index number in the domain, the IDC structure&#8217;s registers may (or may
not) be all read-only zeros.</p>
</div>
<div class="paragraph">
<p>Aside from the registers in
<a href="#TableAdvPLIC-domainControlRegion">The registers of the first 16 KiB of an interrupt domain&#8217;s memory-mapped control region.</a>
and those listed above for IDC structures, all other bytes in an
interrupt domain&#8217;s control region are reserved and are implemented as
read-only zeros.</p>
</div>
<div class="paragraph">
<p>Only naturally aligned 32-bit simple reads and writes are supported
within an interrupt domain&#8217;s control region. Writes to read-only bytes
are ignored. For other forms of accesses (other sizes, misaligned
accesses, or AMOs), implementations should preferably report an access
fault or bus error but must otherwise ignore the access.</p>
</div>
<div class="paragraph">
<p>The registers of the first 16 KiB of an interrupt domain&#8217;s control
region (all but the IDC structures) are documented individually below.
IDC structures are documented later, in
<a href="#AdvPLIC-directMode">Interrupt delivery directly by the APLIC</a>, "Interrupt delivery directly by
the APLIC."</p>
</div>
<div class="sect3">
<h4 id="AdvPLIC-reg-domaincfg"><a class="anchor" href="#AdvPLIC-reg-domaincfg"></a>Domain configuration (<code>domaincfg</code>)</h4>
<div class="paragraph">
<p>The <code>domaincfg</code> register has this format:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 31:24</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">read-only 0x80</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bit 8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bit 7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">read-only 0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bit 2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DM (<strong>WARL</strong>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bit 0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BE (<strong>WARL</strong>)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>All other register bits are reserved and read as zeros.</p>
</div>
<div class="paragraph">
<p>Bit IE (Interrupt Enable) is a global enable for all active interrupt
sources at this interrupt domain. Only when IE = 1 are
pending-and-enabled interrupts actually signaled or forwarded to harts.</p>
</div>
<div class="paragraph">
<p>The value of bit IE affects only whether interrupts are delivered to harts.
It has no effect on any other APLIC state, including
the interrupt-enable and interrupt-pending bits of interrupt sources
and IDC registers <code>idelivery</code>, <code>topi</code>, and <code>claimi</code>.</p>
</div>
<div class="paragraph">
<p>Field DM (Delivery Mode) is <strong>WARL</strong> and determines how this interrupt domain
delivers interrupts to harts. The two possible values for DM are:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">0 =</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">direct delivery mode</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">1 =</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MSI delivery mode</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>In <em>direct delivery mode</em>, interrupts are prioritized and signaled
directly to harts by the APLIC itself. In <em>MSI delivery mode</em>,
interrupts are forwarded by the APLIC as MSIs to harts, presumably for
further handling by IMSICs at those harts. A given APLIC implementation
may support either or both of these delivery modes for each interrupt
domain.</p>
</div>
<div class="paragraph">
<p>If the interrupt domain&#8217;s harts have IMSICs, then unless the relevant
interrupt files of those IMSICs support value <code>0x40000000</code> for register <code>eidelivery</code>, setting DM
to zero (direct delivery mode) will have the same effect as setting IE
to zero. See <a href="#IMSIC-reg-eidelivery">[IMSIC-reg-eidelivery]</a>
and <a href="#AdvPLIC-directMode-intrDelivery">Interrupt delivery and handling</a>.</p>
</div>
<div class="paragraph">
<p>BE (Big-Endian) is a <strong>WARL</strong> field that determines the byte order for most
registers in the interrupt domain&#8217;s memory-mapped control region. If
BE = 0, byte order is little-endian, and if BE = 1, it is big-endian.
For RISC-V systems that support only little-endian, BE may be read-only zero,
and for those that support only big-endian, BE may be read-only one. For
bi-endian systems, BE is writable.</p>
</div>
<div class="paragraph">
<p>Field BE affects the byte order of accesses to the <code>domaincfg</code> register itself, just
as for other registers in the interrupt domain’s control region. To deal
with this fact, the read-only value in <code>domaincfg’s</code> most-significant byte, bits
31:24, serves two purposes. First, for any read of <code>domaincfg</code>, the register&#8217;s correct byte order is easily determined from the four-byte value
obtained: When interpreted in the correct byte order, bit 31 is one, and
in the wrong order, bit 31 is zero. Second, if the value of BE is
uncertain (prior to software initializing the interrupt domain,
presumably), an 8-bit value \(x\) can be safely written to <code>domaincfg</code> by writing (\(x\)&lt;&lt;24)|\(x\), where &lt;&lt;24 represents
shifting left by 24 bits, and the vertical bar (|) represents bitwise
logical OR. After <code>domaincfg</code> is written once, the value of BE should then be known,
so subsequent writes should not need to repeat the same trick.</p>
</div>
<div class="paragraph">
<p>At system reset, all writable bits in <code>domaincfg</code> are initialized to zero,
including IE. If an implementation supports additional forms of reset
for the APLIC, it is implementation-defined (or possibly
platform-defined) how these other resets may affect <code>domaincfg</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="AdvPLIC-reg-sourcecfg"><a class="anchor" href="#AdvPLIC-reg-sourcecfg"></a>Source configurations (<code>sourcecfg[1]–sourcecfg[1023]</code>)</h4>
<div class="paragraph">
<p>For each possible interrupt source \(i\), register <code>sourcecfg[\(i\)]</code> controls
the <em>source mode</em> for source \(i\) in this interrupt domain as
well as any delegation of the source to a child domain. When
source \(i\) is not implemented, or appears in this domain not
to be implemented, <code>sourcecfg[\(i\)]</code> is read-only zero. If source \(i\) was not
delegated to this domain and is then changed (at the parent domain) to
become delegated to this domain, <code>sourcecfg[\(i\)]</code> remains zero until successfully written with a nonzero value.</p>
</div>
<div class="paragraph">
<p>Bit 10 of <code>sourcecfg[\(i\)]</code> is a 1-bit field called D (Delegate). If D = 1,
source \(i\) is delegated to a child domain, and if D = 0, it
is not delegated to a child domain. Interpretation of the rest of <code>sourcecfg[\(i\)]</code> depends on field D.</p>
</div>
<div class="paragraph">
<p>When interrupt source \(i\) is delegated to a child domain, <code>sourcecfg[\(i\)]</code> has this format:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bit 10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">D, =1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 9:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Child Index (<strong>WLRL</strong>)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>All other register bits are reserved and read as zeros.</p>
</div>
<div class="paragraph">
<p>Child Index is a <strong>WLRL</strong> field that specifies the interrupt domain to which this
source is delegated. For an interrupt domain with \(C\) child
domains, this field must be able to hold integer values in the range 0
to \({C-{1}}\). Each interrupt domain has a fixed mapping
from these index numbers to child domains.</p>
</div>
<div class="paragraph">
<p>If an interrupt domain has no children in the domain hierarchy, bit D
cannot be set to one in any <code>sourcecfg</code> register for that domain. For such a leaf
domain, attempting to write a <code>sourcecfg</code> register with a value that has bit 10 = 1 causes the entire register to be set to zero instead.</p>
</div>
<div class="paragraph">
<p>When interrupt source \(i\) is not delegated to a child
domain, <code>sourcecfg[\(i\)]</code> has this format:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bit 10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">D, =0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 2:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SM (<strong>WARL</strong>)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>All other register bits are reserved and read as zeros.</p>
</div>
<div class="paragraph">
<p>The SM (Source Mode) field is <strong>WARL</strong> and controls whether the interrupt source
is active in this domain, and if so, what values or transitions on the
incoming wire are interpreted as interrupts. The values allowed for SM
and their meanings are listed in
<a href="#TableAdvPLIC-sourcecfg-SM">Encoding of the SM (Source Mode) field of a sourcecfg register when bit D = 0</a>. Inactive
(zero) is always supported for field SM. Implementations are free to
choose, independently for each interrupt source, what other values are
supported for SM.</p>
</div>
<table id="TableAdvPLIC-sourcecfg-SM" class="tableblock frame-all grid-none fit-content center">
<caption class="title">Table 2. Encoding of the SM (Source Mode) field of a sourcecfg register when bit D = 0</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Value</th>
<th class="tableblock halign-center valign-top">Name</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Inactive</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Inactive in this domain (and not delegated)</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Detached</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Active, detached from the source wire</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">2–3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">—</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Reserved</em></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Edge1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Active, edge-sensitive; interrupt asserted on rising edge</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Edge0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Active, edge-sensitive; interrupt asserted on falling edge</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Level1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Active, level-sensitive; interrupt asserted when high</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">Level0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Active, level-sensitive; interrupt asserted when low</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>An interrupt source is inactive in the interrupt domain if either the
source is delegated to a child domain (D = 1) or it is not delegated
(D = 0) and SM is Inactive. Whenever interrupt source \(i\) is
inactive in an interrupt domain, the corresponding interrupt-pending and
interrupt-enable bits within the domain are read-only zeros, and
register <code>target[\(i\)]</code> is also read-only zero. If source \(i\) is changed
from inactive to an active mode, the interrupt source&#8217;s pending and
enable bits remain zeros, unless set automatically for a reason
specified later in this section or in
<a href="#AdvPLIC-pendingBits">Precise effects on interrupt-pending bits</a>, and the defined subfields of <code>target[\(i\)]</code> obtain UNSPECIFIED values.</p>
</div>
<div class="paragraph">
<p>When a source is configured as Detached, its wire input is ignored;
however, the interrupt-pending bit may still be set by a write to a <code>setip</code> or <code>setipnum</code> register. (This mode can be useful for receiving MSIs, for example.)</p>
</div>
<div class="paragraph">
<p>An edge-sensitive source can be configured to recognize an incoming
interrupt on either a rising edge (low-to-high transition) or a falling
edge (high-to-low transition). When configured for a falling edge (mode
Edge0), the source is said to be <em>inverted</em>.</p>
</div>
<div class="paragraph">
<p>A level-sensitive source can be configured to interpret either a high
level (1) or a low level (0) on the wire as the assertion of an
interrupt. When configured for a low level (mode Level0), the source is
said to be <em>inverted</em>.</p>
</div>
<div class="paragraph">
<p>For an interrupt source that is configured as edge-sensitive or
level-sensitive, define</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><em>rectified input value</em> = (incoming wire value) XOR (source is
inverted).</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>For a source that is inactive or Detached, the <em>rectified input value</em>
is zero.</p>
</div>
<div class="paragraph">
<p>Any write to a <code>sourcecfg</code> register might (or might not) cause the corresponding interrupt-pending bit to be set to one if the rectified input value is high (= 1) under the new source mode. A write to a <code>sourcecfg</code> register will not by itself cause a pending bit to be cleared except when the source is made inactive. (But see <a href="#AdvPLIC-pendingBits">Precise effects on interrupt-pending bits</a>.)</p>
</div>
</div>
<div class="sect3">
<h4 id="AdvPLIC-reg-mmsiaddrcfg"><a class="anchor" href="#AdvPLIC-reg-mmsiaddrcfg"></a>Machine MSI address configuration (<code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code>)</h4>
<div class="paragraph">
<p>For machine-level interrupt domains, registers <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code> may optionally provide parameters used to determine the addresses to write outgoing MSIs.</p>
</div>
<div class="paragraph">
<p>If no interrupt domain of the APLIC supports MSI delivery mode (<code>domaincfg</code>.DM is read-only zero for all domains), these two registers are not implemented for any domain. Otherwise, they are implemented for the root domain, and
may or may not be implemented for other machine-level domains. For
domains not at machine level, they are never implemented. When a domain
does not implement <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code>, the eight bytes at their locations are simply read-only zeros like other reserved bytes.</p>
</div>
<div class="paragraph">
<p>Registers <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code> are potentially writable only for the root domain. For all
other machine-level domains that implement them, they are read-only.</p>
</div>
<div class="paragraph">
<p>When implemented, <code>mmsiaddrcfg</code> has this format:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 31:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Low Base PPN (<strong>WARL</strong>)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>and <code>mmsiaddrcfgh</code> has this format:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bit 31</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">L</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 28:24</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HHXS (<strong>WARL</strong>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 22:20</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LHXS (<strong>WARL</strong>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 18:16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HHXW (<strong>WARL</strong>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 15:12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LHXW (<strong>WARL</strong>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 11:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">High Base PPN (<strong>WARL</strong>)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>All other bits of <code>mmsiaddrcfgh</code> are reserved and read as zeros.</p>
</div>
<div class="paragraph">
<p>Fields High Base PPN from <code>mmsiaddrcfgh</code> and Low Base PPN from <code>mmsiaddrcfg</code> concatenate to form a
44-bit Base PPN (Physical Page Number). The use of this value and fields
HHXS (High Hart Index Shift), LHXS (Low Hart Index Shift), HHXW (High
Hart Index Width), and LHXW (Low Hart Index Width) for determining
target addresses for MSIs is described later, in
<a href="#AdvPLIC-MSIAddrs">Addresses and data for outgoing MSIs</a>.</p>
</div>
<div class="paragraph">
<p>When <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code> are writable (root domain only), all fields other than L are <strong>WARL</strong>.
An implementation is free to choose what values are supported.
Typically, some bits are writable while others are read-only constants.
In the extreme, the values of all fields may be entirely constant, fixed
by the implementation.</p>
</div>
<div class="paragraph">
<p>If bit L in <code>mmsiaddrcfgh</code> is set to one, <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code> are <em>locked</em>, and writes to the registers
are ignored, making the registers effectively read-only. When L = 1, the
other fields in <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code> may optionally all read as zeros. In that case, if
these other fields were given nonzero values when L was first set in the
root domain, their values are retained internally by the APLIC but
become no longer visible by reading <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code>.</p>
</div>
<div class="paragraph">
<p>Setting <code>mmsiaddrcfgh</code>.L to one also locks registers <code>smsiaddrcfg</code> and <code>smsiaddrcfgh</code> described in the next
subsection, if those registers are implemented as well.</p>
</div>
<div class="paragraph">
<p>For the root domain, L is initialized at system reset to either zero or
one, whichever is deemed appropriate for the specific APLIC
implementation. If reset initializes L to one, either the other fields
are hardwired by the APLIC to constants, or the APLIC has a different
means, outside of this standard, for determining the addresses of
outgoing MSI writes. In the latter case, the other fields in <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code> may all
read as zeros, so registers <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code> have only read-only values zero and <code>0x80000000</code>
respectively. Any time <code>mmsiaddrcfg</code> or <code>mmsiaddrcfgh</code> has a different value (not zero or <code>0x80000000</code>
respectively), the addresses for outgoing MSI writes directed to machine
level must be derivable from the visible values of these registers, as
specified in <a href="#AdvPLIC-MSIAddrs">Addresses and data for outgoing MSIs</a>.</p>
</div>
<div class="paragraph">
<p>For machine-level domains that are not the root domain, if these
registers are implemented, bit L is always one, and the other fields
either are read-only copies of <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code> from the root domain, or are all zeros.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Giving software the ability to arbitrarily determine the addresses to
which MSIs are sent, even if allowed only for machine level, permits
bypassing physical memory protection (PMP). For APLICs that support MSI
delivery mode, it is recommended, if feasible, that the APLIC internally
hardwire the physical addresses for all target IMSICs, putting those
addresses beyond the reach of software to change. However, not all APLIC
implementations will be able to follow that recommendation.</p>
</div>
<div class="paragraph">
<p>It is expected that most systems will arrange the physical addresses of
target IMSICs in a simple linear correspondence with hart index numbers.
(See <a href="#IMSIC-systemMemRegions">[IMSIC-systemMemRegions]</a>.)
Registers <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code> (along with <code>smsiaddrcfg</code> and <code>smsiaddrcfgh</code> from the next subsection) allow
sufficiently trusted machine-level software, early after system reset,
to configure the pattern of physical addresses for target IMSICs and
then lock this configuration against subsequent tampering.</p>
</div>
<div class="paragraph">
<p>APLICs that actually hardwire the IMSIC addresses internally can
implement these registers simply as read-only with values zero and <code>0x80000000</code>. Or,
if the IMSIC addresses must be configured by software but the formula is
too complex for registers <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code> to handle, again the registers can be
implemented simply as read-only with values zero and <code>0x80000000</code>, and a separate, custom mechanism supplied for configuring the IMSIC addresses.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If an APLIC supports additional forms of reset besides system reset, it
is implementation-defined (or possibly platform-defined) how these other
resets may affect <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code> (as well as <code>smsiaddrcfg</code> and <code>smsiaddrcfgh</code>) in the root domain. However, it
must not be possible for insufficiently privileged software to use a
localized reset to unlock these registers by changing bit L back to
zero. For this reason, it is likely that only a complete system reset
affects these registers, and any other resets do not.</p>
</div>
</div>
<div class="sect3">
<h4 id="AdvPLIC-reg-smsiaddrcfg"><a class="anchor" href="#AdvPLIC-reg-smsiaddrcfg"></a>Supervisor MSI address configuration (<code>smsiaddrcfg</code> and <code>smsiaddrcfgh</code>)</h4>
<div class="paragraph">
<p>For machine-level interrupt domains, registers <code>smsiaddrcfg</code> and <code>smsiaddrcfgh</code> may optionally
provide parameters used by supervisor-level domains to determine the
addresses to write outgoing MSIs.</p>
</div>
<div class="paragraph">
<p>Registers <code>smsiaddrcfg</code> and <code>smsiaddrcfgh</code> are implemented by a domain if the domain implements <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code>
and the APLIC has at least one supervisor-level interrupt domain. If the
registers are not implemented, the eight bytes at their locations are
simply read-only zeros like other reserved bytes.</p>
</div>
<div class="paragraph">
<p>Like <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code>, registers <code>smsiaddrcfg</code> and <code>smsiaddrcfgh</code> are potentially writable only for the root
domain. For all other machine-level domains that implement them, they
are read-only.</p>
</div>
<div class="paragraph">
<p>When implemented, <code>smsiaddrcfg</code> has this format:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 31:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Low Base PPN (<strong>WARL</strong>)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>and <code>smsiaddrcfgh</code> has this format:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 22:20</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LHXS (<strong>WARL</strong>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 11:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">High Base PPN (<strong>WARL</strong>)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>All other bits of <code>smsiaddrcfgh</code> are reserved and read as zeros.</p>
</div>
<div class="paragraph">
<p>Fields High Base PPN from <code>smsiaddrcfgh</code> and Low Base PPN from <code>smsiaddrcfg</code> concatenate to form a
44-bit Base PPN (Physical Page Number). The use of this value and field
LHXS (Low Hart Index Shift) for determining target addresses for MSIs is
described later, in <a href="#AdvPLIC-MSIAddrs">Addresses and data for outgoing MSIs</a>.</p>
</div>
<div class="paragraph">
<p>When <code>smsiaddrcfg</code> and <code>smsiaddrcfgh</code> are writable (root domain only), all fields are <strong>WARL</strong>. An
implementation is free to choose what values are supported, just as for <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code>.</p>
</div>
<div class="paragraph">
<p>If register <code>mmsiaddrcfgh</code> of the domain has bit L set to one, then <code>smsiaddrcfg</code> and <code>smsiaddrcfgh</code> are <em>locked</em> as
read-only alongside <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code>. When <code>mmsiaddrcfgh.L</code> = 1, if the readable values of <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code> are
zero and <code>0x80000000</code> respectively—because their other fields are hidden—then <code>smsiaddrcfg</code> and <code>smsiaddrcfgh</code> are hidden also and read as zeros.</p>
</div>
<div class="paragraph">
<p>For the root domain only, if <code>mmsiaddrcfgh.L</code> = 1 and the MSI-address-configuration
fields are hidden (so <code>mmsiaddrcfgh</code> reads as <code>0x80000000</code> and registers <code>mmsiaddrcfg</code>, <code>smsiaddrcfg</code>, and <code>smsiaddrcfgh</code> all read as zeros),
then whatever values <code>smsiaddrcfg</code> and <code>smsiaddrcfgh</code> had when <code>mmsiaddrcfgh</code>.L was first set are retained
internally by the APLIC, though those values are no longer visible by
reading the registers. Alternatively, if system reset initializes <code>mmsiaddrcfgh.L</code> = 1
in the root domain, and if all MSI-address-configuration fields never
appear as anything other than zeros, then the APLIC implementation has
some other, possibly nonstandard, means for determining the addresses of
outgoing MSIs, as discussed in the previous subsection,
<a href="#AdvPLIC-reg-mmsiaddrcfg">Machine MSI address configuration (<code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code>)</a>.</p>
</div>
<div class="paragraph">
<p>Any time <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code> are not read-only zero and <code>0x80000000</code> respectively, the addresses for
outgoing MSI writes directed to supervisor level must be derivable from
the visible values of registers <code>mmsiaddrcfgh</code>, <code>smsiaddrcfg</code>, and <code>smsiaddrcfgh</code>, as specified in
<a href="#AdvPLIC-MSIAddrs">Addresses and data for outgoing MSIs</a>.</p>
</div>
<div class="paragraph">
<p>For machine-level domains that are not the root domain, if <code>smsiaddrcfg</code> and <code>smsiaddrcfgh</code> are
implemented and are not read-only zeros, then they are read-only copies
of the same registers from the root domain.</p>
</div>
</div>
<div class="sect3">
<h4 id="set-interrupt-pending-bits-setip0-setip31"><a class="anchor" href="#set-interrupt-pending-bits-setip0-setip31"></a>Set interrupt-pending bits (<code>setip[0]</code>-<code>setip[31]</code>)</h4>
<div class="paragraph">
<p>Reading or writing <code>setip[\(k\)]</code> register reads or potentially modifies the pending
bits for interrupt sources \(k\times{32}\) through
\(k\times{32}+{31}\). For an implemented interrupt
source \(i\) within that range, the pending bit for
source \(i\) corresponds with register bit
(\(i\bmod{32}\)).</p>
</div>
<div class="paragraph">
<p>A read of a <code>setip</code> register returns the pending bits of the corresponding
interrupt sources. Bit positions in the result value that do not
correspond to an implemented interrupt source (such as bit 0 of <code>setip[0]</code>) are zeros.</p>
</div>
<div class="paragraph">
<p>On a write to a <code>setip</code> register, for each bit that is one in the 32-bit value
written, if that bit position corresponds to an active interrupt source,
the interrupt-pending bit for that source is set to one if possible. See
<a href="#AdvPLIC-pendingBits">Precise effects on interrupt-pending bits</a> for exactly when a pending bit may
be set by writing to a <code>setip</code> register.</p>
</div>
</div>
<div class="sect3">
<h4 id="set-interrupt-pending-bit-by-number-setipnum"><a class="anchor" href="#set-interrupt-pending-bit-by-number-setipnum"></a>Set interrupt-pending bit by number (<code>setipnum</code>)</h4>
<div class="paragraph">
<p>If \(i\) is an active interrupt source number in the domain,
writing 32-bit value \(i\) to register <code>setipnum</code> causes the pending bit
for source \(i\) to be set to one if possible. See
<a href="#AdvPLIC-pendingBits">Precise effects on interrupt-pending bits</a> for exactly when a pending bit may
be set by writing to <code>setipnum</code>.</p>
</div>
<div class="paragraph">
<p>A write to <code>setipnum</code> is ignored if the value written is not an active interrupt
source number in the domain. A read of <code>setipnum</code> always returns zero.</p>
</div>
</div>
<div class="sect3">
<h4 id="rectified-inputs-clear-interrupt-pending-bits-in_clrip0-in_clrip31"><a class="anchor" href="#rectified-inputs-clear-interrupt-pending-bits-in_clrip0-in_clrip31"></a>Rectified inputs, clear interrupt-pending bits (<code>in_clrip[0]</code>-<code>in_clrip[31]</code>)</h4>
<div class="paragraph">
<p>Reading register <code>in_clrip[\(k\)]</code> returns the rectified input (<a href="#AdvPLIC-reg-sourcecfg">Source configurations (<code>sourcecfg[1]–sourcecfg[1023]</code>)</a>) for interrupt sources
\(k\times{32}\) through
\({k\times{32}+{31}}\), while writing <code>in_clrip[\(k\)]</code> potentially
modifies the pending bits for the same sources. For an implemented
interrupt source \(i\) within the specified range,
source \(i\) corresponds with register bit
(\(i\bmod{32}\)).</p>
</div>
<div class="paragraph">
<p>A read of an <code>in_clrip</code> register returns the rectified input values of the
corresponding interrupt sources. Bit positions in the result value that
do not correspond to an implemented interrupt source (such as bit 0 of <code>in_clrip[0]</code>) are zeros.</p>
</div>
<div class="paragraph">
<p>On a write to an <code>in_clrip</code> register, for each bit that is one in the 32-bit value written, if that bit position corresponds to an active interrupt source, the interrupt-pending bit for that source is cleared if possible. See
<a href="#AdvPLIC-pendingBits">Precise effects on interrupt-pending bits</a> for exactly when a pending bit may
be cleared by writing to an <code>in_clrip</code> register.</p>
</div>
</div>
<div class="sect3">
<h4 id="clear-interrupt-pending-bit-by-number-clripnum"><a class="anchor" href="#clear-interrupt-pending-bit-by-number-clripnum"></a>Clear interrupt-pending bit by number (<code>clripnum</code>)</h4>
<div class="paragraph">
<p>If \(i\) is an active interrupt source number in the domain,
writing 32-bit value \(i\) to register <code>clripnum</code> causes the pending bit
for source \(i\) to be cleared if possible. See
<a href="#AdvPLIC-pendingBits">Precise effects on interrupt-pending bits</a> for exactly when a pending bit may
be cleared by writing to <code>clripnum</code>.</p>
</div>
<div class="paragraph">
<p>A write to <code>clripnum</code> is ignored if the value written is not an active interrupt
source number in the domain. A read of <code>clripnum</code> always returns zero.</p>
</div>
</div>
<div class="sect3">
<h4 id="set-interrupt-enable-bits-setie0-setie31"><a class="anchor" href="#set-interrupt-enable-bits-setie0-setie31"></a>Set interrupt-enable bits (<code>setie[0]</code>-<code>setie[31]</code>)</h4>
<div class="paragraph">
<p>Reading or writing register <code>setie[\(k\)]</code> reads or potentially modifies the enable
bits for interrupt sources \(k\times{32}\) through
\({k\times{32}+{31}}\). For an implemented interrupt
source \(i\) within that range, the enable bit for
source \(i\) corresponds with register bit
\(i\bmod{32}\).</p>
</div>
<div class="paragraph">
<p>A read of a <code>setie</code> register returns the enable bits of the corresponding
interrupt sources. Bit positions in the result value that do not
correspond to an implemented interrupt source (such as bit 0 of <code>setie[0]</code>) are zeros.</p>
</div>
<div class="paragraph">
<p>On a write to a <code>setie</code> register, for each bit that is one in the 32-bit value
written, if that bit position corresponds to an active interrupt source,
the interrupt-enable bit for that source is set to one.</p>
</div>
</div>
<div class="sect3">
<h4 id="set-interrupt-enable-bit-by-number-setienum"><a class="anchor" href="#set-interrupt-enable-bit-by-number-setienum"></a>Set interrupt-enable bit by number (<code>setienum</code>)</h4>
<div class="paragraph">
<p>If \(i\) is an active interrupt source number in the domain,
writing 32-bit value \(i\) to register <code>setienum</code> causes the enable bit for source \(i\) to be set to one.</p>
</div>
<div class="paragraph">
<p>A write to <code>setienum</code> is ignored if the value written is not an active interrupt source number in the domain. A read of <code>setienum</code> always returns zero.</p>
</div>
</div>
<div class="sect3">
<h4 id="clear-interrupt-enable-bits-clrie0-clrie31"><a class="anchor" href="#clear-interrupt-enable-bits-clrie0-clrie31"></a>Clear interrupt-enable bits (<code>clrie[0]</code>-<code>clrie[31]</code>)</h4>
<div class="paragraph">
<p>Writing register <code>clrie[\(k\)]</code> potentially modifies the enable bits for interrupt sources \(k\times{32}\) through
\({k\times{32}+{31}}\). For an implemented interrupt
source \(i\) within that range, the enable bit for
source \(i\) corresponds with register bit
\(i\bmod{32}\).</p>
</div>
<div class="paragraph">
<p>On a write to a <code>clrie</code> register, for each bit that is one in the 32-bit value written, the interrupt-enable bit for that source is cleared.</p>
</div>
<div class="paragraph">
<p>A read of a <code>clrie</code> register always returns zero.</p>
</div>
</div>
<div class="sect3">
<h4 id="clear-interrupt-enable-bit-by-number-clrienum"><a class="anchor" href="#clear-interrupt-enable-bit-by-number-clrienum"></a>Clear interrupt-enable bit by number (<code>clrienum</code>)</h4>
<div class="paragraph">
<p>If \(i\) is an active interrupt source number in the domain,
writing 32-bit value \(i\) to register <code>clrienum</code> causes the enable bit for source \(i\) to be cleared.</p>
</div>
<div class="paragraph">
<p>A write to <code>clrienum</code> is ignored if the value written is not an active interrupt source number in the domain. A read of <code>clrienum</code> always returns zero.</p>
</div>
</div>
<div class="sect3">
<h4 id="set-interrupt-pending-bit-by-number-little-endian-setipnum_le"><a class="anchor" href="#set-interrupt-pending-bit-by-number-little-endian-setipnum_le"></a>Set interrupt-pending bit by number, little-endian (<code>setipnum_le</code>)</h4>
<div class="paragraph">
<p>Register <code>setipnum_le</code> acts identically to <code>setipnum</code> except that byte order is always little-endian, as though field BE (Big-Endian) of register <code>domaincfg</code> is zero.</p>
</div>
<div class="paragraph">
<p>For systems that are big-endian-only, with <code>domaincfg</code>.BE hardwired to one, <code>setipnum_le</code> need not be implemented, in which case the four bytes at this offset are simply read-only zeros like other reserved bytes.</p>
</div>
<div class="paragraph">
<p><code>setipnum_le</code> may be used as a write port for MSIs.</p>
</div>
</div>
<div class="sect3">
<h4 id="set-interrupt-pending-bit-by-number-big-endian-setipnum_be"><a class="anchor" href="#set-interrupt-pending-bit-by-number-big-endian-setipnum_be"></a>Set interrupt-pending bit by number, big-endian (<code>setipnum_be</code>)</h4>
<div class="paragraph">
<p>Register <code>setipnum_be</code> acts identically to <code>setipnum</code> except that byte order is always big-endian, as though field BE (Big-Endian) of register <code>domaincfg</code> is one.</p>
</div>
<div class="paragraph">
<p>For systems that are little-endian-only, with <code>domaincfg</code>.BE hardwired to zero, <code>setipnum_be</code> need not be implemented, in which case the four bytes at this offset are simply read-only zeros like other reserved bytes.</p>
</div>
<div class="paragraph">
<p>For systems built mainly for big-endian byte order, <code>setipnum_be</code> may be useful as a write port for MSIs from some devices.</p>
</div>
</div>
<div class="sect3">
<h4 id="AdvPLIC-reg-genmsi"><a class="anchor" href="#AdvPLIC-reg-genmsi"></a>Generate MSI (<code>genmsi</code>)</h4>
<div class="paragraph">
<p>When the interrupt domain is configured in MSI delivery mode (<code>domaincfg</code>.DM = 1), register <code>genmsi</code> can be used to cause an <em>extempore</em> MSI to be sent from the
APLIC to a hart. The main purpose for this function is to assist in
establishing a temporary known ordering between a hart&#8217;s writes to the
APLIC&#8217;s registers and the transmission of MSIs from the APLIC to the
hart, as explained later in <a href="#AdvPLIC-MSISync">Synchronizing interactions between a hart and the APLIC</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>For other purposes, sending an MSI to a hart is usually better done by
writing directly to the hart&#8217;s IMSIC, rather than employing an APLIC as
an intermediary. Use of the <code>genmsi</code> register should be minimized to avoid it
becoming a bottleneck.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Register <code>genmsi</code> has this format:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 31:18</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hart Index (<strong>WLRL</strong>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Busy (read-only)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 10:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">EIID (<strong>WARL</strong>)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>All other register bits are reserved and read as zeros.</p>
</div>
<div class="paragraph">
<p>The Busy bit is ordinarily zero (false), but a write to <code>genmsi</code> causes Busy to become one (true), indicating an extempore MSI is pending. The Hart
Index field specifies the destination hart, and EIID (External Interrupt
Identity) specifies the data value for the MSI. Fields Hart Index and
EIID have the same formats and behavior as in a <code>target</code> register, documented in the next subsection, <a href="#AdvPLIC-reg-target">Interrupt targets (<code>target[1]-target[1023]</code>)</a>. For a
machine-level interrupt domain, an extempore MSI is sent to the
destination hart at machine level, and for a supervisor-level interrupt
domain, an extempore MSI is sent to the destination hart at supervisor
level.</p>
</div>
<div class="paragraph">
<p>A pending extempore MSI should be sent by the APLIC with minimal delay.
Once it has left the APLIC and the APLIC is able to accept a new write
to <code>genmsi</code> for another extempore MSI, Busy reverts to false. All MSIs previously sent from this APLIC to the same hart must be visible at the hart&#8217;s IMSIC before the extempore MSI becomes visible at the hart&#8217;s IMSIC.</p>
</div>
<div class="paragraph">
<p>While Busy is true, writes to <code>genmsi</code> are ignored.</p>
</div>
<div class="paragraph">
<p>Extempore MSIs are not affected by the IE bit of the domain&#8217;s <code>domaincfg</code> register. An extempore MSI is sent even if <code>domaincfg</code>.IE = 0.</p>
</div>
<div class="paragraph">
<p>When the interrupt domain is configured in direct delivery mode (<code>domaincfg</code>.DM = 0), register <code>genmsi</code> is read-only zero.</p>
</div>
</div>
<div class="sect3">
<h4 id="AdvPLIC-reg-target"><a class="anchor" href="#AdvPLIC-reg-target"></a>Interrupt targets (<code>target[1]-target[1023]</code>)</h4>
<div class="paragraph">
<p>If interrupt source \(i\) is inactive in this domain, register <code>target[\(i\)]</code> is read-only zero. If source \(i\) is active, <code>target[\(i\)]</code> determines the
hart to which interrupts from the source are signaled or forwarded. The
exact interpretation of <code>target[\(i\)]</code> depends on the delivery mode configured by field DM of register <code>domaincfg</code>.</p>
</div>
<div class="paragraph">
<p>If <code>domaincfg</code>.DM is changed, the <code>target</code> registers for all active interrupt sources within the domain obtain UNSPECIFIED values in all fields defined for the new delivery mode.</p>
</div>
<div class="sect4">
<h5 id="active-source-direct-delivery-mode"><a class="anchor" href="#active-source-direct-delivery-mode"></a>Active source, direct delivery mode</h5>
<div class="paragraph">
<p>For an active interrupt source \(i\), if the domain is
configured in direct delivery mode (<code>domaincfg</code>.DM = 0), then register <code>target[\(i\)]</code> has this format:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 31:18</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hart Index (<strong>WLRL</strong>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 7:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IPRIO (<strong>WARL</strong>)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>All other register bits are reserved and read as zeros.</p>
</div>
<div class="paragraph">
<p>Hart Index is a <strong>WLRL</strong> field that specifies the hart to which interrupts from
this source will be delivered.</p>
</div>
<div class="paragraph">
<p>Field IPRIO (Interrupt Priority) specifies the <em>priority number</em> for the
interrupt source. This field is a <strong>WARL</strong> unsigned integer of <em>IPRIOLEN</em> bits,
where IPRIOLEN is a constant parameter for the given APLIC, in the range
of 1 to 8. Only values 1 through
\({2}^{\textrm{IPRIOLEN}} - {1}\) are allowed for
IPRIO, not zero. A write to a <code>target</code> register sets IPRIO equal to bits
\(({{IPRIOLEN} - {1}})\):0 of the 32-bit value
written, unless those bits are all zeros, in which case the priority
number is set to 1 instead. (If IPRIOLEN = 1, these rules cause IPRIO to
be effectively read-only with value 1.)</p>
</div>
<div class="paragraph">
<p>Smaller priority numbers convey higher priority. When interrupt sources
have equal priority number, the source with the lowest identity number
has the highest priority.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Interrupt priorities are encoded as integers, with smaller numbers
denoting higher priority, to match the encoding of priorities by IMSICs.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="active-source-msi-delivery-mode"><a class="anchor" href="#active-source-msi-delivery-mode"></a>Active source, MSI delivery mode</h5>
<div class="paragraph">
<p>For an active interrupt source \(i\), if the domain is
configured in MSI delivery mode (<code>domaincfg</code>.DM = 1), then register <code>target[\(i\)]</code> has this format:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 31:18</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hart Index (<strong>WLRL</strong>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 17:12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Guest Index (<strong>WLRL</strong>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bits 10:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">EIID (<strong>WARL</strong>)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Bit 11 is reserved and reads as zero.</p>
</div>
<div class="paragraph">
<p>The Hart Index field specifies the hart to which interrupts from this
source will be forwarded.</p>
</div>
<div class="paragraph">
<p>If the interrupt domain is at supervisor level and the domain&#8217;s harts
implement the H extension, then Guest Index is a <strong>WLRL</strong> field that must be able to hold all integer values in the range 0 through GEILEN. (Parameter <em>GEILEN</em> is defined by the H extension.) Otherwise, field Guest Index is read-only zero. For a supervisor-level interrupt domain, a nonzero Guest
Index is the number of the target hart&#8217;s guest interrupt file to which
MSIs will be sent. When Guest Index is zero, MSIs from a
supervisor-level domain are forwarded to the target hart at supervisor
level. For a machine-level domain, Guest Index is read-only zero, and
MSIs are forwarded to a target hart always at machine level.</p>
</div>
<div class="paragraph">
<p>Together, fields Hart Index and Guest Index of register <code>target[\(i\)]</code> determine the
address for MSIs forwarded for interrupt source \(i\). The
remaining field EIID (External Interrupt Identity) specifies the data
value for those MSIs, eventually becoming the minor identity for an
external interrupt at the target hart.</p>
</div>
<div class="paragraph">
<p>If the interrupt domain&#8217;s harts have IMSIC interrupt files that
implement \(N\) distinct interrupt identities
(<a href="#IMSIC-intrFilesAndIdents">[IMSIC-intrFilesAndIdents]</a>),
then EIID is a \(k\)-bit unsigned integer field, where
\(\lceil\log_{2}N\rceil \leq k \leq {11}\). EIID is thus
able to hold at least values 0 through \(N\). A write to a <code>target</code>
register sets the \(k\) implemented bits of EIID equal to the
least-significant \(k\) bits of the 32-bit value written.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="reset"><a class="anchor" href="#reset"></a>Reset</h3>
<div class="paragraph">
<p>Upon reset of an APLIC, all its state becomes valid and consistent but
otherwise UNSPECIFIED, except for:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the domaincfg register of each interrupt domain (<a href="#AdvPLIC-reg-domaincfg">Domain configuration (<code>domaincfg</code>)</a>);</p>
</li>
<li>
<p>possibly the MSI address configuration registers of machine-level interrupt domains (<a href="#AdvPLIC-reg-mmsiaddrcfg">Machine MSI address configuration (<code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code>)</a> and <a href="#AdvPLIC-reg-smsiaddrcfg">Supervisor MSI address configuration (<code>smsiaddrcfg</code> and <code>smsiaddrcfgh</code>)</a>); and</p>
</li>
<li>
<p>the Busy bit of each interrupt domain&#8217;s <code>genmsi</code> register, if it exists (<a href="#AdvPLIC-reg-genmsi">Generate MSI (<code>genmsi</code>)</a>).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="AdvPLIC-pendingBits"><a class="anchor" href="#AdvPLIC-pendingBits"></a>Precise effects on interrupt-pending bits</h3>
<div class="paragraph">
<p>An attempt to set or clear an interrupt source&#8217;s pending bit by writing
to a register in the interrupt domain&#8217;s control region may or may not be
successful, depending on the corresponding source mode, the interrupt
domain&#8217;s delivery mode, and the state of the source&#8217;s rectified input
value (defined in <a href="#AdvPLIC-reg-sourcecfg">Source configurations (<code>sourcecfg[1]–sourcecfg[1023]</code>)</a>). The
following enumerates all the circumstances when a pending bit is set or
cleared for a given source mode.</p>
</div>
<div class="paragraph">
<p>If the source mode is Detached:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The pending bit is set to one only by a relevant write to a <code>setip</code> or <code>setipnum</code> register.</p>
</li>
<li>
<p>The pending bit is cleared when the interrupt is claimed at the APLIC
or forwarded by MSI, or by a relevant write to an <code>in_clrip</code> register or to <code>clripnum</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the source mode is Edge1 or Edge0:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The pending bit is set to one by a low-to-high transition in the
rectified input value, or by a relevant write to a <code>setip</code> or <code>setipnum</code> register.</p>
</li>
<li>
<p>The pending bit is cleared when the interrupt is claimed at the APLIC
or forwarded by MSI, or by a relevant write to an <code>in_clrip</code> register or to <code>clripnum</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the source mode is Level1 or Level0 and the interrupt domain is
configured in direct delivery mode (<code>domaincfg</code>.DM = 0):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The pending bit is set to one whenever the rectified input value is
high. The pending bit cannot be set by a write to a <code>setip</code> or <code>setipnum</code> register.</p>
</li>
<li>
<p>The pending bit is cleared whenever the rectified input value is low.
The pending bit is not cleared by a claim of the interrupt at the APLIC,
nor can it be cleared by a write to an <code>in_clrip</code> register or to <code>clripnum</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the source mode is Level1 or Level0 and the interrupt domain is
configured in MSI delivery mode (<code>domaincfg</code>.DM = 1):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The pending bit is set to one by a low-to-high transition in the
rectified input value. The pending bit may also be set by a relevant
write to a <code>setip</code> or <code>setipnum</code> register when the rectified input value is high, but not when the rectified input value is low.</p>
</li>
<li>
<p>The pending bit is cleared whenever the rectified input value is low,
when the interrupt is forwarded by MSI, or by a relevant write to an <code>in_clrip</code> register or to <code>clripnum</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When an interrupt domain is in direct delivery mode, the pending bit for
a level-sensitive source is always just a copy of the rectified input
value. Even in MSI delivery mode, the pending bit for a level-sensitive
source is never set (= 1) when the rectified input value is low.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In addition to the rules above, a write to a <code>sourcecfg</code> register can cause the
source’s interrupt-pending bit to be set to one, as specified in
<a href="#AdvPLIC-reg-sourcecfg">Source configurations (<code>sourcecfg[1]–sourcecfg[1023]</code>)</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="AdvPLIC-directMode"><a class="anchor" href="#AdvPLIC-directMode"></a>Interrupt delivery directly by the APLIC</h3>
<div class="paragraph">
<p>When an interrupt domain is in direct delivery mode (<code>domaincfg</code>.DM = 0),
interrupts are delivered from the APLIC to harts by a unique signal to
each hart, usually a dedicated wire. In this case, the domain&#8217;s
memory-mapped control region contains at the end an array of interrupt
delivery control (IDC) structures, one IDC structure per potential hart
index. The first IDC structure is for the domain&#8217;s hart with index 0;
the second is for the hart with index 1; etc.</p>
</div>
<div class="sect3">
<h4 id="AdvPLIC-IDC"><a class="anchor" href="#AdvPLIC-IDC"></a>Interrupt delivery control (IDC) structure</h4>
<div class="paragraph">
<p>Each IDC structure is 32 bytes (naturally aligned to a 32-byte address
boundary) and has these defined registers:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">offset</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">size</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">register name</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x00</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>idelivery</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ox04</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>iforce</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x08</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ithreshold</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x18</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>topi</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0x1C</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 bytes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>claimi</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>If the IDC structure is for a hart index number that is not valid for
any actual hart in the interrupt domain, then these registers may
optionally be all read-only zeros. Otherwise, the registers are
documented individually below.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A particular APLIC might be built to support up to some maximum number
of harts without complete knowledge of the set of hart index numbers the
system will employ in each interrupt domain. In that case, for the hart
index numbers that are unused, the APLIC may have IDC structures that
are functional within the APLIC (not read-only zeros) but simply left
unconnected to any physical harts.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="interrupt-delivery-enable-idelivery"><a class="anchor" href="#interrupt-delivery-enable-idelivery"></a>Interrupt delivery enable (<code>idelivery</code>)</h5>
<div class="paragraph">
<p><code>idelivery</code> is a <strong>WARL</strong> register that controls whether interrupts that are targeted to the corresponding hart are delivered to the hart so they appear as a pending interrupt in the hart&#8217;s <code>mip</code> CSR. Only two values are currently defined for <code>idelivery</code>:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">0 =</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">interrupt delivery is disabled</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">1 =</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">interrupt delivery is enabled</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The <code>idelivery</code> register affects only whether
interrupts are delivered to the relevant hart.
It has no effect on any other APLIC state,
including IDC registers <code>topi</code> and <code>claimi</code>.</p>
</div>
<div class="paragraph">
<p>If an IDC structure is for a nonexistent hart (i.e., corresponding to a
hart index number that is not valid for any actual hart in the interrupt
domain), setting <code>idelivery</code> to 1 does not deliver interrupts to any hart.</p>
</div>
</div>
<div class="sect4">
<h5 id="interrupt-force-iforce"><a class="anchor" href="#interrupt-force-iforce"></a>Interrupt force (<code>iforce</code>)</h5>
<div class="paragraph">
<p><code>iforce</code> is a <strong>WARL</strong> register useful for testing. Only values 0 and 1 are allowed. Setting <code>iforce</code> = 1 forces an interrupt to be asserted to the corresponding hart whenever both the IE field of <code>domaincfg</code> is one and interrupt delivery is enabled to the hart by the <code>idelivery</code> register. When <code>topi</code> is zero, this creates a <em>spurious external interrupt</em> for the hart.</p>
</div>
<div class="paragraph">
<p>When a read of register <code>claimi</code> returns an interrupt identity of zero
(indicating a spurious interrupt), <code>iforce</code> is automatically cleared to zero.</p>
</div>
</div>
<div class="sect4">
<h5 id="interrupt-enable-threshold-ithreshold"><a class="anchor" href="#interrupt-enable-threshold-ithreshold"></a>Interrupt enable threshold (<code>ithreshold</code>)</h5>
<div class="paragraph">
<p><code>ithreshold</code> is a <strong>WLRL</strong> register that determines the minimum interrupt priority (maximum priority number) for an interrupt to be signaled to the corresponding hart. Register <code>ithreshold</code> implements exactly IPRIOLEN bits, and thus is capable of
holding all priority numbers from 0 to
\({{2}^{\textrm{IPRIOLEN}} - {1}}\).</p>
</div>
<div class="paragraph">
<p>When <code>ithreshold</code> is a nonzero value \(P\), interrupt sources with priority
numbers \(P\) and higher do not contribute to signaling
interrupts to the hart, as though those sources were not enabled,
regardless of the settings of their interrupt-enable bits. When <code>ithreshold</code> is zero, all enabled interrupt sources can contribute to signaling interrupts to the hart.</p>
</div>
</div>
<div class="sect4">
<h5 id="top-interrupt-topi"><a class="anchor" href="#top-interrupt-topi"></a>Top interrupt (<code>topi</code>)</h5>
<div class="paragraph">
<p><code>topi</code> is a read-only register whose value indicates the current
highest-priority pending-and-enabled interrupt targeted to this hart
that also exceeds the priority threshold specified by <code>ithreshold</code>, if not zero.</p>
</div>
<div class="paragraph">
<p>A read of <code>topi</code> returns zero either if no interrupt that is targeted to this
hart is both pending and enabled, or if <code>ithreshold</code> is not zero and no
pending-and-enabled interrupt targeted to this hart has a priority
number less than the value of <code>ithreshold</code>. Otherwise, the value returned from a read of <code>topi</code> has this format:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">bits 25:16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interrupt identity (source number)</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock">bits 7:0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interrupt priority</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>All other bit positions are zeros.</p>
</div>
<div class="paragraph">
<p>The interrupt identity reported in <code>topi</code> is the minor identity for an external interrupt at the target hart.</p>
</div>
<div class="paragraph">
<p>The value of <code>topi</code> is not affected by <code>domaincfg</code>.IE or by <code>idelivery</code>.</p>
</div>
<div class="paragraph">
<p>Writes to <code>topi</code> are ignored.</p>
</div>
</div>
<div class="sect4">
<h5 id="claim-top-interrupt-claimi"><a class="anchor" href="#claim-top-interrupt-claimi"></a>Claim top interrupt (<code>claimi</code>)</h5>
<div class="paragraph">
<p>Register <code>claimi</code> has the same value as <code>topi</code>. When this value is not zero, reading <code>claimi</code> has the simultaneous side effect of clearing the pending bit for the reported interrupt identity, if possible. See
<a href="#AdvPLIC-pendingBits">Precise effects on interrupt-pending bits</a> for exactly when the pending bit
is cleared by a read of <code>claimi</code>.</p>
</div>
<div class="paragraph">
<p>A read from <code>claimi</code> that returns a value of zero has the simultaneous side
effect of setting the <code>iforce</code> register to zero.</p>
</div>
<div class="paragraph">
<p>Writes to <code>claimi</code> are ignored.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="AdvPLIC-directMode-intrDelivery"><a class="anchor" href="#AdvPLIC-directMode-intrDelivery"></a>Interrupt delivery and handling</h4>
<div class="paragraph">
<p>When an interrupt domain is configured so the APLIC delivers interrupts
directly to harts (field DM of <code>domaincfg</code> is zero), the APLIC supplies the
<em>external interrupt</em> signals, at the domain’s privilege level, for all
harts of the domain, so long as one of the following is true: (a) the
harts do not have IMSICs, or (b) the <code>eidelivery</code> registers of the relevant IMSIC
interrupt files are set to <code>0x40000000</code> (<a href="#IMSIC-reg-eidelivery">[IMSIC-reg-eidelivery]</a>). For a
machine-level domain, the interrupt signals from the APLIC appear as bit
MEIP (Machine External Interrupt-Pending) in each hart&#8217;s <code>mip</code> CSR. For a
supervisor-level domain, the interrupt signals appear as bit SEIP
(Supervisor External Interrupt-Pending) in each hart&#8217;s <code>mip</code> and <code>sip</code> CSRs. Each
interrupt signal may be arbitrarily delayed traveling from the APLIC to
the proper hart.</p>
</div>
<div class="paragraph">
<p>At the APLIC, each interrupt signal to a hart is derived from the IE
field of register <code>domaincfg</code> and the current state of the hart&#8217;s IDC structure in
the memory-mapped control region for the domain. If either <code>domaincfg</code>.IE = 0 or
interrupt delivery to the hart is disabled by the <code>idelivery</code> register (<code>idelivery</code> = 0), the
interrupt signal is held de-asserted. When <code>domaincfg</code>.IE = 1 and interrupt
delivery is enabled (<code>idelivery</code> = 1), the interrupt signal is asserted whenever either register <code>iforce</code> or <code>topi</code> is not zero.</p>
</div>
<div class="paragraph">
<p>Due to likely delay in the communication between an APLIC and a hart, it
may happen that an external interrupt trap is taken, yet no interrupt is
pending and enabled for the hart when a read of the hart&#8217;s <code>claimi</code> register
actually occurs. In such a circumstance, the interrupt identity reported
by the claim will be zero, resulting in an apparent <em>spurious interrupt</em>
from the APLIC. Portable software must be prepared for the possibility
of spurious interrupts at the APLIC, which can safely be ignored and
should be rare. For testing purposes, a spurious interrupt can be
triggered for a hart by setting an IDC structure&#8217;s <code>iforce</code> register to 1.</p>
</div>
<div class="paragraph">
<p>A trap handler solely for external interrupts via an APLIC could be
written roughly as follows:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">save processor registers</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">i = read register <code>claimi</code> from the hart&#8217;s IDC structure at the APLIC</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">i = i&gt;&gt;16</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">call the interrupt handler for external interrupt \(i\) (minor identity)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">restore processor registers</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">return from trap</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>To account for spurious interrupts, this pseudocode assumes there is an
interrupt handler for "external interrupt 0" which does nothing.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="interrupt-forwarding-by-msis"><a class="anchor" href="#interrupt-forwarding-by-msis"></a>Interrupt forwarding by MSIs</h3>
<div class="paragraph">
<p>In MSI delivery mode (<code>domaincfg</code>.DM = 1), an interrupt domain forwards interrupts to target harts by MSIs.</p>
</div>
<div class="paragraph">
<p>An MSI is sent for a specific source only when the source&#8217;s
corresponding pending and enable bits are both one and the IE field of
register <code>domaincfg</code> is also one. If and when an MSI is sent, the source&#8217;s interrupt pending bit is cleared.</p>
</div>
<div class="sect3">
<h4 id="AdvPLIC-MSIAddrs"><a class="anchor" href="#AdvPLIC-MSIAddrs"></a>Addresses and data for outgoing MSIs</h4>
<div class="paragraph">
<p>To forward interrupts by MSIs, an APLIC must know the MSI target address
for each hart. For any given system, these addresses are fixed and
should be hardwired into the APLIC if possible. However, some APLIC
implementations may require that software supply the MSI target
addresses. In that case, the root domain&#8217;s registers <code>mmsiaddrcfg</code>, <code>mmsiaddrcfgh</code>, <code>smsiaddrcfg</code>, and <code>smsiaddrcfgh</code> (<a href="#AdvPLIC-reg-mmsiaddrcfg">Machine MSI address configuration (<code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code>)</a>
and <a href="#AdvPLIC-reg-smsiaddrcfg">Supervisor MSI address configuration (<code>smsiaddrcfg</code> and <code>smsiaddrcfgh</code>)</a>) may be used to configure the
MSI addresses for all interrupt domains. Alternatively MSI addresses may
be configured by some custom means outside this standard. If MSI target
addresses must be configured by software, this should be done only from
a suitably privileged execution mode, typically just once, early after
system reset.</p>
</div>
<div class="paragraph">
<p>For a machine-level interrupt domain, if MSI target addresses are
determined by <code>mmsiaddrcfg</code> and <code>mmsiaddrcfgh</code>, then the address for an outgoing MSI for interrupt
source \(i\) is computed from those registers and from the
Hart Index field of register <code>target[\(i\)]</code> as follows:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">g = (Hart Index&gt;&gt;LHXW) &amp; (2<sup>HHXW</sup> - 1)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">h = Hart Index &amp; (2<sup>LHXW</sup> -1)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MSI address = ( Base PPN | (g&lt;&lt;(HHXS+12)) | (h&lt;&lt;LHXS) )&lt;&lt;12</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Here, \(&lt;&lt;k$\) and \(&gt;&gt;k$\) represent shifting left
and right by \(k\) bits, an ampersand (&amp;) represents bitwise
logical AND, and a vertical bar (|) represents bitwise logical OR.
Assuming the recommendations of <a href="#IMSIC-systemMemRegions">[IMSIC-systemMemRegions]</a> are
followed for the arrangement of IMSIC interrupt files in the machine&#8217;s
address space, value \(g\) is intended to be the number of a
hart group (always zero if HHXW = 0), while \(h\) is the
number of the target hart within that group. Represented in the terms of
<a href="#IMSIC-systemMemRegions">[IMSIC-systemMemRegions]</a>, HHXW = \(j\), LHXW = \(k\), HHXS = \({E-24}\), LHXS = \({C-12}\), and Base PPN = \(A\)&gt;&gt;12.</p>
</div>
<div class="paragraph">
<p>For a supervisor-level domain, if MSI target addresses are determined by
the root domain&#8217;s configuration registers (<code>smsiaddrcfg</code> and others), then to
construct the address for an outgoing MSI for interrupt
source \(i\), the Hart Index from register <code>target[\(i\)]</code> must first be
converted into the index number that machine-level domains use for the
same hart. (These numbers are often the same, but they may not be.) The
address for the MSI is then computed using this machine-level hart index
together with the Base PPN and LHXS values from <code>smsiaddrcfg</code> and <code>smsiaddrcfgh</code>, the other fields
(HHXW, LHXW, and HHXS) from <code>mmsiaddrcfgh</code>, and the Guest Index from <code>target[\(i\)]</code>, as follows:</p>
</div>
<table class="tableblock frame-none grid-none fit-content center">
<colgroup>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">g = (machine-level hart index&gt;&gt;LHXW) &amp; (2<sup>HHXW</sup> - 1)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">h = machine-level hart index &amp; (2<sup>LHXW</sup> - 1)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MSI address = (Base PPN | (g&lt;&lt;(HHXS + 12)) | (h&lt;&lt;LHXS) | Guest Index)&lt;&lt;12</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Represented in the terms of
<a href="#IMSIC-systemMemRegions">[IMSIC-systemMemRegions]</a>, HHXW = \(j\), LHXW = \(k\), HHXS = \({E-24}\), LHXS = \({D-12}\), and Base PPN = \(B\)&gt;&gt;12.</p>
</div>
<div class="paragraph">
<p>The data for an outgoing MSI write is taken from the EIID field of <code>target[\(i\)]</code>, zero-extended to 32 bits. An MSI&#8217;s 32-bit data is always written in
little-endian byte order, regardless of the BE field of the domain&#8217;s <code>domaincfg</code>
register.</p>
</div>
</div>
<div class="sect3">
<h4 id="special-consideration-for-level-sensitive-interrupt-sources"><a class="anchor" href="#special-consideration-for-level-sensitive-interrupt-sources"></a>Special consideration for level-sensitive interrupt sources</h4>
<div class="paragraph">
<p>As soon as a level-sensitive interrupt is forwarded by MSI, the APLIC
clears the pending bit for the interrupt source and then ignores the
source until its incoming signal has been de-asserted. Clearing the
pending bit when an MSI is sent is obviously necessary to avoid a
constant stream of repeated MSIs from the APLIC to the target hart for
the same interrupt. However, after an interrupt service routine has
addressed a cause found for the interrupt, the incoming interrupt wire
might remain asserted at the APLIC for another reason, despite that the
interrupt&#8217;s pending bit at the APLIC was cleared and will remain so
without intervention from software. If the interrupt service routine
then exits without further action, a continued interrupt from this
source might never receive attention.</p>
</div>
<div class="paragraph">
<p>To avoid dropping interrupts in this way, the interrupt service routine
for a level-sensitive interrupt may do one of the following before
exiting:</p>
</div>
<div class="paragraph">
<p>The first option is to test whether the interrupt wire into the APLIC is
still asserted, by reading the appropriate <code>in_clrip</code> register at the APLIC. If the
incoming interrupt is still asserted, the body of the interrupt service
routine may be repeated to find and address an additional interrupt
cause before the source wire is tested again. Once the incoming wire is
observed not asserted, the interrupt service routine may safely exit, as
any new interrupt assertion will cause the pending bit to become set and
a new MSI sent to the hart.</p>
</div>
<div class="paragraph">
<p>A second option is for the interrupt service routine to write the
APLIC&#8217;s source identity number for the interrupt to the domain&#8217;s <code>setipnum</code>
register just before exiting. This will cause the interrupt&#8217;s pending
bit to be set to one again if the source is still asserting an
interrupt, but not if the source is not asserting an interrupt.</p>
</div>
</div>
<div class="sect3">
<h4 id="AdvPLIC-MSISync"><a class="anchor" href="#AdvPLIC-MSISync"></a>Synchronizing interactions between a hart and the APLIC</h4>
<div class="paragraph">
<p>When an APLIC sends an MSI to a hart, there is an unspecified travel
delay before the MSI is observed at the hart&#8217;s IMSIC. Consequently,
after an APLIC&#8217;s configuration is changed by writing to an APLIC
register, harts may continue to see MSIs arrive from the APLIC from the
time before the write, for an unspecified amount of time.</p>
</div>
<div class="paragraph">
<p>It is sometimes necessary to know when no more of these late MSIs can
arrive. For example, if a hart will be turned off ("powered down"),
all interrupts directed to it must be redirected to other harts, which
may involve reconfiguring one or more APLICs. Even after the APLICs are
reconfigured, the hart still cannot be safely turned off until it is
known no more MSIs are destined for it.</p>
</div>
<div class="paragraph">
<p>The <code>genmsi</code> register (<a href="#AdvPLIC-reg-genmsi">Generate MSI (<code>genmsi</code>)</a>) exists to allow
software to determine when all earlier MSIs have arrived at a hart. To
use <code>genmsi</code> for this purpose, software can dedicate one external interrupt
identity at each hart&#8217;s IMSIC interrupt file solely for APLIC
synchronization. Assuming there are multiple harts, an APLIC&#8217;s <code>genmsi</code> register
should also be protected by a standard mutual-exclusion lock. The
following sequence can then be used to synchronize between an APLIC and
a specific hart:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>At the hart&#8217;s IMSIC, clear the pending bit for the specific minor
interrupt identity \(i\) used exclusively for APLIC
synchronization.</p>
</li>
<li>
<p>Acquire the shared lock for the APLIC&#8217;s <code>genmsi</code> register.</p>
</li>
<li>
<p>Write <code>genmsi</code> to generate an MSI to the hart with interrupt
identity \(i\).</p>
</li>
<li>
<p>Repeatedly read <code>genmsi</code> until bit Busy is false.</p>
</li>
<li>
<p>Release the lock for <code>genmsi</code>.</p>
</li>
<li>
<p>Repeatedly read the pending bit for minor interrupt identity
\(i\) at the hart&#8217;s IMSIC until it is found set.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The loops of steps 4 and 6 are expected normally to succeed very
quickly, often on the first or second attempt. When this sequence is
complete, all earlier MSIs from the APLIC must also have arrived at the
hart&#8217;s IMSIC.</p>
</div>
</div>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="IMSIC.html">Incoming MSI Controller (IMSIC)</a></span>
  <span class="next"><a href="MSLevel.html">Interrupts for Machine and Supervisor Levels</a></span>
</nav>
</article>  </div>
</main>
<div class="modal micromodal-slide" id="modal-versions" aria-hidden="true">
    <div class="modal__overlay" tabindex="-1" data-micromodal-close>
        <div class="modal__container" role="dialog" aria-modal="true">
            <main class="modal__content" id="modal-versions-content">
              <button data-micromodal-close class="modal-versions-close">
                <svg width="28px" height="28px" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><defs><style>.cls-1h{fill:none;stroke:#000;stroke-linecap:round;stroke-linejoin:round;stroke-width:2px;}</style></defs><title/><g id="cross"><line class="cls-1h" x1="7" x2="25" y1="7" y2="25"/><line class="cls-1h" x1="7" x2="25" y1="25" y2="7"/></g></svg>
              </button>
              <div class="colset">
                <div class="col-left">

                  <ul class="nav-versions">
                      <li class="component">
                        <div>
                          <a class="title" href="../../ffh/v1.0/index.html">ACPI Functional Fixed Hardware</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../ffh/v1.0/index.html">
      v1.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="index.html">Advanced Interrupt Architecture</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="index.html">
      v1.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="../../etrace/v1.0/index.html">E-Trace Encapsulation Specification</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../etrace/v1.0/index.html">
      v1.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="../../psabi/v1.0/index.html">ELF psABI Specification</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../psabi/v1.0/index.html">
      v1.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="../../iommuArch/v1.0/index.html">IOMMU Architecture</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../iommuArch/v1.0/index.html">
      v1.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="../../isa/index.html">ISA Specifications</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../isa/index.html">
      default
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="../../reri/v1.0/index.html">RERI Architecture</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../reri/v1.0/index.html">
      v1.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="../../qos/v1.0/index.html">RISC-V Capacity and Bandwidth QoS Register Interface</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../qos/v1.0/index.html">
      v1.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="../../plic/v1.0.0/index.html">RISC-V Platform-Level Interrupt Controller</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../plic/v1.0.0/index.html">
      v1.0.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                      <li class="component">
                        <div>
                          <a class="title" href="../../semihost/v1.0/index.html">semihosting</a>
                        </div>                        <div class="version-item is-active">
                          <div>
                            <button class="version-toggle" type="button">
                              <span></span>
                              Stable
                            </button>
                          </div>
                          <ul class="versions">
  <li class="version">
    <a href="../../semihost/v1.0/index.html">
      v1.0
    </a>
  </li>
</ul>                        </div>
                        
                      </li>
                  </ul>
                </div>
                <div class="col-right">
                  <ul class="projects">
  <li>
    Related Spring Documentation
    <ul class="projects-list">
        <li>
<a href="https://docs.spring.io/spring-boot/">
  Spring Boot
</a>
</li>
        <li>
<a href="https://docs.spring.io/spring-framework/reference/">
  Spring Framework
</a>
</li>
        <li>
<a class="anchor"><i class="fa fa-angle-right" aria-hidden="true"></i></a>
  Spring Cloud
<ul>
    <li>
<a href="https://docs.spring.io/spring-cloud-build/reference/">
  Spring Cloud Build
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-bus/reference/">
  Spring Cloud Bus
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-circuitbreaker/reference/">
  Spring Cloud Circuit Breaker
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-commons/reference/">
  Spring Cloud Commons
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-config/reference/">
  Spring Cloud Config
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-consul/reference/">
  Spring Cloud Consul
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-contract/reference/">
  Spring Cloud Contract
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-function/reference/">
  Spring Cloud Function
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-gateway/reference/">
  Spring Cloud Gateway
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-kubernetes/reference/">
  Spring Cloud Kubernetes
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-netflix/reference/">
  Spring Cloud Netflix
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-openfeign/reference/">
  Spring Cloud OpenFeign
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-stream/reference/">
  Spring Cloud Stream
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-task/reference/">
  Spring Cloud Task
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-vault/reference/">
  Spring Cloud Vault
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-cloud-zookeeper/reference/">
  Spring Cloud Zookeeper
</a>
</li>
</ul>
</li>
        <li>
<a class="anchor"><i class="fa fa-angle-right" aria-hidden="true"></i></a>
  Spring Data
<ul>
    <li>
<a href="https://docs.spring.io/spring-data/cassandra/reference/">
  Spring Data Cassandra
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-data/commons/reference/">
  Spring Data Commons
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-data/couchbase/reference/">
  Spring Data Couchbase
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-data/elasticsearch/reference/">
  Spring Data Elasticsearch
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-data/jpa/reference/">
  Spring Data JPA
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-data/keyvalue/reference/">
  Spring Data KeyValue
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-data/ldap/reference/">
  Spring Data LDAP
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-data/mongodb/reference/">
  Spring Data MongoDB
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-data/neo4j/reference/">
  Spring Data Neo4j
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-data/redis/reference/">
  Spring Data Redis
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-data/relational/reference/">
  Spring Data JDBC &amp; R2DBC
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-data/rest/reference/">
  Spring Data REST
</a>
</li>
</ul>
</li>
        <li>
<a href="https://docs.spring.io/spring-integration/reference/">
  Spring Integration
</a>
</li>
        <li>
<a href="https://docs.spring.io/spring-batch/reference/">
  Spring Batch
</a>
</li>
        <li>
<a class="anchor"><i class="fa fa-angle-right" aria-hidden="true"></i></a>
<a href="https://docs.spring.io/spring-security/reference/">
  Spring Security
</a>
<ul>
    <li>
<a href="https://docs.spring.io/spring-authorization-server/reference/">
  Spring Authorization Server
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-ldap/reference/">
  Spring LDAP
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-security-kerberos/reference/">
  Spring Security Kerberos
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-session/reference/">
  Spring Session
</a>
</li>
    <li>
<a href="https://docs.spring.io/spring-vault/reference/">
  Spring Vault
</a>
</li>
</ul>
</li>
        <li>
<a href="https://docs.spring.io/spring-ai/reference/">
  Spring AI
</a>
</li>
        <li>
<a href="https://docs.spring.io/spring-amqp/reference/">
  Spring AMQP
</a>
</li>
        <li>
<a href="https://docs.spring.io/spring-cli/reference/">
  Spring CLI
</a>
</li>
        <li>
<a href="https://docs.spring.io/spring-graphql/reference/">
  Spring GraphQL
</a>
</li>
        <li>
<a href="https://docs.spring.io/spring-kafka/reference/">
  Spring for Apache Kafka
</a>
</li>
        <li>
<a href="https://docs.spring.io/spring-modulith/reference/">
  Spring Modulith
</a>
</li>
        <li>
<a href="https://docs.spring.io/spring-pulsar/reference/">
  Spring for Apache Pulsar
</a>
</li>
        <li>
<a href="https://docs.spring.io/spring-shell/reference/">
  Spring Shell
</a>
</li>
    </ul>
  </li
  <li><a href="../../spring-projects.html">All Docs...</a></li>
</ul>
                </div>
              </div>
            </main>
        </div>
    </div>
</div>

</div>
<footer class="hidden">
</footer><script src="../../_/js/vendor/import.js"></script>
<script src="../../_/js/site.js"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
<script async src="../../_/js/vendor/spring-tabs.js" data-sync-storage-key="docs:preferred-tab"></script>
  </body>
</html>
